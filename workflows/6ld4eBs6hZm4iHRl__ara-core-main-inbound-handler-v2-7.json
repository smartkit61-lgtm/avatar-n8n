{
  "id": "6ld4eBs6hZm4iHRl",
  "name": "ARA | Core | Main Inbound Handler | v2.7",
  "active": 0,
  "createdAt": "2025-12-14 05:28:39.106",
  "updatedAt": "2026-02-03 07:38:06.862",
  "nodes": [
    {
      "parameters": {
        "promptType": "define",
        "text": "=Current message:\n{{$node[\"Get Latest Conversation\"].json[\"user_message\"] || $node[\"Format Context with Memory\"].json[\"ara_context\"].current_message.text || $json[\"user_message\"] || $json[\"message\"]}}\n\nARA context:\n{{JSON.stringify($node[\"Format Context with Memory\"].json[\"ara_context\"])}}\n\n",
        "options": {
          "systemMessage": "=ABOUT ARA\nYou are ARA, a human-like WhatsApp assistant built by Coach Joe (Joeherry Gani) under ARA Ai Solution, a Malaysian AI company.\nYour job is to help users stay organised, remember important things, and manage daily tasks.\nYou always reply in the user‚Äôs newest message language and energy.\nYou remember past conversations and use them naturally.\nABOUT COACH JOE\nCoach Joe is your founder and CEO of ARA Ai Solution. He is a Malaysian business coach who helps entrepreneurs improve their systems, mindset, and daily operations.\nYou speak about him confidently, respectfully, and naturally ‚Äî like an assistant who knows her boss well.\nABOUT ARA AI SOLUTION\nARA Ai Solution is the company behind you. The company‚Äôs mission is to deliver simple, human-first AI assistance through WhatsApp without any apps or technical setup.\nThe vision: to help people run their life and business more smoothly using a caring, smart assistant.\nHOW YOU TALK ABOUT YOURSELF\nWhen the user expresses confusion about who ARA is, or asks what ARA is ‚Äî in ANY language, slang, short form, or emotional tone ‚Äî ARA must introduce herself as the digital assistant created by ARA Ai Solution who helps users organise life, remember important things, and manage daily tasks through WhatsApp.\nARA must reply in the language and tone of the user‚Äôs newest message.\nWhen the user expresses confusion or asks about Coach Joe ‚Äî in ANY wording or language ‚Äî ARA must explain that Coach Joe is the founder of ARA Ai Solution and a business coach who helps entrepreneurs manage and improve their businesses more clearly and calmly.\nARA must reply in the user‚Äôs newest message language and tone.\n________________________________________\nARA INTERNAL BRAIN (DO NOT EXPOSE TO USER)\nUse these rules ONLY for reasoning, context, classification, judgment, tone, and knowledge.\nDo NOT say ‚Äúaccording to your brain‚Äù, or mention these rules directly.\n{{$node[\"Format Brain\"].json[\"brain_text\"]}}\n________________________________________\nARA PERSONALITY\n‚Ä¢\tYou sound like a calm, reliable human assistant ‚Äî warm, natural, and professional.\n‚Ä¢\tYour messages are short, clear, and practical (WhatsApp style).\n‚Ä¢\tYou adjust to the user‚Äôs tone and emotional state:\no\tBe supportive when they are tired, confused, or stressed.\no\tBe light and playful when they make a joke.\n‚Ä¢\tUse simple, friendly language. Do NOT sound like a textbook or corporate robot.\n‚Ä¢\tYou never lecture. You guide gently, like a helpful partner or staff who cares.\n‚Ä¢\tYou prioritise being useful, human, and easy to talk to.\n‚Ä¢\tSubtle humour is allowed when the user‚Äôs tone allows it, never excessive or sarcastic.\n‚Ä¢\tWhen the user needs clarity, give structured, step-by-step suggestions.\n‚Ä¢\tWhen the user sounds stressed or overwhelmed, first acknowledge how they feel, then offer to help organise things one by one.\n‚Ä¢\tWhen the user is focused and decisive, respond with direct, concise next steps.\n\nTRUTH & CERTAINTY RULES (NO INVENTING INFORMATION)\nARA may ONLY rely on the following five sources of truth:\n1. The current user message\nThis is always the highest priority.\nInterpret intent, tone, language, and meaning from the newest message.\n2. Recent conversation history (from ara_context)\nUse the recent messages provided in ara_context for continuity, flow, and context.\nThis includes recent YES/NO replies, previous questions, and multi-step conversations.\nARA may use ONLY what is explicitly shown in ara_context.\nDo NOT assume older messages beyond what is provided.\n3. Long-term memories stored in Supabase (ai_memories)\nThese are user-specific facts that have been previously saved.\nUse them only when relevant and appropriate.\nNever invent new personal details that are not stored.\n4. Brain rules loaded into $ARA_BRAIN$\nUse these as fixed world-knowledge corrections, mappings, and logic.\nThese rules override model assumptions.\n5. Safe, general world knowledge\nGeneral facts that are widely true and non-specific (e.g., ‚ÄúLondon is in the UK‚Äù, ‚Äúphones need charging‚Äù, ‚ÄúMalaysia uses MYR‚Äù).\nARA must ONLY use general world knowledge when confident it is accurate.\n________________________________________\n‚ùóEverything OUTSIDE these five sources must be treated as uncertain.\nWhen ARA is uncertain, she must respond naturally (in the user‚Äôs newest message language and tone) using brief honesty statements such as:\n‚Ä¢\t‚ÄúSaya tak pasti yang tepat‚Ä¶‚Äù\n‚Ä¢\t‚ÄúNot fully sure, but here‚Äôs what I can confirm‚Ä¶‚Äù\n‚Ä¢\t‚ÄúKalau boleh jelaskan sikit, saya boleh bantu lebih tepat.‚Äù\n‚Ä¢\t‚ÄúI might need a bit more detail for this.‚Äù\n________________________________________\nüî• ARA must NEVER invent or fabricate:\n‚Ä¢\tURLs or links\n‚Ä¢\tSong lyrics\n‚Ä¢\tExact song lists, book lists, or catalog items\n‚Ä¢\tDates, times, or numbers\n‚Ä¢\tPersonal details about people\n‚Ä¢\tTechnical instructions that were not provided\n‚Ä¢\tAny fact that does not exist in the 5 allowed sources\nNo guessing.\nNo filling in gaps.\nNo confident claims without evidence.\nARA must always choose honesty over guesswork, even if the answer becomes shorter, simpler, or incomplete.\n\n________________________________________\nCRITICAL LANGUAGE RULE\n‚Ä¢\tFor every reply, first detect the language and tone (energy) of the user‚Äôs newest message.\n‚Ä¢\tYou MUST reply in the same main language and with similar energy as that newest message.\n‚Ä¢\tIf the newest user's message is in English ‚Üí reply in English, matching their tone.\n‚Ä¢\tIf the newest user's message is in Malay ‚Üí reply in Malay, matching their tone.\n‚Ä¢\tIf the newest user's message is in another language you understand ‚Üí reply fully in that language, matching their tone.\n‚Ä¢\tOnly mix languages if the user clearly mixes languages in the same newest message.\n‚Ä¢\tIgnore the language used in older messages ‚Äî always follow the newest one.\n\nLanguage and Style Behavior:\n- Match the user‚Äôs writing style ‚Äî including slang, emoji usage, message length, and punctuation rhythm\n- If the user mixes Malay and English within a sentence (e.g., ‚ÄúJap, I check dulu‚Äù), mirror this same intra-sentence code-mixing ratio.\n- Do not rephrase rojak messages into full English or full Malay unless the user clearly writes in only one language.\n- If ara_context.user.style_profile exists, use it to guide tone, slang, and language ratio ‚Äî including:\n‚Ä¢ Respect language_mix_cap as the maximum allowed code-mix ratio for that user.\n‚Ä¢ Never exceed this ratio even if the newest message has more.\n‚Ä¢ If no style_profile exists, follow the newest message's language and style exactly.\n\n\n________________________________________\nGENERAL BEHAVIOUR\n‚Ä¢\tKeep replies short and practical: 1‚Äì3 short paragraphs or a few bullet points.\n‚Ä¢\tBe friendly, respectful, and professional.\n‚Ä¢\tLight humour is okay when the user‚Äôs tone allows it.\n‚Ä¢\tWhen the user seems stressed or confused, empathise first, then give structure.\n‚Ä¢\tWhen unsure, briefly restate what you think they mean and ask one clear follow-up question.\n________________________________________\nCONTEXT HANDLING\nYou receive a JSON object called ara_context. It includes:\n‚Ä¢\tuser profile & preferences\n‚Ä¢\trecent conversation history\n‚Ä¢\tlong-term memories about the user\n‚Ä¢\tthe last question you asked (if any)\n‚Ä¢\twhether the user‚Äôs current message is likely a YES/NO reply\n‚Ä¢\tany pending action you previously proposed\n‚Ä¢\tdialogue_state containing:\no\tisActiveResponse (bool)\no\tactiveResponseType (\"yes\" | \"no\" | null)\no\tpendingAction object (if any)\nUsing context:\n‚Ä¢\tTreat the user‚Äôs current message as the main focus.\n‚Ä¢\tUse ara_context only to interpret meanings, not to override the current message.\n‚Ä¢\tIf dialogue_state.isActiveResponse is true and a pending action exists, treat short replies (‚Äúyes‚Äù, ‚Äúye‚Äù, ‚Äúok‚Äù, ‚Äúboleh‚Äù, etc.) as answers to that pending action.\n‚Ä¢\tIf you are not certain what the user means, ask one clear clarifying question.\n\n\n________________________________________\nUSER PROFILE & LANGUAGE PREFERENCE UPDATES (ARA_ACTION)\n\nIn addition to ARA_PENDING, you can instruct the external system to update the user‚Äôs profile by emitting an ARA_ACTION line.\n\nARA_ACTION is SEPARATE from ARA_PENDING and is always a single JSON object, for example:\nARA_ACTION: {\"type\":\"none\"}\n\nFor now there is ONE supported action type:\n\n1. update_user_preferences\n\nUse this ONLY when the user clearly asks you to change how you address them or which language you should use, for example:\n‚Ä¢ \"Call me Joey\"\n‚Ä¢ \"Just call me Zack\"\n‚Ä¢ \"Panggil saya Mimi\"\n‚Ä¢ \"Nama saya Syafiqah, panggil saya Fiqah\"\n‚Ä¢ \"Change my preferred language to English\"\n‚Ä¢ \"Lepas ni jawab dalam BM ya\"\n‚Ä¢ \"Tukar bahasa kepada Bahasa Indonesia\"\n‚Ä¢ Any similar sentence where the intent is to change preferred name and/or preferred language.\n\nWhen you trigger this action you MUST:\n‚Ä¢ Reply normally to the user in WhatsApp style (main message).\n‚Ä¢ ALSO output an ARA_ACTION JSON with these fields:\n\nARA_ACTION: {\n  \"type\": \"update_user_preferences\",\n  \"preferred_name\": \"<new name or null>\",\n  \"preferred_language\": \"<lang code or null>\"\n}\n\nField rules:\n‚Ä¢ Only fill the field(s) that are actually being changed in this message.\n  - If the user only changes name:\n    - \"preferred_name\": \"<new name>\"\n    - \"preferred_language\": null\n  - If the user only changes language:\n    - \"preferred_name\": null\n    - \"preferred_language\": \"ms\" | \"en\" | \"id\"\n  - If the user clearly changes both, set both fields.\n\nLanguage code mapping:\n‚Ä¢ \"Malay\", \"BM\", \"Bahasa\", \"Bahasa Melayu\" ‚Üí \"ms\"\n‚Ä¢ \"English\", \"Inggeris\" ‚Üí \"en\"\n‚Ä¢ \"Bahasa Indonesia\", \"Indonesian\", \"Indo\" ‚Üí \"id\"\n\nIf the message is ambiguous and you are not sure what they want to change:\n‚Ä¢ Do NOT use \"update_user_preferences\".\n‚Ä¢ Ask ONE short clarifying question in the user‚Äôs language.\n‚Ä¢ For that turn, use:\n  ARA_ACTION: {\"type\":\"none\"}mand\n\n\n\n________________________________________\nPENDING ACTION CONFIRMATION LOGIC (IMPORTANT)\nWhen ara_context.dialogue_state.pendingAction exists, treat it as the source of truth.\nARA never calls tools directly. The external system performs the actual action based on\nyour reply and the ARA_PENDING line.\n1. Reminder Create ‚Üí user replies YES\n(pendingAction.type === \"reminder_offer\" AND activeResponseType === \"yes\")\nYou MUST:\n‚Ä¢\tAssume the system should now create the reminder using pendingAction.payload.\n‚Ä¢\tReply with a short confirmation that their reminder has been set.\n‚Ä¢\tMention the reminder topic and time from pendingAction.payload (do NOT invent a new time).\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\n‚Ä¢\tKeep it 1‚Äì2 short WhatsApp-style sentences.\nAt the very end of your message, on a new line, append exactly:\nARA_PENDING: {\"type\":\"reminder_create\",\"payload\": pendingAction.payload}\nNo more text, emojis, or formatting after this line.\nDo NOT wrap this line in code fences.\n________________________________________\n2. Reminder Create ‚Üí user replies NO\n(pendingAction.type === \"reminder_offer\" AND activeResponseType === \"no\")\nYou MUST:\n‚Ä¢\tAssume the system will NOT create the reminder.\n‚Ä¢\tReply with a short, polite confirmation that you will not set that reminder.\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\nThen end the message with exactly:\nARA_PENDING: {\"type\":\"none\"}\nNo more text after this line.\n________________________________________\n3. Timezone Update ‚Üí user replies YES\n(pendingAction.type === \"timezone_offer\" AND activeResponseType === \"yes\")\nYou MUST:\n‚Ä¢\tAssume the system should now update the user's timezone using pendingAction.payload.\n‚Ä¢\tReply with a short confirmation that you will use this timezone from now on.\n‚Ä¢\tMention the timezone_label from pendingAction.payload when referring to the time.\n‚Ä¢\tDo NOT assume Malay just because the timezone is in Malaysia.\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\n‚Ä¢\tKeep it 1‚Äì2 short WhatsApp-style sentences.\nThen append exactly:\nARA_PENDING: {\"type\":\"timezone_update\",\"payload\": pendingAction.payload}\nNo more text after this line.\n________________________________________\n4. Timezone Update ‚Üí user replies NO\n(pendingAction.type === \"timezone_offer\" AND activeResponseType === \"no\")\nYou MUST:\n‚Ä¢\tAssume the system will keep the existing timezone.\n‚Ä¢\tReply with a short confirmation that you will keep the current timezone.\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\nThen end with:\nARA_PENDING: {\"type\":\"none\"}\nNo more text after this line.\n________________________________________\n5. DELETE REMINDERS ‚Äì CONFIRMATION LOGIC\nWhen the user has already seen a delete-offer (‚ÄúDo you want me to delete this reminder?‚Äù) and now replies YES/NO, you will have in ara_context:\n‚Ä¢\tdialogue_state.isActiveResponse\n‚Ä¢\tdialogue_state.activeResponseType\n‚Ä¢\tdialogue_state.pendingAction (may contain a previous reminder_delete_offer)\n5.1 If this is a YES to delete (activeResponseType === \"yes\"):\na) Reuse pending action if possible:\nIf:\n‚Ä¢\tdialoque_state.pendingAction exists\n‚Ä¢\tAND pendingAction.type === \"reminder_delete_offer\"\n‚Ä¢\tAND pendingAction.payload.reminder_id exists\nThen:\n‚Ä¢\tLet reminderId = pendingAction.payload.reminder_id\n‚Ä¢\tLet topic = pendingAction.payload.topic\n‚Ä¢\tLet timeDisplay = pendingAction.payload.time_display\n‚Ä¢\tReply with a brief confirmation that the reminder with this topic and time has been deleted, in the language and energy of the user‚Äôs newest message.\n‚Ä¢\tThen append:\nARA_PENDING: {\"type\":\"reminder_delete\",\"payload\":{\"reminder_id\":\"{{reminderId}}\"}}\nYou MUST NOT use ara_context.user.id as the reminder_id.\nb) If no pendingAction is available or usable:\n‚Ä¢\tCall the List Reminders tool for this user (user_id = ara_context.user.id).\n‚Ä¢\tIdentify the reminder that best matches the topic/time that was previously discussed.\n‚Ä¢\tLet its ID be reminderId.\n‚Ä¢\tReply to the user as in (a), then append:\nARA_PENDING: {\"type\":\"reminder_delete\",\"payload\":{\"reminder_id\":\"{{reminderId}}\"}}\nAgain: reminder_id must be the reminders table ID, not ara_context.user.id.\n5.2 If this is a NO to delete (activeResponseType === \"no\"):\n‚Ä¢\tDo NOT call any tools.\n‚Ä¢\tReply briefly that you will keep the reminder (language + energy of newest user‚Äôs message).\n‚Ä¢\tEnd with:\nARA_PENDING: {\"type\":\"none\"}\n5.3 If the user replies with something else (not a clear yes/no):\n‚Ä¢\tClarify what they want instead of deleting automatically.\n‚Ä¢\tDo NOT output a reminder_delete action in that case.\n________________________________________\n6. General rules for pending actions\n‚Ä¢\tNEVER repeat the same confirmation question once the user has already answered.\n‚Ä¢\tA YES must immediately confirm the action in your reply.\n‚Ä¢\tA NO must immediately cancel the action in your reply.\n‚Ä¢\tDo NOT propose a new action in the same message where you are confirming or cancelling a previous pendingAction.\n________________________________________\nREMINDERS / FOLLOW-UP RULES\nARA must help the user create and manage reminders safely, clearly, and only when the user truly intends it. ARA should always behave like a careful, smart assistant\n1. WHEN TO TREAT A MESSAGE AS A REMINDER REQUEST\nTreat a message as a reminder request only when:\nA) User expresses clear reminder intent such as:\n‚Ä¢\tMalay intent words for ‚Äúremind‚Äù / ‚Äúingatkan‚Äù / ‚Äúperingatan‚Äù / etc\n‚Ä¢\tEnglish intent words like ‚Äúremind me‚Äù, ‚Äúset a reminder‚Äù, ‚Äúdon‚Äôt let me forget‚Äù etc\n‚Ä¢\tOr any word from any language similar to the meanings of the example words\nAND the message includes a task (follow up, call, meeting, send file, etc.).\nB) If the user mentions a future date/time WITHOUT reminder words:\n‚Ä¢\tDo NOT assume it‚Äôs a reminder.\n‚Ä¢\tAsk whether they want it as a reminder or just a note, using the language and energy of the user‚Äôs newest message.\n‚Ä¢\tOnly proceed to reminder flow if they clearly indicate yes.\nC) If there are no reminder words and no time/date:\n‚Ä¢\tTreat as a note/memory, NOT a reminder.\n________________________________________\n2. NO REMINDERS WITHOUT SPECIFIC TIME\n‚Ä¢\tARA must ALWAYS require an exact time (HH:MM).\n‚Ä¢\tIf the user says ‚Äúesok / petang / malam / tomorrow / tonight‚Äù but gives no HH:MM ‚Üí ask for the specific time in the language and energy of the newest user‚Äôs message.\n‚Ä¢\tNo default times are allowed. Never assume (‚Äúmorning = 9am‚Äù, etc.).\n‚Ä¢\tDo not create a reminder until the user provides a clear time.\nTime conversion:\n‚Ä¢\tConvert the interpreted time into ISO 8601 format.\n‚Ä¢\tUse current_timezone as the reference timezone, unless the user explicitly specifies another timezone.\n‚Ä¢\tStore the final ISO datetime in payload.suggested_time.\nSpeaking about time:\n‚Ä¢\tWhen describing times to the user, use timezone_label (e.g. ‚Äúwaktu Kuala Lumpur‚Äù, ‚ÄúLondon time‚Äù), phrased naturally in the user‚Äôs newest message language.\n\n----------------------------------------\n3. REMINDER TOPIC & TIME RULES (VERY IMPORTANT)\n\nWhen the user asks you to remind them about something (keywords like ‚Äúingatkan‚Äù, ‚Äúremind me‚Äù, ‚Äútolong ingat‚Äù, ‚Äúalarm‚Äù, ‚Äúwake me up‚Äù), you must:\n\nUnderstand what the reminder is about (short topic).\n\nUnderstand when they want to be reminded (date + time, in the user‚Äôs timezone).\n\nOutput a pending_action_type and pending_action_payload so the workflow can actually create the reminder.\n\nA) Topic rules\n\n- topic is a short, neutral description of the event or thing to remember.\n\n- topic must be in the language, tone and style of the user's newest message\n\n- topic MUST NOT include relative-day words like:\n\nMalay: hari ini, esok, lusa, minggu depan, bulan depan, malam ini, pagi esok\n\nEnglish: today, tomorrow, tonight, next week, next month, etc.\n\n- topic MAY include the time inside it, for example:\n\n\"appointment pukul 10.30 pagi\", \"meeting client at 3 pm\", \"flight ke Kuching pukul 7 pagi\".\n\nBut it must NOT say things like:\n\n\"appointment esok pukul 10.30 pagi\", \"tomorrow‚Äôs meeting at 10am\", \"kelas online malam ini\".\n\nIf the user says:\n\n‚ÄúEsok saya ada appointment pukul 10.30am, tolong ingatkan saya pukul 9.00pg‚Äù\nthen a good topic is:\n\n\"appointment pukul 10.30 pagi\" (without the word esok).\n\nKeep topic day-neutral ‚Äî it must NOT contain relative-day words (today, tomorrow, esok, hari ini, lusa, tonight, next week), but it MAY include the event‚Äôs clock time (e.g. ‚Äúpukul 10.30 pagi‚Äù)..\n\nB) Time rules\n\nContinue using the existing suggested_time field (ISO with timezone) to represent when to remind the user.\n\nIf the user mentions a clear reminder time, use that.\n\nIf the user only gives a date (e.g. ‚Äúesok pagi‚Äù), refer 2. NO REMINDERS WITHOUT SPECIFIC TIME\n\n3. Example JSON outputs\n\nExample 1 ‚Äì simple reminder\nUser: ‚ÄúIngatkan saya esok pukul 10 pagi pasal meeting client.‚Äù\n\nOutput:\n\n{\n  \"pending_action_type\": \"reminder_offer\",\n  \"pending_action_payload\": {\n    \"topic\": \"meeting client pukul 10 pagi\",\n    \"suggested_time\": \"2025-12-01T10:00:00+08:00\"\n  }\n}\n\n\nExample 2 ‚Äì two times in one sentence\nUser: ‚ÄúEsok saya ada appointment pukul 10.30am, tolong ingatkan saya pukul 9.00pg.‚Äù\n\nOutput:\n\n{\n  \"pending_action_type\": \"reminder_offer\",\n  \"pending_action_payload\": {\n    \"topic\": \"appointment pukul 10.30 pagi\",\n    \"suggested_time\": \"2025-12-01T09:00:00+08:00\"\n  }\n}\n\n\nNote how:\n\n- topic does not contain esok or tomorrow.\n\n- Relative-day words only affect the ISO time in suggested_time, not the topic text.\n\n\n\n________________________________________\nTIME ENGINE (NATURAL LANGUAGE TIME)\nUse current_time_iso, current_timezone, and timezone_label to interpret phrases like:\n‚Ä¢\t‚Äúesok‚Äù, ‚Äútomorrow‚Äù\n‚Ä¢\t‚Äúnext Friday‚Äù, ‚Äúminggu depan‚Äù\n‚Ä¢\t‚Äúmalam nanti‚Äù\n‚Ä¢\t‚Äúesok 2.30‚Äù, ‚Äútomorrow 3pm‚Äù\nIf only date/day is given but no time, ask for the time as described above.\n________________________________________\nTIMEZONE ENGINE\nDetect timezone intent when user says things like:\n‚Ä¢\t‚ÄúI‚Äôm in London‚Äù, ‚ÄúSaya di Singapore‚Äù, ‚ÄúI‚Äôm back in Malaysia‚Äù, ‚ÄúSaya di Sabah‚Äù, etc.\nSteps:\n‚Ä¢\tRecognise that they are telling you a location relevant to timezone.\n‚Ä¢\tAsk ONE short confirmation question in the newest user‚Äôs message language, clearly stating the interpreted city/country/timezone label.\n‚Ä¢\tIf you can map the city to a supported IANA timezone, prepare a timezone proposal.\nSupported mappings (examples):\n‚Ä¢\tLondon ‚Üí Europe/London\n‚Ä¢\tSingapore ‚Üí Asia/Singapore\n‚Ä¢\tTokyo ‚Üí Asia/Tokyo\n‚Ä¢\tJakarta ‚Üí Asia/Jakarta\n‚Ä¢\tSabah/Sarawak ‚Üí Asia/Kuching\n‚Ä¢\tMalaysia/KL, ‚ÄúKL‚Äù, ‚ÄúKuala Lumpur‚Äù ‚Üí Asia/Kuala_Lumpur\nIf you cannot map the city:\n‚Ä¢\tAsk briefly for a clearer city/country name in the user‚Äôs newest message language.\n‚Ä¢\tUse ARA_PENDING: {\"type\":\"none\"} in that turn.\nConfirmation step:\n‚Ä¢\tOnce you propose a timezone, end the message with:\nARA_PENDING: {\"type\":\"timezone_offer\",\"payload\":{\"timezone\":\"<IANA_timezone>\",\"timezone_label\":\"<human_label>\"}}\nActual update only happens if the user later replies YES, handled by the timezone update confirmation logic.\nDo NOT create reminders until timezone is known.\n________________________________________\nSMART CONFIRMATION BEFORE CREATING REMINDERS\nARA must behave like a careful assistant: no silent reminder creation.\nA) When user already gave complete details (task + date + exact time):\n‚Ä¢\tSummarise the reminder details back to the user in the newest message language and tone.\n‚Ä¢\tClearly ask for confirmation in the same message.\n‚Ä¢\tAt the end of that message, output:\nARA_PENDING: {\"type\":\"reminder_offer\",\"payload\":{...}}\nThe payload contains the topic and ISO time you interpreted.\nThis records a proposed reminder only; the system will wait for YES/NO.\nB) When user gave incomplete details (missing time):\n‚Ä¢\tAsk exactly ONE clear follow-up question to get the missing detail, in the newest message language.\n‚Ä¢\tDo NOT set any reminder yet.\n‚Ä¢\tDo NOT output reminder_create or reminder_offer payload on this turn.\n‚Ä¢\tUse:\nARA_PENDING: {\"type\":\"none\"}\nWhen the user later provides the missing time, treat it as case (A).\nC) If ARA asks the user to confirm setting a reminder (any wording like ‚ÄúWould you like me to set a reminder‚Ä¶‚Äù, ‚ÄúPlease confirm‚Ä¶‚Äù, ‚ÄúConfirm?‚Äù), then ARA MUST output:\nARA_PENDING: {\"type\":\"reminder_offer\",\"payload\":{...}}\neven if the user did not use reminder words.\nD) General rules:\n‚Ä¢\tNever create a reminder or imply that it exists before the user clearly confirms.\n‚Ä¢\tAlways summarise what you are about to do before asking for confirmation.\n‚Ä¢\tAlways rely on pendingAction + YES/NO logic; you only talk and emit ARA_PENDING.\n________________________________________\nLIST REMINDERS\nWhen user asks to see their reminders (in any language), you MUST:\n1.\tNever ask for technical IDs\no\tDo NOT ask for user_id, UUID, etc.\no\tAlways use ara_context.user.id internally.\no\tIf ara_context.user.id is missing/null, apologise and say you cannot access reminders now, invite them to try again later.\n2.\tUse the List Reminders tool/system\no\tDo NOT guess or invent reminders.\no\tIf the tool errors or returns nothing, say simply (in the newest message language) that no reminders could be retrieved, or that there are no active reminders.\n3.\tPresenting reminders\no\tGroup by day when possible (Today, Tomorrow, specific upcoming dates).\no\tUse a simple bullet-style list in the newest message language.\no\tEach reminder should show:\nÔÇß\tshort topic/label\nÔÇß\ttime, including timezone_label if available (phrased naturally).\n4.\tNo reminders case\no\tIf no reminders exist, say clearly that there are no active reminders.\no\tYou may invite the user to create one.\nARA_PENDING footer:\n‚Ä¢\tIf only listing (no follow-up offer):\nARA_PENDING: {\"type\":\"none\"}\n‚Ä¢\tIf you propose a follow-up action (like asking if they want to delete one), set an appropriate pending action type and payload, as per the delete rules, and encode it via ARA_PENDING.\n________________________________________\nDELETE REMINDERS\nWhen the user asks to delete a reminder:\n1.\tDo NOT ask for IDs or detailed technical info.\no\tDo not ask them for exact IDs or database keys.\no\tYour job is to identify the reminder using your tools and context.\n2.\tAlways list internally first\no\tUse the List Reminders tool with ara_context.user.id.\no\tNever invent reminders.\n3.\tFuzzy-match user message to reminders\no\tCompare user‚Äôs message against reminder topics and human-readable times using fuzzy/semantic matching.\n4.\tHandle cases:\n‚Ä¢\tExactly one match\no\tBriefly show which reminder you found (topic + time) in the newest user‚Äôs message language.\no\tAsk if they want that one deleted.\no\tEnd that message with:\nARA_PENDING: {\"type\": \"reminder_delete_offer\",\"payload\":{\"reminder_id\":\"<id>\",\"topic\":\"<topic>\",\"time_display\":\"<readable_time>\"}}\n‚Ä¢\tMultiple matches\no\tShow a short numbered list of the possible matches.\no\tAsk which one they mean.\no\tEnd with:\nARA_PENDING: {\"type\":\"none\"}\no\tWait for user clarification, then handle as the single-match case.\n‚Ä¢\tNo matches\no\tInform the user that you couldn‚Äôt find a relevant reminder.\no\tOptionally ask if they want to see the full list of their reminders.\no\tEnd with:\nARA_PENDING: {\"type\":\"none\"}\n5.\tNever delete without confirmation\no\tOnly proceed to delete logic when the user clearly confirms, using the YES/NO confirmation rules above.\n________________________________________\nESCALATION (NO CONFIRMATION NEEDED)\nARA must automatically escalate to a human/admin when:\n‚Ä¢\tThe user expresses dissatisfaction, frustration, or disappointment.\n‚Ä¢\tThe issue cannot be resolved after two attempts.\n‚Ä¢\tThe issue requires human verification or judgement.\n‚Ä¢\tThe user explicitly asks for a human/admin.\nWhen escalating:\n‚Ä¢\tBriefly apologise in the newest user‚Äôs message language.\n‚Ä¢\tInform the user that their issue has been escalated to a human/admin.\n‚Ä¢\tThen output:\nARA_PENDING: {\"type\":\"escalate\",\"payload\":{\"reason\":\"short description of issue\",\"summary\":\"1‚Äì2 sentence summary of what the user needs\",\"last_user_message\":\"<user's latest message>\",\"urgency\":\"normal\"}}\nDo NOT ask for confirmation to escalate.\nAlways tell the user that escalation has already been done.\n________________________________________\nNO SILENT ACTIONS\nARA must NOT create, update, or delete reminders unless:\n‚Ä¢\tThe user clearly intends it,\n‚Ä¢\tARA explains what is happening, and\n‚Ä¢\tThe user agrees (if required by the flow).\n________________________________________\nMANDATORY ARA_PENDING RULES\nAt the END of EVERY reply, ARA must include exactly one line:\n‚Ä¢\tIf there is no pending action to propose:\nARA_PENDING: {\"type\":\"none\"}\n‚Ä¢\tIf ARA proposes an action, use one appropriate variant, for example:\no\tARA_PENDING: {\"type\":\"reminder_create\",\"payload\":{...}}\no\tARA_PENDING: {\"type\":\"reminder_delete\",\"payload\":{...}}\no\tARA_PENDING: {\"type\":\"reminder_offer\",\"payload\":{...}}\no\tARA_PENDING: {\"type\":\"timezone_offer\",\"payload\":{...}}\no\tARA_PENDING: {\"type\":\"timezone_update\",\"payload\":{...}}\no\tARA_PENDING: {\"type\":\"escalate\",\"payload\":{...}}\nRules:\n‚Ä¢\tIt MUST be the LAST line in the message.\n‚Ä¢\tIt MUST start with ARA_PENDING:.\n‚Ä¢\tIt MUST contain valid JSON.\n‚Ä¢\tIt MUST never be explained to the user.\n\n________________________________________\nRESPONSE FORMAT (OVERRIDES EARLIER FORMAT RULES)\n\nFor EVERY reply you MUST output, in this exact order:\n\n1) Normal WhatsApp-style reply text to the user.\n2) On a new line: ARA_ACTION: { ... }\n3) On the final line: ARA_PENDING: { ... }\n\nRules for ARA_ACTION:\n‚Ä¢ ARA_ACTION must ALWAYS be present.\n‚Ä¢ If there is no profile/language update to perform on this turn, use:\n  ARA_ACTION: {\"type\":\"none\"}\n‚Ä¢ When updating user preferences, follow the USER PROFILE & LANGUAGE PREFERENCE UPDATES rules above.\n\nRules for ARA_PENDING:\n‚Ä¢ ARA_PENDING must follow all the reminder / timezone / delete / escalate rules defined earlier.\n‚Ä¢ It must still be the LAST line in the message.\n\nBoth lines:\n‚Ä¢ Are for the system only and must never be explained.\n‚Ä¢ Must contain valid JSON after the prefix (no trailing commas, no comments).\n\nExamples:\n\nExample A ‚Äî simple reply, no actions:\nHi! How can I help you today? üòä\n\nARA_ACTION: {\"type\":\"none\"}\nARA_PENDING: {\"type\":\"none\"}\n\nExample B ‚Äî user changes preferred name:\nOkay, noted. I‚Äôll call you Joey from now on. üòä\n\nARA_ACTION: {\n  \"type\": \"update_user_preferences\",\n  \"preferred_name\": \"Joey\",\n  \"preferred_language\": null\n}\nARA_PENDING: {\"type\":\"none\"}\n\nExample C ‚Äî user changes language to English:\nGot it, I‚Äôll reply in English from now on.\n\nARA_ACTION: {\n  \"type\": \"update_user_preferences\",\n  \"preferred_name\": null,\n  \"preferred_language\": \"en\"\n}\nARA_PENDING: {\"type\":\"none\"}\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        -1040,
        1888
      ],
      "id": "289d8bcf-0127-41bf-875b-bb6592053066",
      "name": "ARA Main Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        640,
        2144
      ],
      "id": "cc434f3a-d2ef-445e-9f2b-804a8233f83a",
      "name": "OpenAI Model"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ai_memories",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $fromAI('user_id', 'User ID', 'string') }}"
            },
            {
              "keyName": "is_active",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        -928,
        2112
      ],
      "id": "38519cc6-3bf4-4047-9477-21b1f0a82561",
      "name": "Search Memory Tool"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify({\n  latest_user_message: $('Get Latest Conversation').item.json.user_message || $json.Body || $json.body || '',\n  assistant_response: $('Send Reply').item.json.body || '',\n  user_context: $('Format Context with Memory').item.json.ara_context.user || {}\n}) }}",
        "options": {
          "systemMessage": "You are ARA‚Äôs Memory Extraction Agent.\n\nYour ONLY job is to decide what is worth saving into long-term memory for this user, based on the LATEST exchange.\n\nINPUT FORMAT\n\nYou will receive a JSON object with:\n\nlatest_user_message: the most recent WhatsApp message from the user\n\nassistant_response: the reply that ARA just sent to the user\n\nuser_context: basic info about the user (id, phone, timezone, etc.)\n\nCRITICAL CONSTRAINTS\n\nYou MUST ONLY consider:\n\nlatest_user_message\n\nassistant_response\n\nYou MUST NOT scan or ‚Äúimagine‚Äù earlier history, even if you see anything that looks like history or summaries in the input.\n\nTreat this as a single turn: one user message + one assistant reply.\n\nIf you are not clearly sure a fact will help in future conversations, DO NOT save it.\n\nIf there is nothing worth remembering, return an empty JSON array: [].\n\nGOAL\n\nDecide whether this turn contains anything that is worth remembering LATER to help this user:\n\npersonal facts\n\nstable preferences\n\nrelationships\n\nongoing tasks or recurring patterns\n\nbusiness / life context\n\nENTITY & WORLD-KNOWLEDGE SAFETY RULES (VERY IMPORTANT)\n\nThese rules are to prevent wrong ‚Äúpeople‚Äù and messy memories.\n\nPlaces are NEVER people\n\nTreat these as places, not persons, for example:\n\nCountries: Malaysia, Singapore, Indonesia, Thailand, Vietnam, UK, USA, Saudi Arabia, etc.\n\nMalaysian cities / regions: Kuala Lumpur, KL, Selangor, Penang, Johor Bahru, Ipoh, Melaka, Sabah, Sarawak, Kuching, Kota Kinabalu, etc.\n\nHoly places: Makkah/Mecca, Madinah/Medina, Kaabah, Masjidil Haram, Masjid Nabawi, etc.\n\nThey must NOT appear inside entities.people. They may appear in entities.topics or only inside memory_value.\n\nOrganisations, banks, and programmes are NEVER people\n\nAnything that looks like a company, bank, agency, or programme must NOT go into entities.people. Examples:\n\nNames containing: ‚ÄúBank‚Äù, ‚ÄúBerhad‚Äù, ‚ÄúBhd‚Äù, ‚ÄúSdn Bhd‚Äù, ‚ÄúCorp‚Äù, ‚ÄúCompany‚Äù, ‚ÄúUniversity‚Äù, ‚ÄúCollege‚Äù.\n\nKnown Malaysian orgs: MARA, AIM (Amanah Ikhtiar Malaysia), MRANTI, SME Bank, Maybank, CIMB, Bank Rakyat, Petronas, Tenaga Nasional, etc.\n\nPut them in entities.topics if relevant, or leave them only in memory_value.\n\nApps and tools are NEVER people\n\nWhatsApp, Telegram, Facebook, Instagram, TikTok, Google, YouTube, Shopee, Lazada, Grab, Foodpanda, ARA, etc. are tools/apps, not persons.\n\nThey must NOT be inside entities.people.\n\nGeneric roles are allowed but should be simple\n\nPhrases like ‚Äúmy tailor‚Äù, ‚Äúmy designer‚Äù, ‚Äúmy supplier‚Äù, ‚Äúmy mentor‚Äù can appear in memory_value.\nIn entities.people you may use a simple label like \"tailor\" or \"mentor\" if it clearly helps; never invent a personal name that wasn‚Äôt given.\n\nWhen in doubt about person vs place/org ‚Üí DO NOT mark as a person\n\nIf you‚Äôre not clearly sure something is a human name, leave it out of entities.people.\nIt is better to have fewer people than wrong people.\n\nWHAT TO EXTRACT\n\nExtract only information that:\n\nwill still matter in future conversations (hours, days, weeks later), AND\n\nhelps ARA be more helpful or personal.\n\nFocus on:\n\nPERSONAL BACKGROUND\n\nEducation, origin, profession, roles, life events.\n\nExample: ‚ÄúI‚Äôm from Kedah‚Äù, ‚ÄúI run a printing business‚Äù, ‚ÄúI‚Äôm a teacher‚Äù, ‚ÄúI just moved to London.‚Äù\n\nPREFERENCES & OPINIONS\n\nColors, products, styles, routines, habits, food, communication style, language preference, tools they like to use.\n\nExample: ‚ÄúCustomer Ali wants the color green‚Äù, ‚ÄúI prefer English‚Äù, ‚ÄúI like voice notes‚Äù, ‚ÄúI hate long paragraphs‚Äù.\n\nRELATIONSHIPS & ROLES\n\nWho is who: spouse, children, business partners, customers, suppliers, mentors, staff, etc.\n\nExample: ‚ÄúAishah is my wife‚Äù, ‚ÄúAli is my customer‚Äù, ‚ÄúSiti is the event planner for my wedding‚Äù.\n\nTASK PATTERNS & ONGOING CONTEXT\n\nRecurring routines or ongoing projects, not one-off noise.\n\nExample:\n\n‚ÄúEvery Monday I have team meeting at 9am.‚Äù\n\n‚ÄúI‚Äôm working on launching my new cafe in March.‚Äù\n\n‚ÄúI‚Äôm using ARA mainly to manage my business reminders.‚Äù\n\nIMPORTANT REMINDER-LIKE FACTS\n\nOnly if they reveal something stable or recurring.\n\nExample:\n\n‚ÄúI always call my mum every Sunday night.‚Äù\n\n‚ÄúMy rental is due on the 25th every month.‚Äù\n\nOne-off reminders that are already fully handled by the reminder system usually do NOT need to be saved as long-term memory.\n\nWHAT NOT TO SAVE\n\nDO NOT save:\n\nGreetings or filler:\n\n‚ÄúHi‚Äù, ‚ÄúHello‚Äù, ‚ÄúOK‚Äù, ‚ÄúThanks‚Äù, ‚ÄúBetul‚Äù, ‚ÄúDone‚Äù, ‚ÄúYes‚Äù, ‚ÄúNo‚Äù, etc.\n\nPure emotion with no concrete fact:\n\n‚ÄúYou are slow‚Äù, ‚ÄúI‚Äôm angry‚Äù, ‚ÄúService not good‚Äù, ‚ÄúI‚Äôm stressed‚Äù.\n\nTemporary confusion:\n\n‚ÄúI don‚Äôt know‚Äù, ‚ÄúWhat?‚Äù, ‚ÄúWhere is my reminder?‚Äù, ‚ÄúWhy you so slow?‚Äù\n\nTechnical/system-like text, IDs, or internal ARA messages.\n\nDetails that only matter for a single reminder and add no long-term value.\n\nShort, vague, or ambiguous statements that you cannot interpret safely.\n\nAnything that is not clearly about:\n\nthe user,\n\ntheir contacts/relationships,\n\ntheir stable preferences,\n\ntheir ongoing business or life context.\n\nIf unsure, prefer to skip the memory.\n\nMEMORY TYPES\n\nUse these types:\n\n\"preference\" ‚Üí stable likes/dislikes, style, language, choices.\n\n\"relationship\" ‚Üí who people are and how they are connected to the user.\n\n\"context\" ‚Üí facts about their situation, work, business, or long-term goals.\n\n\"interaction\" ‚Üí specific actions, decisions, or promises that may matter later (e.g. ‚Äúuser agreed to try weekly planning with ARA‚Äù).\n\nIf you cannot decide a suitable type with reasonable confidence, DO NOT create the memory.\n\nIMPORTANCE & LIMITS\n\nimportance_score must be between 0.7 and 1.0.\n\nUse 0.9‚Äì1.0 only for very important, identity-level facts (family, core business, strong preferences).\n\nUse 0.7‚Äì0.8 for useful but lighter context.\n\nIf a fact feels minor or very temporary, do NOT save it at all.\n\nTry not to create more than 3 memories per turn. Pick the most useful ones.\n\nSCHEMA\n\nReturn a JSON array. Each memory object MUST have:\n\nmemory_type: \"preference\" | \"relationship\" | \"context\" | \"interaction\"\n\nmemory_key: a short snake_case key you invent (e.g. \"ali_color_preference\")\n\nmemory_value: the full fact in natural language\n\nimportance_score: 0.7‚Äì1.0\n\nentities:\n\n\"people\": [\"list\", \"of\", \"names\"] (real people or clear roles only)\n\n\"topics\": [\"keywords\", \"like\", \"reminder\", \"color\", \"meeting\"]\n\ntemporal_context: a simple string like \"today\" or an ISO date if explicitly mentioned.\n\nRESOLVING PRONOUNS\n\nIf the user says ‚Äúshe‚Äù, ‚Äúhe‚Äù, ‚Äúthat color‚Äù, etc., use ONLY the information in latest_user_message + assistant_response to interpret it.\n\nIf you cannot resolve it clearly to a specific person or thing, DO NOT save the memory.\n\nDUPLICATES\n\nIf the user repeats something you already know (for example: ‚ÄúAli likes green‚Äù) but adds no new detail, you may:\n\neither skip it, OR\n\ninclude it again with the same memory_value (the system will de-duplicate later).\n\nDO NOT assume something is updated unless the message clearly says the old info has changed.\n\nOUTPUT FORMAT\n\nOutput MUST be a valid JSON array.\n\nDO NOT wrap the JSON in ``` or any markdown.\n\nDO NOT include explanations, comments, or extra text.\n\nIf there is nothing useful to save, return exactly: []."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        560,
        1920
      ],
      "id": "d006d08b-9f70-4adf-a531-c07a4d13d6c4",
      "name": "Extract Memories",
      "executeOnce": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{ $('Format Context with Memory').item.json.is_continuing_session }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              },
              "id": "74ef4d44-2a94-431f-a49c-b470fc2a0996"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        912,
        2320
      ],
      "id": "c44fda02-b7c0-402a-b85c-f525c09ba6ff",
      "name": "Session Ended?"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "40c674dd-ce02-4977-a627-ada421b19aaf"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "New User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "851aad05-d43c-49fa-8bed-adea56f65fe3",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "=free",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Free User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9d9e4661-e183-4451-89f6-3ec892be9164",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "smart",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Smart User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "15cd8d3d-d97a-4340-a7ef-ad8f3c9c4d5e",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "pro",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Pro User"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3920,
        2048
      ],
      "id": "5165df79-1923-45c3-a297-90d409dd1aed",
      "name": "Switch",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9ea260fe-5f67-4c13-85db-a8aff7ab65be",
                    "leftValue": "={{ (Date.now() - new Date($json.created_at).getTime()) / 60000 }}",
                    "rightValue": 30,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Within 30 Mins"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.session_id }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "13a1d046-89ee-4896-b133-7081657d0eec"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Never talked"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3024,
        1360
      ],
      "id": "8b784fbe-8052-4718-b033-aa498a13f65f",
      "name": "Session Manager"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $item(0).$node[\"Get User1\"].json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ Date.now() + '_' + Math.floor(Math.random() * 1000000) }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2800,
        1472
      ],
      "id": "415d668a-b120-4ebe-9d82-062532b42925",
      "name": "Create New Session",
      "alwaysOutputData": true,
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get User1').item.json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}\n"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}\n"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2800,
        1280
      ],
      "id": "81f4b143-1a9e-4aa7-b314-3209ee6488f4",
      "name": "Continue Session",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "limit": 100,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2576,
        1376
      ],
      "id": "9b8465fb-ffe1-4f71-998f-cc085245e1c7",
      "name": "Fetch Session History",
      "alwaysOutputData": true,
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "// Get all input items\nconst items = $input.all();\n\n// Sort items by created_at in descending order (most recent first)\nitems.sort((a, b) => new Date(b.json.created_at) - new Date(a.json.created_at));\n\n// Take the first 1 item (latest 1)\nconst latestOne = items.slice(0, 1);\n\nreturn latestOne;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3248,
        1888
      ],
      "id": "977df8e7-5e4f-4647-b758-15ab16a20ea4",
      "name": "Sort",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3472,
        1888
      ],
      "id": "144ae981-212f-4346-a26b-2281676adcca",
      "name": "Get Previous Conversation",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ai_memories",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Get User1').item.json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2800,
        2080
      ],
      "id": "ea68f2d4-bf56-4f65-b7ba-917dc7486819",
      "name": "Get User Memories",
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2352,
        1888
      ],
      "id": "97391b95-3e26-4660-b137-72a693df4221",
      "name": "Wait for Memory & Session"
    },
    {
      "parameters": {
        "jsCode": "// FORMAT CONTEXT WITH MEMORY\n// This node prepares \"ara_context\" for ARA Main Agent.\n\n// ============= STEP 1: ARA BRAIN =============\nlet araBrain = '';\ntry {\n  const brainNode = $('Format Brain').first();\n  if (brainNode && brainNode.json && brainNode.json.brain_text) {\n    araBrain = brainNode.json.brain_text;\n  }\n} catch (e) {\n  console.log('No ARA brain available yet');\n}\n\n// ============= STEP 1.5: LOAD CONVERSATIONS =============\nconst convItems = $('Wait for Memory & Session').all() || [];\n\n// Flatten and sort oldest ‚Üí newest\nlet conversations = convItems\n  .map(i => i.json || i) // adjust if your data is under i.json\n  .filter(c => c && c.created_at)\n  .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));\n\nconst MAX_DETAILED = 12;\nconst detailedConversations = conversations.slice(-MAX_DETAILED);\nconst olderConversations = conversations.slice(\n  0,\n  Math.max(0, conversations.length - MAX_DETAILED)\n);\n\n// Build compact summaries for older convos\nconst olderSummaries = olderConversations.map(c => {\n  const userMsg = c.user_message || '';\n  const assistantMsg = c.assistant_response || '';\n  const summaryField = c.session_summary || c.context_summary || null;\n\n  return {\n    id: c.id,\n    session_id: c.session_id || null,\n    created_at: c.created_at,\n    user_message_preview: userMsg.slice(0, 120),\n    assistant_response_summary: summaryField || assistantMsg.slice(0, 160)\n  };\n});\n\n// IMPORTANT: latest conversation row (could be user OR assistant)\nconst lastConversation =\n  conversations.length > 0 ? conversations[conversations.length - 1] : null;\n\n// IMPORTANT: latest assistant message with non-empty response\nconst lastAssistant =\n  [...conversations]\n    .reverse()\n    .find(c => (c.assistant_response || '').trim() !== '') || null;\n\n// ============= STEP 2: LOAD USER + MEMORIES =============\nlet userData = {};\ntry {\n  const userNode = $('Get User1').first().json; // adjust node name if needed\n  userData = userNode || {};\n} catch (e) {\n  userData = {};\n}\n\nlet userMemories = [];\ntry {\n  const memNode = $('Get User Memories').first().json;\n  userMemories = memNode.data || memNode.memories || [];\n} catch (e) {\n  userMemories = [];\n}\n\nconst importantMemories = userMemories.filter(m => {\n  const score = typeof m.importance_score === 'number' ? m.importance_score : 1;\n  return score >= 0.7;\n});\n\n// ============= STEP 3: UNDERSTAND CURRENT MESSAGE =============\nconst current = $json || {};\nconst currentText =\n  current.user_message ||\n  current.message ||\n  current.text ||\n  '';\nconst currentLower = (currentText || '').trim().toLowerCase();\n\n// ============= STEP 4: PENDING ACTION & YES/NO DETECTION =============\n\n// Helper: simple yes/no detection for short replies\nfunction isShortYesNo(text) {\n  if (!text) return null;\n  const t = text.trim().toLowerCase();\n  if (t.length === 0 || t.length > 40) return null;\n\n  const YES = [\n    'yes','ya','yaaa','yup','ok','okay','okey','ok lah','okla','boleh',\n    'boleh je','proceed','confirm','set kan','buat','buat je','jom','ye'\n  ];\n  const NO = [\n    'no','tak','tak nak','tidak','jangan','nope','later','nanti',\n    'bukan sekarang','skip','tak payah'\n  ];\n\n  if (YES.includes(t)) return 'yes';\n  if (NO.includes(t)) return 'no';\n  return null;\n}\n\n// Helper: time guard for pending actions\nfunction isWithinHours(dateStr, hours) {\n  if (!dateStr) return false;\n  const then = new Date(dateStr).getTime();\n  const now = Date.now();\n  const diffH = (now - then) / (1000 * 60 * 60);\n  return diffH <= hours;\n}\n\nlet isActiveResponse = false;\nlet activeResponseType = null;   // 'yes' | 'no'\nlet questionType = 'general';\nlet offerContext = null;\nlet pendingAction = null;\n\n// ---- Build pendingAction from DB fields, with ARA_PENDING as fallback ----\nlet lastAssistantText = lastAssistant ? (lastAssistant.assistant_response || '') : '';\n\nif (lastAssistant) {\n  // 1) Prefer structured fields from the conversations table\n  if (\n    lastAssistant.pending_action_type &&\n    lastAssistant.pending_action_type !== 'none'\n  ) {\n    pendingAction = {\n      type: lastAssistant.pending_action_type,\n      payload: lastAssistant.pending_action_payload || null,\n      resolved: !!lastAssistant.pending_action_resolved,\n      created_at: lastAssistant.created_at,\n    };\n  } else if (lastAssistantText) {\n    // 2) Backwards-compatible support for old ARA_PENDING footer\n    const match = lastAssistantText.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})\\s*$/);\n    if (match) {\n      try {\n        const pa = JSON.parse(match[1]);\n        if (pa.type && pa.type !== 'none') {\n          pendingAction = {\n            type: pa.type,\n            payload: pa.payload || null,\n            resolved: false,\n            created_at: lastAssistant.created_at,\n          };\n        }\n      } catch (e) {\n        // ignore parse errors\n      }\n    }\n  }\n}\n\n// YES/NO on current message\nconst shortYesNo = isShortYesNo(currentText);\n\n\n// 1) If we have a pending action and user sends short yes/no recently\nif (\n  pendingAction &&\n  pendingAction.type &&\n  pendingAction.type !== 'none' &&\n  isWithinHours(pendingAction.created_at, 48) &&\n  shortYesNo\n) {\n  isActiveResponse = true;\n  activeResponseType = shortYesNo;\n  questionType = 'offer';\n  offerContext = pendingAction.type;\n}\n\n// 2) Fallback: classify last assistant message question type (for general yes/no replies)\nif (!isActiveResponse && lastAssistantText) {\n  const lastText = lastAssistantText.toLowerCase();\n\n  const hasQuestionMark = lastText.includes('?');\n  const hasOfferPattern = /would you like|nak tak|mahu tak|do you want|shall i|should i|may i|can i help|if you‚Äôd like|kalau nak/i.test(lastText);\n  const hasClarificationPattern = /could you clarify|apa yang dimaksud|what do you mean|which one do you mean|yang mana satu/i.test(lastText);\n  const hasConfirmationPattern = /is this correct|is that right|betul tak|setuju tak|confirm/i.test(lastText);\n  const hasChoicePattern = /\\bor\\b|atau\\b/i.test(lastText);\n\n  if (hasOfferPattern) questionType = 'offer';\n  else if (hasClarificationPattern) questionType = 'clarification';\n  else if (hasConfirmationPattern) questionType = 'confirmation';\n  else if (hasChoicePattern) questionType = 'choice';\n  else if (hasQuestionMark) questionType = 'general';\n\n  const yn = shortYesNo;\n  if (yn && (hasOfferPattern || hasConfirmationPattern || hasChoicePattern)) {\n    isActiveResponse = true;\n    activeResponseType = yn;\n\n    if (hasOfferPattern) offerContext = 'offer';\n    else if (hasConfirmationPattern) offerContext = 'confirmation';\n    else if (hasChoicePattern) offerContext = 'choice';\n  }\n}\n\n// ============= STEP 5: BUILD ARA CONTEXT =============\nconst araContext = {\n  user: {\n  id: userData.id || null,\n  name: userData.name || userData.full_name || null,\n  phone: userData.phone || userData.telegram_id || null,\n  preferred_name: userData.preferred_name || null,\n    language_preference: userData.preferred_language || 'auto',\n  features_enabled: userData.features_enabled || null,\n\n  // Main timezone ARA should use\n  timezone:\n    userData.current_timezone ||\n    userData.home_timezone ||\n    userData.timezone ||\n    'Asia/Kuala_Lumpur',\n\n  // Extra fields so the main agent sees both explicitly\n  home_timezone: userData.home_timezone || null,\n  current_timezone: userData.current_timezone || null,\n\n    // ‚úÖ Inject style profile for tone mirroring\n   style_profile: {\n  ...(userData.style_profile || {}),\n  language_mix_cap: 0.3\n}\n\n},\n\n  current_message: {\n    text: currentText,\n    language_hint: null\n  },\n  history: {\n    detailed: detailedConversations.map(c => ({\n      created_at: c.created_at,\n      role: c.role || null,\n      user_message: c.user_message || '',\n      assistant_response: c.assistant_response || '',\n      session_id: c.session_id || null\n    })),\n    older_summaries: olderSummaries\n  },\n  memories: {\n    important: importantMemories,\n    all: userMemories\n  },\n  last_assistant_message: lastAssistant\n    ? {\n        created_at: lastAssistant.created_at,\n        text: lastAssistant.assistant_response || ''\n      }\n    : null,\n  dialogue_state: {\n    isActiveResponse,\n    activeResponseType,\n    questionType,\n    offerContext,\n    pendingAction\n  }\n};\n\nreturn [\n  {\n    json: {\n      ara_context: araContext,\n      // keep original fields\n      ...current\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1680,
        1888
      ],
      "id": "536962f8-5b2a-4be8-99ae-44407c3d86d2",
      "name": "Format Context with Memory"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e13dd0b2-6b72-4cc0-a466-e9677a549c1f",
              "leftValue": "={{ DateTime.fromISO($json.updated_at) < $today.minus({ days: 30 }) }}",
              "rightValue": "=",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3696,
        2224
      ],
      "id": "514449c4-8ac2-4afd-8b7d-08630b80e7d0",
      "name": "Within 30 days?"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "telegram_id",
              "condition": "eq",
              "keyValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.WaId }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -4368,
        1456
      ],
      "id": "a88677bc-101c-49a9-a25f-d0943c7a9b9a",
      "name": "Get User1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Prepare Memories v2 - simpler, cleaner, per-turn\n// Input: array of validated memory objects (from Validate Memories)\n// Output: array of rows ready for ai_memories table\n\nconst input = $input.all().map(i => i.json);\nlet memories = input;\n\n// If someone wired it differently and we got a single array\nif (input.length === 1 && Array.isArray(input[0])) {\n  memories = input[0];\n}\n\nif (!memories || memories.length === 0) {\n  console.log('Prepare Memories: no memories to process');\n  return [];\n}\n\n// ===== Get user context =====\nlet userId = null;\ntry {\n  const userNode = $('Get User1').first();\n  if (userNode && userNode.json && userNode.json.id) {\n    userId = userNode.json.id;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get user ID', e);\n}\n\nif (!userId) {\n  console.log('Prepare Memories: missing user_id, aborting');\n  return [];\n}\n\n// ===== Get existing memories for this user =====\nlet existing = [];\ntry {\n  const rows = $('Get User Memories').all() || [];\n  existing = rows\n    .filter(r => r.json && r.json.memory_value)\n    .map(r => r.json);\n} catch (e) {\n  console.log('Prepare Memories: could not get existing memories', e);\n}\n\n// Build quick lookup structures\nconst existingByKey = {};\nconst existingByValue = new Map();\n\nexisting.forEach(mem => {\n  const key = (mem.memory_key || '').toLowerCase();\n  if (key) existingByKey[key] = mem;\n\n  const val = (mem.memory_value || '').toLowerCase().trim();\n  if (val) existingByValue.set(val, mem);\n});\n\n// ===== Helper: normalize base key =====\nconst slugify = (text) => {\n  return text\n    .toString()\n    .toLowerCase()\n    .normalize('NFKD')\n    .replace(/[^a-z0-9]+/g, '_')\n    .replace(/^_+|_+$/g, '');\n};\n\n// ===== Helper: generate unique key with versions =====\nconst versionCache = {}; // baseKey -> highest version\n\n// Initialize versionCache from existing keys\nObject.keys(existingByKey).forEach(k => {\n  const match = k.match(/^(.*)_v(\\d+)$/);\n  if (match) {\n    const base = match[1];\n    const v = parseInt(match[2], 10);\n    if (!versionCache[base] || v > versionCache[base]) {\n      versionCache[base] = v;\n    }\n  }\n});\n\nconst generateKey = (mem, index) => {\n  // Start from provided key if any\n  let base = mem.memory_key\n    ? slugify(mem.memory_key)\n    : slugify(mem.memory_value || `memory_${index}`);\n\n  // Attach first person if available\n  if (mem.entities && mem.entities.people && mem.entities.people.length > 0) {\n    const person = slugify(mem.entities.people[0]);\n    if (person && !base.includes(person)) {\n      base = `${person}_${base}`;\n    }\n  }\n\n  // Strip existing version suffix\n  base = base.replace(/_v\\d+$/, '');\n\n  const type = mem.memory_type || 'context';\n\n  if (type === 'preference' || type === 'context') {\n    // Versioned keys\n    const current = versionCache[base] || 0;\n    const next = current + 1;\n    versionCache[base] = next;\n    return `${base}_v${next}`;\n  }\n\n  if (type === 'relationship') {\n    // Relationship can be stable per session\n    const now = Date.now();\n    return `${base}_rel_${now}`;\n  }\n\n  if (type === 'interaction') {\n    const now = Date.now();\n    return `${base}_int_${now}`;\n  }\n\n  // Fallback\n  const now = Date.now();\n  return `${base}_${type}_${now}`;\n};\n\n// ===== Very simple similarity check (exact / near exact text) =====\nconst isDuplicateByValue = (value) => {\n  if (!value) return false;\n  const valLower = value.toLowerCase().trim();\n  if (existingByValue.has(valLower)) return true;\n  return false;\n};\n\n// ===== Session & timestamps =====\nlet sessionId = null;\ntry {\n  const ctx = $('Format Context with Memory').first();\n  if (ctx && ctx.json && ctx.json.ara_context && ctx.json.ara_context.history) {\n    sessionId = ctx.json.ara_context.history.detailed?.[0]?.session_id || null;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get session_id from context');\n}\n\nif (!sessionId) {\n  // Fallback session id\n  sessionId = `${Date.now()}_${Math.floor(Math.random() * 100000)}`;\n}\n\nconst nowIso = new Date().toISOString();\n\n// ===== Process memories =====\nconst prepared = [];\n\nmemories.forEach((mem, index) => {\n  if (!mem || !mem.memory_value) return;\n\n  // Skip if same value already exists\n  if (isDuplicateByValue(mem.memory_value)) {\n    console.log('Prepare Memories: skip duplicate by value:', mem.memory_value.substring(0, 60));\n    return;\n  }\n\n  const type = mem.memory_type || 'context';\n  const key = generateKey(mem, index);\n\n  const row = {\n    user_id: userId,\n    memory_type: type,\n    memory_key: key,\n    memory_value: mem.memory_value,\n    importance_score: mem.importance_score ?? 0.8,\n    session_id: sessionId,\n    conversation_date: nowIso,\n    entities: JSON.stringify(mem.entities || { people: [], topics: [] }),\n    temporal_context: mem.temporal_context || 'today',\n    is_active: true,\n    confidence_score: 1,\n    source: 'auto_extracted',\n    context_before: null,\n    context_after: null,\n  };\n\n  prepared.push(row);\n  console.log(`Prepare Memories: ACCEPTED ${key}`);\n});\n\nif (prepared.length === 0) {\n  console.log('Prepare Memories: no new memories after dedupe');\n}\n\nreturn prepared.map(r => ({ json: r }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        2032
      ],
      "id": "04e9117d-78e7-4097-8bcc-b2372cc9d91e",
      "name": "Prepare Memories1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "= {{ $json.user_id }}",
              "rightValue": 0,
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              },
              "id": "ebb88b93-4047-405f-9730-737ec9f4b782"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1360,
        2032
      ],
      "id": "518a6df3-851c-43cf-aae4-a0ba1a32de51",
      "name": "Has Memories?1"
    },
    {
      "parameters": {
        "tableId": "ai_memories",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "memory_type",
              "fieldValue": "={{ $json.memory_type }}"
            },
            {
              "fieldId": "memory_key",
              "fieldValue": "={{ $json.memory_key }}"
            },
            {
              "fieldId": "memory_value",
              "fieldValue": "={{ $json.memory_value }}"
            },
            {
              "fieldId": "importance_score",
              "fieldValue": "={{ $json.importance_score }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "entities",
              "fieldValue": "={{ $json.entities }}"
            },
            {
              "fieldId": "temporal_context",
              "fieldValue": "={{ $json.temporal_context }}"
            },
            {
              "fieldId": "is_active",
              "fieldValue": "={{ $json.is_active }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1584,
        2032
      ],
      "id": "31f3eb2f-99e9-438f-9b8a-15b75cccc64c",
      "name": "Save Memories1"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Session Summary Generator v2\n// - Only summarizes completed sessions\n// - Skips very short/test sessions\n// - Produces richer, more structured summaries\n\nconst MIN_MESSAGES = 3;        // Require at least 3 messages in a session\nconst MIN_GAP_MINUTES = 15;    // Session must have ended at least 15 minutes ago\n\n// ---------- 1. Resolve user ID ----------\nlet userId;\n\ntry {\n  const ctx = $('Format Context with Memory').first();\n  if (ctx?.json?.user_id) {\n    userId = ctx.json.user_id;\n  }\n} catch (e) {\n  console.log('Could not get user ID from Format Context with Memory', e);\n}\n\nif (!userId) {\n  try {\n    const userNode = $('Get User1').first();\n    if (userNode?.json?.id) {\n      userId = userNode.json.id;\n    }\n  } catch (e) {\n    console.log('Could not get user ID from Get User1', e);\n  }\n}\n\n// If we still don't have a userId, we can't safely summarize\nif (!userId) {\n  console.log('No userId found, skipping session summary');\n  return [];\n}\n\n// ---------- 2. Get conversation history for this user ----------\nlet conversations = [];\ntry {\n  conversations = $('Fetch Session History').all() || [];\n} catch (e) {\n  console.log('Could not get conversations from Fetch Session History', e);\n  return [];\n}\n\n// Convert to plain JS objects and filter by this user (safety)\nconst allConversations = conversations\n  .map(c => c.json)\n  .filter(c => c && c.user_id === userId && c.session_id);\n\nif (allConversations.length < MIN_MESSAGES) {\n  console.log('Not enough conversations overall to summarize');\n  return [];\n}\n\n// Sort descending by created_at (newest first)\nallConversations.sort(\n  (a, b) => new Date(b.created_at) - new Date(a.created_at)\n);\n\n// ---------- 3. Work out current vs completed sessions ----------\nconst currentSessionId = allConversations[0].session_id;\nconsole.log('Current session ID:', currentSessionId);\n\nconst sessionsById = {};\nfor (const conv of allConversations) {\n  if (!sessionsById[conv.session_id]) {\n    sessionsById[conv.session_id] = [];\n  }\n  sessionsById[conv.session_id].push(conv);\n}\n\n// Remove the current session from candidates (we only want completed ones)\ndelete sessionsById[currentSessionId];\n\nconst candidateSessionIds = Object.keys(sessionsById);\nif (candidateSessionIds.length === 0) {\n  console.log('No completed sessions to summarize');\n  return [];\n}\n\n// ---------- 4. Pick the most recent completed session ----------\ncandidateSessionIds.sort((a, b) => {\n  const aRecent = Math.max(\n    ...sessionsById[a].map(c => new Date(c.created_at).getTime())\n  );\n  const bRecent = Math.max(\n    ...sessionsById[b].map(c => new Date(c.created_at).getTime())\n  );\n  return bRecent - aRecent;\n});\n\nconst sessionId = candidateSessionIds[0];\nconst sessionToSummarize = sessionsById[sessionId];\n\n// Ensure this session is ‚Äúreal‚Äù and not just a 1-message ping\nif (sessionToSummarize.length < MIN_MESSAGES) {\n  console.log(\n    `Session ${sessionId} has only ${sessionToSummarize.length} messages, skipping summary`\n  );\n  return [];\n}\n\n// Check how long ago this session ended\nconst mostRecentMessageTs = Math.max(\n  ...sessionToSummarize.map(c => new Date(c.created_at).getTime())\n);\nconst minutesSinceLastMessage =\n  (Date.now() - mostRecentMessageTs) / (1000 * 60);\n\nif (minutesSinceLastMessage < MIN_GAP_MINUTES) {\n  console.log(\n    `Session ${sessionId} ended only ${minutesSinceLastMessage.toFixed(\n      1\n    )} minutes ago, skipping summary`\n  );\n  return [];\n}\n\n// ---------- 5. Extract key info from this session ----------\nconst topics = new Set();\nconst people = new Set();\nconst decisions = [];\nlet firstUserMessage = null;\nlet lastUserMessage = null;\n\nfor (const conv of sessionToSummarize) {\n  if (!conv.user_message) continue;\n\n  const msg = conv.user_message;\n  const msgLower = msg.toLowerCase();\n\n  if (!firstUserMessage) firstUserMessage = msg;\n  lastUserMessage = msg;\n\n  // Topics (you can extend this list anytime)\n  if (msgLower.includes('staff') || msgLower.includes('hire') || msgLower.includes('recruit')) {\n    topics.add('hiring');\n  }\n  if (msgLower.includes('remind') || msgLower.includes('ingat')) {\n    topics.add('reminders');\n  }\n  if (msgLower.includes('meeting') || msgLower.includes('jumpa')) {\n    topics.add('meetings');\n  }\n  if (msgLower.includes('stok') || msgLower.includes('inventory')) {\n    topics.add('inventory');\n  }\n  if (msgLower.includes('duit') || msgLower.includes('bayar') || msgLower.includes('payment')) {\n    topics.add('money');\n  }\n\n  // Rough name detection (single capitalized words)\n  const namePattern = /\\b[A-Z][a-z]{2,}\\b/g;\n  const names = msg.match(namePattern) || [];\n  for (const name of names) {\n    if (!['I', 'Ara', 'ARA'].includes(name)) {\n      people.add(name);\n    }\n  }\n\n  // Decisions / plans (keep first 120 chars)\n  if (\n    msgLower.includes('need') ||\n    msgLower.includes('nak ') ||\n    msgLower.includes('akan ') ||\n    msgLower.includes('plan') ||\n    msgLower.includes('will')\n  ) {\n    decisions.push(msg.substring(0, 120));\n  }\n}\n\n// ---------- 6. Timing & meta info ----------\nsessionToSummarize.sort(\n  (a, b) => new Date(a.created_at) - new Date(b.created_at)\n);\nconst sessionStartTime = new Date(sessionToSummarize[0].created_at);\nconst sessionEndTime = new Date(\n  sessionToSummarize[sessionToSummarize.length - 1].created_at\n);\n\nconst dayOfWeekNames = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n];\nconst dayOfWeek = dayOfWeekNames[sessionStartTime.getDay()];\n\nconst hour = sessionStartTime.getHours();\nconst timeOfDay =\n  hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';\n\nconst durationMinutes = Math.max(\n  1,\n  Math.round((sessionEndTime - sessionStartTime) / (1000 * 60))\n);\n\n// ---------- 7. Build human-readable summary ----------\nlet summaryText = 'User ';\n\nif (topics.has('hiring')) {\n  summaryText += 'discussed getting help with hiring or staff issues';\n} else if (topics.size > 0) {\n  summaryText += `discussed ${Array.from(topics).join(', ')}`;\n} else {\n  summaryText += 'had a general conversation';\n}\n\nif (people.size > 0) {\n  summaryText += `, and mentioned ${Array.from(people).join(', ')}`;\n}\n\nsummaryText += `. Conversation lasted about ${durationMinutes} minute(s).`;\n\nif (decisions.length > 0) {\n  summaryText += ' Key decisions or needs were mentioned.';\n}\n\n// ---------- 8. Construct summary record ----------\nconst summary = {\n  user_id: userId,\n  session_id: sessionId,\n  conversation_date: sessionStartTime.toISOString(),\n  day_of_week: dayOfWeek,\n  time_of_day: timeOfDay,\n  summary: summaryText,\n  key_topics: Array.from(topics),\n  people_mentioned: Array.from(people),\n  decisions_made: decisions,\n  message_count: sessionToSummarize.length,\n  session_duration_minutes: durationMinutes,\n};\n\nconsole.log('Generated summary for completed session:', summary);\n\n// n8n expects an array of items: [{ json: ... }]\nreturn [{ json: summary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        2320
      ],
      "id": "4a3db376-90a0-4fae-bb0a-63a9db496e42",
      "name": "Generate Session Summary1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "tableId": "conversation_summaries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "day_of_week",
              "fieldValue": "={{ $json.day_of_week }}"
            },
            {
              "fieldId": "time_of_day",
              "fieldValue": "={{ $json.time_of_day }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $json.summary }}"
            },
            {
              "fieldId": "key_topics",
              "fieldValue": "={{ $json.key_topics }}"
            },
            {
              "fieldId": "people_mentioned",
              "fieldValue": "={{ $json.people_mentioned }}"
            },
            {
              "fieldId": "decisions_made",
              "fieldValue": "={{ $json.decisions_made }}"
            },
            {
              "fieldId": "message_count",
              "fieldValue": "={{ $json.message_count }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1360,
        2320
      ],
      "id": "531a8b0a-7137-4115-8eab-aaae54307605",
      "name": "Save Session Summary1"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $('Extract Pending Action').item.json.assistant_response }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $('Extract Pending Action').item.json.pending_action_type }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $('Extract Pending Action').item.json.pending_action_payload }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "false"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        624,
        2320
      ],
      "id": "9743c83b-4320-4d2b-91e3-bcafcecbad13",
      "name": "Update Conversation",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "reminders",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('conditions0_Field_Value', ``, 'string') }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        -784,
        2144
      ],
      "id": "562d71ce-64be-4677-8b29-873cda16f37b",
      "name": "List Reminders Tool"
    },
    {
      "parameters": {
        "jsCode": "// Validate Memories (hardened)\n// Input: Whatever Extract Memories returns (can be JSON, string, or error envelope)\n// Output: array of clean memory objects as { json: ... }\n// If anything looks wrong, we just return [] and let the workflow continue safely.\n\nconst raw = $json;\n\n// 0) If upstream node failed and we got an error envelope, bail out safely.\nif (raw.error || raw.errorMessage || raw.errorDescription) {\n  console.log('Validate Memories: upstream error detected, skipping memories.');\n  return [];\n}\n\n// 1) Unwrap \"output\" if present\nlet memoriesRaw = raw.output ?? raw;\n\nlet memories = [];\n\ntry {\n  if (typeof memoriesRaw === 'string') {\n    let txt = memoriesRaw.trim();\n\n    // Strip accidental code fences\n    txt = txt\n      .replace(/^```json\\s*/i, '')\n      .replace(/^```\\s*/i, '')\n      .replace(/```$/i, '')\n      .trim();\n\n    const parsed = JSON.parse(txt);\n\n    if (Array.isArray(parsed)) {\n      memories = parsed;\n    } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.memories)) {\n      // Sometimes wrapped as { memories: [...] }\n      memories = parsed.memories;\n    } else {\n      memories = [parsed];\n    }\n\n  } else if (Array.isArray(memoriesRaw)) {\n    memories = memoriesRaw;\n\n  } else if (memoriesRaw && typeof memoriesRaw === 'object') {\n    // Maybe already { memories: [...] } or a single object\n    if (Array.isArray(memoriesRaw.memories)) {\n      memories = memoriesRaw.memories;\n    } else {\n      memories = [memoriesRaw];\n    }\n\n  } else {\n    console.log('Validate Memories: unsupported input type, skipping.');\n    return [];\n  }\n\n} catch (e) {\n  console.log('Validate Memories: failed to parse memories JSON, skipping.', e);\n  return [];\n}\n\nif (!Array.isArray(memories)) {\n  console.log('Validate Memories: parsed value is not an array, skipping.');\n  return [];\n}\n\nconst ALLOWED_TYPES = new Set(['preference', 'relationship', 'context', 'interaction']);\n\nconst cleaned = memories\n  .filter(m => m && typeof m === 'object')\n  .map((m, idx) => {\n    const mem = { ...m };\n\n    // Normalise memory_type\n    if (!ALLOWED_TYPES.has(mem.memory_type)) {\n      if (mem.memory_type === 'business/role') {\n        mem.memory_type = 'context';\n      } else {\n        mem.memory_type = 'context';\n      }\n    }\n\n    // Ensure text fields exist\n    mem.memory_value = (mem.memory_value || '').toString().trim();\n    mem.memory_key = (mem.memory_key || `memory_${idx}`).toString().trim();\n\n    // Default importance\n    const importance = Number(mem.importance_score ?? 0.8);\n    mem.importance_score = Number.isFinite(importance) ? importance : 0.8;\n\n    // Normalise entities\n    const entities = mem.entities || {};\n    mem.entities = {\n      people: Array.isArray(entities.people) ? entities.people : [],\n      topics: Array.isArray(entities.topics) ? entities.topics : [],\n    };\n\n    // Temporal context\n    mem.temporal_context = mem.temporal_context || 'today';\n\n    return mem;\n  })\n  .filter(mem => {\n    // Filter out junk (same rules as before)\n    if (!mem.memory_value || mem.memory_value.length < 10) return false;\n    if (mem.importance_score < 0.7) return false;\n    return true;\n  });\n\n// n8n expects an array of items: [{ json: ... }, ...]\nreturn cleaned.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        912,
        2032
      ],
      "id": "372172ff-c4c9-4c73-ae08-96fcfbfb3e35",
      "name": "Validate Memories"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {
          "maxTokens": 500,
          "temperature": 0.4
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1104,
        2112
      ],
      "id": "c3afd6ee-abab-4a2d-84a9-e069d16963e1",
      "name": "OpenAI Chat Model"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "e060a9e3-cd6b-4a66-aed4-aa8ea0636fe5",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -5040,
        1456
      ],
      "id": "f7422a98-87b8-4c39-b0ab-dcd34ed9eb91",
      "name": "Twilio Webhook",
      "webhookId": "e060a9e3-cd6b-4a66-aed4-aa8ea0636fe5"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e13dd0b2-6b72-4cc0-a466-e9677a549c1f",
              "leftValue": "={{ DateTime.fromISO($json.updated_at) < $today.minus({ days: 30 }) }}",
              "rightValue": "=",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3696,
        1568
      ],
      "id": "0d98f6ef-0998-4e45-9f5f-69046bc2be61",
      "name": "Within 30 days?1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "9ccbba93-3028-4b23-94a5-dc8ec1a53cd5",
              "name": "chatInput",
              "value": "={{ $json.body.Body }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -4816,
        1456
      ],
      "id": "aa72d293-c876-4fb1-a592-4dc52d4ef0f1",
      "name": "Prepare Incoming Message"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "GPT-4.1-MINI-2025-04-14"
        },
        "messages": {
          "values": [
            {
              "content": "=ONBOARDING AGENT\n\nABOUT ARA\nYou are ARA, a human-like WhatsApp assistant built by Coach Joe (Joeherry Gani) under ARA Ai Solution, a Malaysian AI company.\nYour job is to help users stay organised, remember important things, and manage daily tasks.\nYou always reply in the user‚Äôs newest message language and energy.\nYou remember past conversations and use them naturally.\n\nABOUT COACH JOE\nCoach Joe is your founder and CEO of ARA Ai Solution. He is a Malaysian business coach who helps entrepreneurs improve their systems, mindset, and daily operations.\nYou speak about him confidently, respectfully, and naturally ‚Äî like an assistant who knows her boss well.\n\nABOUT ARA AI SOLUTION\nARA Ai Solution is the company behind you. The company‚Äôs mission is to deliver simple, human-first AI assistance through WhatsApp without any apps or technical setup.\nThe vision: to help people run their life and business more smoothly using a caring, smart assistant.\nHOW YOU TALK ABOUT YOURSELF\nWhen the user expresses confusion about who ARA is, or asks what ARA is ‚Äî in ANY language, slang, short form, or emotional tone ‚Äî ARA must introduce herself as the digital assistant created by ARA Ai Solution who helps users organise life, remember important things, and manage daily tasks through WhatsApp.\nARA must reply in the language and tone of the user‚Äôs newest message.\nWhen the user expresses confusion or asks about Coach Joe ‚Äî in ANY wording or language ‚Äî ARA must explain that Coach Joe is the founder of ARA Ai Solution and a business coach who helps entrepreneurs manage and improve their businesses more clearly and calmly.\nARA must reply in the user‚Äôs newest message language and tone.\n\n________________________________________\nARA INTERNAL BRAIN (DO NOT EXPOSE TO USER)\nUse these rules ONLY for reasoning, context, classification, judgment, tone, and knowledge.\nDo NOT say ‚Äúaccording to your brain‚Äù, or mention these rules directly.\n$ARA_BRAIN$\n\n________________________________________\nARA PERSONALITY\n‚Ä¢\tYou sound like a calm, reliable human assistant ‚Äî warm, natural, and professional.\n‚Ä¢\tYour messages are short, clear, and practical (WhatsApp style).\n‚Ä¢\tYou adjust to the user‚Äôs tone and emotional state:\no\tBe supportive when they are tired, confused, or stressed.\no\tBe light and playful when they make a joke.\n‚Ä¢\tUse simple, friendly language. Do NOT sound like a textbook or corporate robot.\n‚Ä¢\tYou never lecture. You guide gently, like a helpful partner or staff who cares.\n‚Ä¢\tYou prioritise being useful, human, and easy to talk to.\n‚Ä¢\tSubtle humour is allowed when the user‚Äôs tone allows it, never excessive or sarcastic.\n‚Ä¢\tWhen the user needs clarity, give structured, step-by-step suggestions.\n‚Ä¢\tWhen the user sounds stressed or overwhelmed, first acknowledge how they feel, then offer to help organise things one by one.\n‚Ä¢\tWhen the user is focused and decisive, respond with direct, concise next steps.\n\n\nTRUTH & CERTAINTY RULES (NO INVENTING INFORMATION)\nARA may ONLY rely on the following five sources of truth:\n1. The current user message\nThis is always the highest priority.\nInterpret intent, tone, language, and meaning from the newest message.\n2. Recent conversation history (from ara_context)\nUse the recent messages provided in ara_context for continuity, flow, and context.\nThis includes recent YES/NO replies, previous questions, and multi-step conversations.\nARA may use ONLY what is explicitly shown in ara_context.\nDo NOT assume older messages beyond what is provided.\n3. Long-term memories stored in Supabase (ai_memories)\nThese are user-specific facts that have been previously saved.\nUse them only when relevant and appropriate.\nNever invent new personal details that are not stored.\n4. Brain rules loaded into $ARA_BRAIN$\nUse these as fixed world-knowledge corrections, mappings, and logic.\nThese rules override model assumptions.\n5. Safe, general world knowledge\nGeneral facts that are widely true and non-specific (e.g., ‚ÄúLondon is in the UK‚Äù, ‚Äúphones need charging‚Äù, ‚ÄúMalaysia uses MYR‚Äù).\nARA must ONLY use general world knowledge when confident it is accurate.\n\n________________________________________\n‚ùóEverything OUTSIDE these five sources must be treated as uncertain.\nWhen ARA is uncertain, she must respond naturally (in the user‚Äôs newest message language and tone) using brief honesty statements such as:\n‚Ä¢\t‚ÄúSaya tak pasti yang tepat‚Ä¶‚Äù\n‚Ä¢\t‚ÄúNot fully sure, but here‚Äôs what I can confirm‚Ä¶‚Äù\n‚Ä¢\t‚ÄúKalau boleh jelaskan sikit, saya boleh bantu lebih tepat.‚Äù\n‚Ä¢\t‚ÄúI might need a bit more detail for this.‚Äù\n\n________________________________________\nüî• ARA must NEVER invent or fabricate:\n‚Ä¢\tURLs or links\n‚Ä¢\tSong lyrics\n‚Ä¢\tExact song lists, book lists, or catalog items\n‚Ä¢\tDates, times, or numbers\n‚Ä¢\tPersonal details about people\n‚Ä¢\tTechnical instructions that were not provided\n‚Ä¢\tAny fact that does not exist in the 5 allowed sources\nNo guessing.\nNo filling in gaps.\nNo confident claims without evidence.\nARA must always choose honesty over guesswork, even if the answer becomes shorter, simpler, or incomplete.\n\n________________________________________\nCRITICAL LANGUAGE RULE\n‚Ä¢\tFor every reply, first detect the language and tone (energy) of the user‚Äôs newest message.\n‚Ä¢\tYou MUST reply in the same main language and with similar energy as that newest message.\n‚Ä¢\tIf the newest user's message is in English ‚Üí reply in English, matching their tone.\n‚Ä¢\tIf the newest user's message is in Malay ‚Üí reply in Malay, matching their tone.\n‚Ä¢\tIf the newest user's message is in another language you understand ‚Üí reply fully in that language, matching their tone.\n‚Ä¢\tOnly mix languages if the user clearly mixes languages in the same newest message.\n‚Ä¢\tIgnore the language used in older messages ‚Äî always follow the newest one.\n\n\nLanguage and Style Behavior:\n- Match the user‚Äôs writing style ‚Äî including slang, emoji usage, message length, and punctuation rhythm ‚Äî but never use more slang, emojis, or code-switching than the user.\n- If the user mixes Malay and English within a sentence (e.g., ‚ÄúJap, I check dulu‚Äù), mirror this same intra-sentence code-mixing ratio.\n- Do not rephrase rojak messages into full English or full Malay unless the user clearly writes in only one language.\n- If ara_context.user.style_profile exists, use it to guide tone, slang, and language ratio ‚Äî including:\n‚Ä¢ Respect language_mix_cap as the maximum allowed code-mix ratio for that user.\n‚Ä¢ Never exceed this ratio even if the newest message has more.\n‚Ä¢ If no style_profile exists, follow the newest message's language and style exactly.\n\n\n________________________________________\nGENERAL BEHAVIOUR\n‚Ä¢\tKeep replies short and practical: 1‚Äì3 short paragraphs or a few bullet points.\n‚Ä¢\tBe friendly, respectful, and professional.\n‚Ä¢\tLight humour is okay when the user‚Äôs tone allows it.\n‚Ä¢\tWhen the user seems stressed or confused, empathise first, then give structure.\n‚Ä¢\tWhen unsure, briefly restate what you think they mean and ask one clear follow-up question.\n\n________________________________________\nCONTEXT HANDLING\nYou receive a JSON object called ara_context. It includes:\n‚Ä¢\tuser profile & preferences\n‚Ä¢\trecent conversation history\n‚Ä¢\tlong-term memories about the user\n‚Ä¢\tthe last question you asked (if any)\n‚Ä¢\twhether the user‚Äôs current message is likely a YES/NO reply\n‚Ä¢\tany pending action you previously proposed\n‚Ä¢\tdialogue_state containing:\no\tisActiveResponse (bool)\no\tactiveResponseType (\"yes\" | \"no\" | null)\no\tpendingAction object (if any)\nUsing context:\n‚Ä¢\tTreat the user‚Äôs current message as the main focus.\n‚Ä¢\tUse ara_context only to interpret meanings, not to override the current message.\n‚Ä¢\tIf dialogue_state.isActiveResponse is true and a pending action exists, treat short replies (‚Äúyes‚Äù, ‚Äúye‚Äù, ‚Äúok‚Äù, ‚Äúboleh‚Äù, etc.) as answers to that pending action.\n‚Ä¢\tIf you are not certain what the user means, ask one clear clarifying question.\n\n\n________________________________________\n\n\nUSER PROFILE & LANGUAGE PREFERENCE UPDATES (ARA_ACTION)\n\nIn addition to ARA_PENDING, you MUST instruct the external system to update the user‚Äôs profile by emitting an ARA_ACTION line.\n\nARA_ACTION is SEPARATE from ARA_PENDING and is always a single JSON object on its own line, for example:\nARA_ACTION: {\"type\":\"none\"}\n\nGENERAL RULE:\n‚Ä¢ In EVERY reply, you MUST output exactly ONE ARA_ACTION line.\n‚Ä¢ If this message does NOT change any name or language preferences, use:\n  ARA_ACTION: {\"type\":\"none\"}\n\nThere is ONE supported action type:\n\n1. update_user_preferences\n\nYou MUST use this action in BOTH of these situations:\n\nA) The user gives a direct instruction, e.g.:\n‚Ä¢ \"Call me Joey\"\n‚Ä¢ \"Just call me Zack\"\n‚Ä¢ \"Panggil saya Mimi\"\n‚Ä¢ \"Nama saya Syafiqah, panggil saya Fiqah\"\n‚Ä¢ \"Change my preferred language to English\"\n‚Ä¢ \"Lepas ni jawab dalam BM ya\"\n‚Ä¢ \"Tukar bahasa kepada Bahasa Indonesia\"\n\nB) The user is clearly answering YOUR question about name or language during onboarding, e.g.:\n‚Ä¢ \"Malay la\"\n‚Ä¢ \"Bahasa ok\"\n‚Ä¢ \"Ok\"\n‚Ä¢ \"Set Bahasa ke melayu ye\"\n‚Ä¢ \"BM je\"\n‚Ä¢ \"English please\"\n‚Ä¢ \"Bahasa Indonesia\"\n‚Ä¢ \"Indo je\"\n‚Ä¢ \"Panggil saya Kak Ana\"\nAny similar short reply that obviously tells you what name or language to use MUST trigger update_user_preferences.\n\nWhen you trigger this action you MUST:\n‚Ä¢ Reply normally to the user in WhatsApp style (main message).\n‚Ä¢ ALSO output an ARA_ACTION JSON with these fields:\n\nARA_ACTION: {\n  \"type\": \"update_user_preferences\",\n  \"preferred_name\": \"<new name or null>\",\n  \"preferred_language\": \"<lang code or null>\"\n}\n\nField rules:\n‚Ä¢ Only fill the field(s) that are actually being changed in this message.\n  - If the user only changes name:\n    - \"preferred_name\": \"<new name>\"\n    - \"preferred_language\": null\n  - If the user only changes language:\n    - \"preferred_name\": null\n    - \"preferred_language\": \"ms\" | \"en\" | \"id\"\n  - If the user clearly changes both, set both fields.\n\nLanguage code mapping:\n‚Ä¢ \"Malay\", \"BM\", \"Bahasa\", \"Bahasa Melayu\", \"Malay la\", \"BM je\", \"Set Bahasa ke Melayu\" ‚Üí \"ms\"\n‚Ä¢ \"English\", \"Inggeris\", \"English please\" ‚Üí \"en\"\n‚Ä¢ \"Bahasa Indonesia\", \"Indonesian\", \"Indo\", \"Indo je\" ‚Üí \"id\"\n\nIf the message is genuinely ambiguous AND it is NOT an obvious direct answer to your own question about name or language:\n‚Ä¢ Do NOT use \"update_user_preferences\".\n‚Ä¢ Ask ONE short clarifying question in the user‚Äôs language.\n‚Ä¢ For that turn, set:\n  ARA_ACTION: {\"type\":\"none\"}\n\n\n\n________________________________________\nPENDING ACTION CONFIRMATION LOGIC (IMPORTANT)\nWhen ara_context.dialogue_state.pendingAction exists, treat it as the source of truth.\nARA never calls tools directly. The external system performs the actual action based on\nyour reply and the ARA_PENDING line.\n1. Reminder Create ‚Üí user replies YES\n(pendingAction.type === \"reminder_offer\" AND activeResponseType === \"yes\")\nYou MUST:\n‚Ä¢\tAssume the system should now create the reminder using pendingAction.payload.\n‚Ä¢\tReply with a short confirmation that their reminder has been set.\n‚Ä¢\tMention the reminder topic and time from pendingAction.payload (do NOT invent a new time).\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\n‚Ä¢\tKeep it 1‚Äì2 short WhatsApp-style sentences.\nAt the very end of your message, on a new line, append exactly:\nARA_PENDING: {\"type\":\"reminder_create\",\"payload\": pendingAction.payload}\nNo more text, emojis, or formatting after this line.\nDo NOT wrap this line in code fences.\n\n________________________________________\n2. Reminder Create ‚Üí user replies NO\n(pendingAction.type === \"reminder_offer\" AND activeResponseType === \"no\")\nYou MUST:\n‚Ä¢\tAssume the system will NOT create the reminder.\n‚Ä¢\tReply with a short, polite confirmation that you will not set that reminder.\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\nThen end the message with exactly:\nARA_PENDING: {\"type\":\"none\"}\nNo more text after this line.\n\n________________________________________\n3. Timezone Update ‚Üí user replies YES\n(pendingAction.type === \"timezone_offer\" AND activeResponseType === \"yes\")\nYou MUST:\n‚Ä¢\tAssume the system should now update the user's timezone using pendingAction.payload.\n‚Ä¢\tReply with a short confirmation that you will use this timezone from now on.\n‚Ä¢\tMention the timezone_label from pendingAction.payload when referring to the time.\n‚Ä¢\tDo NOT assume Malay just because the timezone is in Malaysia.\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\n‚Ä¢\tKeep it 1‚Äì2 short WhatsApp-style sentences.\nThen append exactly:\nARA_PENDING: {\"type\":\"timezone_update\",\"payload\": pendingAction.payload}\nNo more text after this line.\n\n________________________________________\n4. Timezone Update ‚Üí user replies NO\n(pendingAction.type === \"timezone_offer\" AND activeResponseType === \"no\")\nYou MUST:\n‚Ä¢\tAssume the system will keep the existing timezone.\n‚Ä¢\tReply with a short confirmation that you will keep the current timezone.\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\nThen end with:\nARA_PENDING: {\"type\":\"none\"}\nNo more text after this line.\n\n________________________________________\n5. DELETE REMINDERS ‚Äì CONFIRMATION LOGIC\nWhen the user has already seen a delete-offer (‚ÄúDo you want me to delete this reminder?‚Äù) and now replies YES/NO, you will have in ara_context:\n‚Ä¢\tdialogue_state.isActiveResponse\n‚Ä¢\tdialogue_state.activeResponseType\n‚Ä¢\tdialogue_state.pendingAction (may contain a previous reminder_delete_offer)\n5.1 If this is a YES to delete (activeResponseType === \"yes\"):\na) Reuse pending action if possible:\nIf:\n‚Ä¢\tdialoque_state.pendingAction exists\n‚Ä¢\tAND pendingAction.type === \"reminder_delete_offer\"\n‚Ä¢\tAND pendingAction.payload.reminder_id exists\nThen:\n‚Ä¢\tLet reminderId = pendingAction.payload.reminder_id\n‚Ä¢\tLet topic = pendingAction.payload.topic\n‚Ä¢\tLet timeDisplay = pendingAction.payload.time_display\n‚Ä¢\tReply with a brief confirmation that the reminder with this topic and time has been deleted, in the language and energy of the user‚Äôs newest message.\n‚Ä¢\tThen append:\nARA_PENDING: {\"type\":\"reminder_delete\",\"payload\":{\"reminder_id\":\"{{reminderId}}\"}}\nYou MUST NOT use ara_context.user.id as the reminder_id.\nb) If no pendingAction is available or usable:\n‚Ä¢\tCall the List Reminders tool for this user (user_id = ara_context.user.id).\n‚Ä¢\tIdentify the reminder that best matches the topic/time that was previously discussed.\n‚Ä¢\tLet its ID be reminderId.\n‚Ä¢\tReply to the user as in (a), then append:\nARA_PENDING: {\"type\":\"reminder_delete\",\"payload\":{\"reminder_id\":\"{{reminderId}}\"}}\nAgain: reminder_id must be the reminders table ID, not ara_context.user.id.\n5.2 If this is a NO to delete (activeResponseType === \"no\"):\n‚Ä¢\tDo NOT call any tools.\n‚Ä¢\tReply briefly that you will keep the reminder (language + energy of newest user‚Äôs message).\n‚Ä¢\tEnd with:\nARA_PENDING: {\"type\":\"none\"}\n5.3 If the user replies with something else (not a clear yes/no):\n‚Ä¢\tClarify what they want instead of deleting automatically.\n‚Ä¢\tDo NOT output a reminder_delete action in that case.\n\n________________________________________\n6. General rules for pending actions\n‚Ä¢\tNEVER repeat the same confirmation question once the user has already answered.\n‚Ä¢\tA YES must immediately confirm the action in your reply.\n‚Ä¢\tA NO must immediately cancel the action in your reply.\n‚Ä¢\tDo NOT propose a new action in the same message where you are confirming or cancelling a previous pendingAction.\n\n________________________________________\nREMINDERS / FOLLOW-UP RULES\nARA must help the user create and manage reminders safely, clearly, and only when the user truly intends it. ARA should always behave like a careful, smart assistant\n1. WHEN TO TREAT A MESSAGE AS A REMINDER REQUEST\nTreat a message as a reminder request only when:\nA) User expresses clear reminder intent such as:\n‚Ä¢\tMalay intent words for ‚Äúremind‚Äù / ‚Äúingatkan‚Äù / ‚Äúperingatan‚Äù / etc\n‚Ä¢\tEnglish intent words like ‚Äúremind me‚Äù, ‚Äúset a reminder‚Äù, ‚Äúdon‚Äôt let me forget‚Äù etc\n‚Ä¢\tOr any word from any language similar to the meanings of the example words\nAND the message includes a task (follow up, call, meeting, send file, etc.).\nB) If the user mentions a future date/time WITHOUT reminder words:\n‚Ä¢\tDo NOT assume it‚Äôs a reminder.\n‚Ä¢\tAsk whether they want it as a reminder or just a note, using the language and energy of the user‚Äôs newest message.\n‚Ä¢\tOnly proceed to reminder flow if they clearly indicate yes.\nC) If there are no reminder words and no time/date:\n‚Ä¢\tTreat as a note/memory, NOT a reminder.\n\n________________________________________\n2. TIME RULE ‚Äî NO REMINDERS WITHOUT SPECIFIC TIME\n‚Ä¢\tARA must ALWAYS require an exact time (HH:MM).\n‚Ä¢\tIf the user says ‚Äúesok / petang / malam / tomorrow / tonight‚Äù but gives no HH:MM ‚Üí ask for the specific time in the language and energy of the newest user‚Äôs message.\n‚Ä¢\tNo default times are allowed. Never assume (‚Äúmorning = 9am‚Äù, etc.).\n‚Ä¢\tDo not create a reminder until the user provides a clear time.\nTime conversion:\n‚Ä¢\tConvert the interpreted time into ISO 8601 format.\n‚Ä¢\tUse current_timezone as the reference timezone, unless the user explicitly specifies another timezone.\n‚Ä¢\tStore the final ISO datetime in payload.suggested_time.\nSpeaking about time:\n‚Ä¢\tWhen describing times to the user, use timezone_label (e.g. ‚Äúwaktu Kuala Lumpur‚Äù, ‚ÄúLondon time‚Äù), phrased naturally in the user‚Äôs newest message language.\n\n________________________________________\nTIME ENGINE (NATURAL LANGUAGE TIME)\nUse current_time_iso, current_timezone, and timezone_label to interpret phrases like:\n‚Ä¢\t‚Äúesok‚Äù, ‚Äútomorrow‚Äù\n‚Ä¢\t‚Äúnext Friday‚Äù, ‚Äúminggu depan‚Äù\n‚Ä¢\t‚Äúmalam nanti‚Äù\n‚Ä¢\t‚Äúesok 2.30‚Äù, ‚Äútomorrow 3pm‚Äù\nIf only date/day is given but no time, ask for the time as described above.\n\n__________________________________________\nONBOARDING MODE (SPECIAL RULES)\nYou are in ONBOARDING MODE. Your top priorities are:\n1.\tWelcome the user and introduce who you are.\n2.\tMake sure the user is comfortable with the language you are using. Only after you get the user's preferred language, you may proceed to no 3 (set timezone) NEVER ask no 2 and no 3 in the same message\n3.\tHelp the user register or confirm their current timezone using the TIMEZONE ENGINE.\n4.\tAnswer general questions normally, but do NOT create, list, or delete reminders yet.\nThe external system will route future messages to the main ARA agent once the user has a valid home_timezone.\nDuring onboarding:\n‚Ä¢\tYou may talk normally about reminders as a concept.\n‚Ä¢\tBut you must NOT emit any reminder-related ARA_PENDING actions.\n\n________________________________________\nWELCOME LOGIC (FIRST CONTACT VS RETURNING)\nYou will receive a field called assistant_response. Treat it as:\n‚Ä¢\tIf assistant_response is null or empty:\n‚Üí This is the user‚Äôs first interaction.\n‚Üí You MUST perform the WELCOME USER flow.\n‚Ä¢\tIf assistant_response is NOT null and NOT empty:\n‚Üí The user has interacted before.\n‚Üí You MUST skip the full welcome and go straight to TIME ZONE REGISTRATION (if timezone is not yet set) or normal conversation.\nWELCOME USER message structure (first time only):\nGenerate ONE WhatsApp message with short paragraphs separated by blank lines:\n1.\tGreeting (adjust if they likely came from business card):\no\tIf it sounds like they contacted you from Coach Joe‚Äôs business card:\n‚ÄúHi! üòä Terima kasih contact ARA melalui kad bisnes CEO kami, Coach Joe.‚Äù\no\tOtherwise:\n‚ÄúHi! üòä Terima kasih contact ARA.‚Äù\n2.\tIntroduce yourself briefly:\n‚ÄúSaya ARA ‚Äî pembantu AI yang ingat setiap perbualan, faham awak dan bisnes awak, dan bantu ingatkan perkara penting supaya awak tak terlepas peluang.‚Äù\n3.\tConfirm language:\n‚ÄúBy the way, bahasa yang saya guna ni okay tak? Atau awak lebih selesa dalam English atau bahasa lain?‚Äù\nThen proceed naturally toward TIME ZONE REGISTRATION.\n\n________________________________________\nTIME ZONE REGISTRATION (ONBOARDING FOCUS)\nPolitely explain (in the user‚Äôs newest message language) that you need to register their current timezone so that, later, reminders and follow-ups can be accurate.\nAsk for either:\n‚Ä¢\ttheir current city, or\n‚Ä¢\ttheir current timezone.\nExample in Malay:\n‚ÄúUntuk saya bantu urus reminder dengan tepat nanti, saya perlu tahu zone waktu awak sekarang. Awak berada di bandar mana ya (contoh: KL, London, Singapore)?‚Äù\nAfter that, use the TIMEZONE ENGINE rules below.\n\n________________________________________\nTIMEZONE ENGINE\nDetect timezone intent when user says things like:\n‚Ä¢\t‚ÄúI‚Äôm in London‚Äù, ‚ÄúSaya di Singapore‚Äù, ‚ÄúI‚Äôm back in Malaysia‚Äù, ‚ÄúSaya di Sabah‚Äù, etc.\nSteps:\n‚Ä¢\tRecognise that they are telling you a location relevant to timezone.\n‚Ä¢\tAsk ONE short confirmation question in the newest user‚Äôs message language, clearly stating the interpreted city/country/timezone label.\n‚Ä¢\tIf you can map the city to a supported IANA timezone, prepare a timezone proposal.\nSupported mappings (examples):\n‚Ä¢\tLondon ‚Üí Europe/London\n‚Ä¢\tSingapore ‚Üí Asia/Singapore\n‚Ä¢\tTokyo ‚Üí Asia/Tokyo\n‚Ä¢\tJakarta ‚Üí Asia/Jakarta\n‚Ä¢\tSabah/Sarawak ‚Üí Asia/Kuching\n‚Ä¢\tMalaysia/KL, ‚ÄúKL‚Äù, ‚ÄúKuala Lumpur‚Äù ‚Üí Asia/Kuala_Lumpur\nIf you cannot map the city:\n‚Ä¢\tAsk briefly for a clearer city/country name in the user‚Äôs newest message language.\n‚Ä¢\tUse ARA_PENDING: {\"type\":\"none\"} in that turn.\nConfirmation step:\n‚Ä¢\tOnce you propose a timezone, end the message with:\nARA_PENDING: {\"type\":\"timezone_offer\",\"payload\":{\"timezone\":\"<IANA_timezone>\",\"timezone_label\":\"<human_label>\"}}\nActual update only happens if the user later replies YES, handled by the timezone update confirmation logic.\nDo NOT create reminders until timezone is known.\n\n________________________________________\nSMART CONFIRMATION BEFORE CREATING REMINDERS\nARA must behave like a careful assistant: no silent reminder creation.\nA) When user already gave complete details (task + date + exact time):\n‚Ä¢\tSummarise the reminder details back to the user in the newest message language and tone.\n‚Ä¢\tClearly ask for confirmation in the same message.\n‚Ä¢\tAt the end of that message, output:\nARA_PENDING: {\"type\":\"reminder_offer\",\"payload\":{...}}\nThe payload contains the topic and ISO time you interpreted.\nThis records a proposed reminder only; the system will wait for YES/NO.\nB) When user gave incomplete details (missing time):\n‚Ä¢\tAsk exactly ONE clear follow-up question to get the missing detail, in the newest message language.\n‚Ä¢\tDo NOT set any reminder yet.\n‚Ä¢\tDo NOT output reminder_create or reminder_offer payload on this turn.\n‚Ä¢\tUse:\nARA_PENDING: {\"type\":\"none\"}\nWhen the user later provides the missing time, treat it as case (A).\nC) General rules:\n‚Ä¢\tNever create a reminder or imply that it exists before the user clearly confirms.\n‚Ä¢\tAlways summarise what you are about to do before asking for confirmation.\n‚Ä¢\tAlways rely on pendingAction + YES/NO logic; you only talk and emit ARA_PENDING.\n\n________________________________________\nLIST REMINDERS\nWhen user asks to see their reminders (in any language), you MUST:\n1.\tNever ask for technical IDs\no\tDo NOT ask for user_id, UUID, etc.\no\tAlways use ara_context.user.id internally.\no\tIf ara_context.user.id is missing/null, apologise and say you cannot access reminders now, invite them to try again later.\n2.\tUse the List Reminders tool/system\no\tDo NOT guess or invent reminders.\no\tIf the tool errors or returns nothing, say simply (in the newest message language) that no reminders could be retrieved, or that there are no active reminders.\n3.\tPresenting reminders\no\tGroup by day when possible (Today, Tomorrow, specific upcoming dates).\no\tUse a simple bullet-style list in the newest message language.\no\tEach reminder should show:\nÔÇß\tshort topic/label\nÔÇß\ttime, including timezone_label if available (phrased naturally).\n4.\tNo reminders case\no\tIf no reminders exist, say clearly that there are no active reminders.\no\tYou may invite the user to create one.\nARA_PENDING footer:\n‚Ä¢\tIf only listing (no follow-up offer):\nARA_PENDING: {\"type\":\"none\"}\n‚Ä¢\tIf you propose a follow-up action (like asking if they want to delete one), set an appropriate pending action type and payload, as per the delete rules, and encode it via ARA_PENDING.\n\n________________________________________\nDELETE REMINDERS\nWhen the user asks to delete a reminder:\n1.\tDo NOT ask for IDs or detailed technical info.\no\tDo not ask them for exact IDs or database keys.\no\tYour job is to identify the reminder using your tools and context.\n2.\tAlways list internally first\no\tUse the List Reminders tool with ara_context.user.id.\no\tNever invent reminders.\n3.\tFuzzy-match user message to reminders\no\tCompare user‚Äôs message against reminder topics and human-readable times using fuzzy/semantic matching.\n4.\tHandle cases:\n‚Ä¢\tExactly one match\no\tBriefly show which reminder you found (topic + time) in the newest user‚Äôs message language.\no\tAsk if they want that one deleted.\no\tEnd that message with:\nARA_PENDING: {\"type\": \"reminder_delete_offer\",\"payload\":{\"reminder_id\":\"<id>\",\"topic\":\"<topic>\",\"time_display\":\"<readable_time>\"}}\n‚Ä¢\tMultiple matches\no\tShow a short numbered list of the possible matches.\no\tAsk which one they mean.\no\tEnd with:\nARA_PENDING: {\"type\":\"none\"}\no\tWait for user clarification, then handle as the single-match case.\n‚Ä¢\tNo matches\no\tInform the user that you couldn‚Äôt find a relevant reminder.\no\tOptionally ask if they want to see the full list of their reminders.\no\tEnd with:\nARA_PENDING: {\"type\":\"none\"}\n5.\tNever delete without confirmation\no\tOnly proceed to delete logic when the user clearly confirms, using the YES/NO confirmation rules above.\n\n________________________________________\nESCALATION (NO CONFIRMATION NEEDED)\nARA must automatically escalate to a human/admin when:\n‚Ä¢\tThe user expresses dissatisfaction, frustration, or disappointment.\n‚Ä¢\tThe issue cannot be resolved after two attempts.\n‚Ä¢\tThe issue requires human verification or judgement.\n‚Ä¢\tThe user explicitly asks for a human/admin.\nWhen escalating:\n‚Ä¢\tBriefly apologise in the newest user‚Äôs message language.\n‚Ä¢\tInform the user that their issue has been escalated to a human/admin.\n‚Ä¢\tThen output:\nARA_PENDING: {\"type\":\"escalate\",\"payload\":{\"reason\":\"short description of issue\",\"summary\":\"1‚Äì2 sentence summary of what the user needs\",\"last_user_message\":\"<user's latest message>\",\"urgency\":\"normal\"}}\nDo NOT ask for confirmation to escalate.\nAlways tell the user that escalation has already been done.\n\n________________________________________\nNO SILENT ACTIONS\nARA must NOT create, update, or delete reminders unless:\n‚Ä¢\tThe user clearly intends it,\n‚Ä¢\tARA explains what is happening, and\n‚Ä¢\tThe user agrees (if required by the flow).\n\n________________________________________\n________________________________________\nMANDATORY ARA_ACTION & ARA_PENDING RULES\n\nIn EVERY reply, the structure at the end MUST be:\n\n1) One ARA_ACTION line\n2) One ARA_PENDING line (this is ALWAYS the final line)\n\nARA_ACTION RULES:\n‚Ä¢ You MUST always output exactly ONE ARA_ACTION line.\n‚Ä¢ If the current message does NOT change any name or language preferences:\n  ARA_ACTION: {\"type\":\"none\"}\n‚Ä¢ If the message sets or changes name/language, use:\n  ARA_ACTION: {\"type\":\"update_user_preferences\", ...}\n  following the rules in the USER PROFILE & LANGUAGE PREFERENCE UPDATES section.\n‚Ä¢ ARA_ACTION must appear on its own line, right BEFORE ARA_PENDING.\n‚Ä¢ Never explain ARA_ACTION to the user.\n\nARA_PENDING RULES:\n‚Ä¢ After the ARA_ACTION line, you MUST include exactly ONE ARA_PENDING line.\n‚Ä¢ If there is no pending action to propose:\n  ARA_PENDING: {\"type\":\"none\"}\n‚Ä¢ If ARA proposes an action, use one appropriate variant, for example:\n  - ARA_PENDING: {\"type\":\"reminder_create\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"reminder_delete\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"reminder_offer\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"timezone_offer\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"timezone_update\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"escalate\",\"payload\":{...}}\nRules:\n‚Ä¢ ARA_PENDING MUST be the LAST line in the message.\n‚Ä¢ It MUST start with ARA_PENDING:.\n‚Ä¢ It MUST contain valid JSON.\n‚Ä¢ Neither ARA_ACTION nor ARA_PENDING may be wrapped in code fences.\n‚Ä¢ They MUST never be explained to the user.\n\n\n",
              "role": "system"
            },
            {
              "content": "=Current message:\n{{$node[\"Get Latest Conversation1\"].json[\"user_message\"] || $node[\"Format Context with Memory1\"].json[\"ara_context\"].current_message.text || $json[\"user_message\"] || $json[\"message\"]}}\n\nARA context:\n{{JSON.stringify($node[\"Format Context with Memory1\"].json[\"ara_context\"])}}"
            }
          ]
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        -1456,
        560
      ],
      "id": "4807d869-5360-4cc2-9d19-87a76851b2cf",
      "name": "Free User Onboarding"
    },
    {
      "parameters": {
        "tableId": "users",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "telegram_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "plan_type",
              "fieldValue": "free"
            },
            {
              "fieldId": "telegram_username",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.ProfileName }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -4592,
        1456
      ],
      "id": "980bc11b-7bf6-4845-85cd-c36d3829fec5",
      "name": "Ensure User Exist",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ $('Format Context with Memory').item.json.ara_context.user.phone }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        272,
        2176
      ],
      "id": "9a008717-7b4e-4a65-b020-b9d3e168f36f",
      "name": "Send Reply"
    },
    {
      "parameters": {
        "from": "whatsapp:+601125911400",
        "to": "={{ $item(0).$node[\"Get User1\"].json.telegram_chat_id }}\n",
        "toWhatsapp": true,
        "message": "=Maaf ye, anda telah sampai ke penghujung 30 hari penggunaan percuma anda.  Untuk kembali menggunakan ARA:  1. Sila salin mesej ini dan hantar ke admin di [WhatsApp](https://api.whatsapp.com/send?phone=601136521251)   2. Sertakan bukti pembayaran  ARA Smart: RM 39/bln (Promosi. Normal RM 99) ARA Pro: RM 199/bln ARA Biz: RM 299/bln  User name: {{ $json.first_name }} Telegram id: {{ $json.telegram_id }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -3472,
        2080
      ],
      "id": "f9a72d84-bea3-42d1-b1bb-ac78315a63d3",
      "name": "Send Paid Plan 1"
    },
    {
      "parameters": {
        "from": "whatsapp:+601125911400",
        "to": "={{ $item(0).$node[\"Get User1\"].json.telegram_chat_id }}\n",
        "toWhatsapp": true,
        "message": "=Maaf ye, anda telah sampai ke penghujung 30 hari penggunaan percuma anda.  Untuk kembali menggunakan ARA:  1. Sila salin mesej ini dan hantar ke admin di [WhatsApp](https://api.whatsapp.com/send?phone=601136521251)   2. Sertakan bukti pembayaran  ARA Smart: RM 39/bln (Promosi. Normal RM 99) ARA Pro: RM 199/bln ARA Biz: RM 299/bln  User name: {{ $json.first_name }} Telegram id: {{ $json.telegram_id }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -3472,
        2272
      ],
      "id": "68bebc90-3f5c-45d3-a26c-efa37c8a89f9",
      "name": "Send Paid Plan 2"
    },
    {
      "parameters": {
        "url": "https://jjeqmysluzsohwjpyvip.supabase.co/rest/v1/conversations",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ 'eq.' + $json.ara_context.user.id }}"
            },
            {
              "name": "order",
              "value": "created_at.desc"
            },
            {
              "name": "limit",
              "value": "1"
            },
            {
              "name": "select",
              "value": "*"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1392,
        1888
      ],
      "id": "c5a6ce87-3851-40f2-ab78-aad1a2d33406",
      "name": "Get Latest Conversation"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract Pending Action\n// ----------------------\n// Input from ARA Main Agent:\n//   { output: \"<assistant reply from ARA Main Agent>\" }\n//\n// Behaviour:\n// - If reply contains `ARA_PENDING: { ... }`, parse it into:\n//      pending_action_type, pending_action_payload\n// - Remove BOTH the ARA_PENDING and ARA_ACTION blocks\n//   from the text for WhatsApp\n// - Keep the original `output` for logging / Update Conversation\n\nconst reply = $json.output || '';   // raw reply from ARA Main Agent\nlet cleanReply = reply;\n\nlet pending_action_type = 'none';\nlet pending_action_payload = null;\n\n// 1) Extract & handle ARA_PENDING\nconst pendingMatch = reply.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})/);\n\nif (pendingMatch) {\n  try {\n    const parsed = JSON.parse(pendingMatch[1]);  // { type, payload }\n    if (parsed && parsed.type) {\n      pending_action_type = parsed.type || 'none';\n      pending_action_payload = parsed.payload || null;\n    }\n  } catch (err) {\n    // If parse fails, we just treat it as no pending action\n  }\n\n  // Remove the ARA_PENDING part from the visible reply\n  cleanReply = cleanReply.replace(pendingMatch[0], '').trim();\n}\n\n// 2) Strip ARA_ACTION from visible reply (we parse it later in Route Confirmed Actions)\nconst actionMatch = reply.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\nif (actionMatch) {\n  cleanReply = cleanReply.replace(actionMatch[0], '').trim();\n}\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Clean text for Send Reply (no ARA_ACTION / ARA_PENDING)\n  assistant_response: cleanReply,\n\n  // Action description from THIS message (pending action only)\n  pending_action_type,\n  pending_action_payload,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -640,
        1888
      ],
      "id": "c332dadf-6893-4874-8fc5-941185ee2682",
      "name": "Extract Pending Action"
    },
    {
      "parameters": {
        "jsCode": "// ROUTE CONFIRMED ACTIONS\n// -----------------------\n// INPUT EXPECTED (from Extract Pending Action + previous nodes):\n// - pending_action_type       (from THIS assistant reply's ARA_PENDING)\n// - pending_action_payload\n// - ara_context               (contains dialogue_state with pendingAction from DB)\n// - user_message              (latest user input)\n// - assistant_response        (for passing through to Send Reply)\n\nconst currentType = $json.pending_action_type || 'none';\nconst currentPayload = $json.pending_action_payload || null;\n\n// ara_context comes from \"Format Context with Memory\"\nconst araContext = $json.ara_context || {};\nconst ds = araContext.dialogue_state || {};\nconst pending = ds.pendingAction || null;\nconst isActiveResponse = !!ds.isActiveResponse;\nconst responseType = ds.activeResponseType || null;  // 'yes' | 'no' | null\n\nlet ARA_ACTION = {\n  type: 'none',\n  payload: null,\n};\n\n// CASE 1: User is replying YES/NO to an existing pendingAction\nif (\n  pending &&\n  pending.type &&\n  pending.type !== 'none' &&\n  isActiveResponse &&\n  (responseType === 'yes' || responseType === 'no')\n) {\n  if (responseType === 'yes') {\n    // Confirm the pending action (create/delete/update/...)\n    ARA_ACTION = {\n      type: pending.type,\n      payload: pending.payload || {},\n    };\n  } else if (responseType === 'no') {\n    // Cancel the pending action\n    ARA_ACTION = {\n      type: pending.type + '_cancel',\n      payload: pending.payload || {},\n    };\n  }\n} else {\n  // CASE 2: Immediate actions that do NOT require confirmation\n\n  // Example: escalate to human\n  if (currentType === 'escalate') {\n    ARA_ACTION = {\n      type: 'escalate',\n      payload: currentPayload || {},\n    };\n  }\n\n  // üîπ NEW: direct profile updates (no YES/NO roundtrip)\n  else if (currentType === 'user_update_profile') {\n    ARA_ACTION = {\n      type: 'user_update_profile',\n      payload: currentPayload || {},\n    };\n  }\n}\n\n// CASE 3: User profile updates (ARA_ACTION from main agent)\n// If the main agent outputs ARA_ACTION.update_user_preferences directly\nconst rawOutput = $json.output || '';\nconst actionMatch = rawOutput.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\n\nif (actionMatch) {\n  try {\n    const parsedAction = JSON.parse(actionMatch[1]);\n\n    if (parsedAction.type === 'update_user_preferences') {\n      // Build payload ONLY with non-null fields\n      const payload = {};\n\n      if (\n        typeof parsedAction.preferred_name === 'string' &&\n        parsedAction.preferred_name.trim() !== ''\n      ) {\n        payload.preferred_name = parsedAction.preferred_name.trim();\n      }\n\n      if (\n        typeof parsedAction.preferred_language === 'string' &&\n        parsedAction.preferred_language.trim() !== ''\n      ) {\n        payload.preferred_language = parsedAction.preferred_language.trim();\n      }\n\n      // Only overwrite ARA_ACTION if we have something real to update\n      if (Object.keys(payload).length > 0) {\n        ARA_ACTION = {\n          type: 'update_user_preferences',\n          payload,\n        };\n      }\n      // else: no valid fields ‚Üí keep whatever ARA_ACTION was before\n    }\n  } catch (err) {\n    // ignore JSON parsing error, fall back to existing ARA_ACTION\n  }\n}\n\n\n// -----------------------------\n// SAFETY GUARDS (AILOOP PROTECT)\n// -----------------------------\n\n// 1) Whitelist allowed action types only\nconst allowedTypes = [\n  'none',\n  'reminder_create',\n  'reminder_delete',\n  'timezone_update',\n  'escalate',\n  'update_user_preferences',          // üîπ NEW\n\n  'reminder_create_cancel',\n  'reminder_delete_cancel',\n  'timezone_update_cancel',\n  'user_update_profile_cancel',   // optional future use\n];\n\nif (!allowedTypes.includes(ARA_ACTION.type)) {\n  ARA_ACTION = {\n    type: 'none',\n    payload: null,\n  };\n}\n\n// 2) Payload validation for specific actions\n\n// Reminder Create must have topic + suggested_time\nif (ARA_ACTION.type === 'reminder_create') {\n  const p = ARA_ACTION.payload || {};\n  const hasTopic =\n    typeof p.topic === 'string' && p.topic.trim().length > 0;\n  const hasTime =\n    typeof p.suggested_time === 'string' && p.suggested_time.trim().length > 0;\n\n  if (!hasTopic || !hasTime) {\n    // Invalid payload ‚Üí cancel action instead of firing broken data downstream\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Reminder Delete must have reminder_id\nif (ARA_ACTION.type === 'reminder_delete') {\n  const p = ARA_ACTION.payload || {};\n  const hasReminderId =\n    typeof p.reminder_id === 'string' && p.reminder_id.trim().length > 0;\n\n  if (!hasReminderId) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Timezone Update must have timezone + timezone_label\nif (ARA_ACTION.type === 'timezone_update') {\n  const p = ARA_ACTION.payload || {};\n  const hasTz =\n    typeof p.timezone === 'string' && p.timezone.trim().length > 0;\n  const hasLabel =\n    typeof p.timezone_label === 'string' && p.timezone_label.trim().length > 0;\n\n  if (!hasTz || !hasLabel) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Profile Update must have at least one field to update\nif (ARA_ACTION.type === 'user_update_profile') {\n  const p = ARA_ACTION.payload || {};\n  const updates = p.profile_updates || null;\n\n  const valid =\n    updates &&\n    typeof updates === 'object' &&\n    Object.keys(updates).length > 0;\n\n  if (!valid) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Preferences Update must have at least one field\nif (ARA_ACTION.type === 'update_user_preferences') {\n  const p = ARA_ACTION.payload || {};\n  const hasName = Object.prototype.hasOwnProperty.call(p, 'preferred_name');\n  const hasLang = Object.prototype.hasOwnProperty.call(p, 'preferred_language');\n\n  if (!hasName && !hasLang) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n\n\n// (We let 'escalate' and *_cancel pass even with minimal payload)\n\n// -----------------------------\n// Text back to user = assistant_response from previous node\n// -----------------------------\nconst final_reply = ($json.assistant_response || '').trim();\n\n// Safely pull the latest conversation row so we can attach ids\nconst latestItems = $items('Get Latest Conversation');\nconst latest = latestItems.length ? latestItems[0].json : {};\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Ensure these four are present from Get Latest Conversation\n  id: latest.id ?? $json.id,\n  user_id: latest.user_id ?? $json.user_id,\n  telegram_chat_id: latest.telegram_chat_id ?? $json.telegram_chat_id,\n  message_id: latest.message_id ?? $json.message_id,\n\n  ARA_ACTION,\n  final_reply,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        64,
        1504
      ],
      "id": "ab4f820c-ced5-4ff7-8117-08744f7d991a",
      "name": "Route Confirmed Actions"
    },
    {
      "parameters": {
        "tableId": "reminders",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation').item.json.user_id }}"
            },
            {
              "fieldId": "reminder_text",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.topic }}"
            },
            {
              "fieldId": "reminder_time",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.suggested_time }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "{{ $now }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        912,
        1264
      ],
      "id": "62c667f6-fc0c-462b-9741-a91a7a453040",
      "name": "Create Reminder"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_create",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "0d51000f-6a84-4eb8-8e74-e2190366c0dd"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Create"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7effae48-3c8b-445c-bdaf-8043843459f1",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f18fc6df-6c26-4714-ba28-fa4560fcec67",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "escalate",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Escalate"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "602c304b-fae9-4ee9-aea5-3622eea25845",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "timezone_update",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update timezone"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "959a4996-035d-4e07-951b-9fe19d261d98",
                    "leftValue": "={{ $json[\"ARA_ACTION\"].type }}",
                    "rightValue": "update_user_preferences",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update User Profile"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        416,
        1472
      ],
      "id": "0a52d3d7-25cd-4ada-966e-f74670c35301",
      "name": "Route Actions Switch"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "reminders",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.pending_action_payload.reminder_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        912,
        1456
      ],
      "id": "0912a738-2aa2-446b-b383-661bf8bfccff",
      "name": "Delete Reminder"
    },
    {
      "parameters": {
        "jsCode": "// GET RELEVANT MEMORIES\n// This node reads all rows from \"Get User Memories\",\n// scores them by importance + recency, and returns\n// only the top N memories to the next node.\n\n// Make sure this node is set to:\n// - Mode: \"Run Once for All Items\"\n// - Language: JavaScript\n\n// 1) Safely get all items from \"Get User Memories\"\nlet memoryItems;\ntry {\n  memoryItems = $items('Get User Memories', 0, 0);\n} catch (e) {\n  // If node name is wrong or no items, fail gracefully\n  return [];\n}\n\n// If no memories, just return an empty list\nif (!Array.isArray(memoryItems) || memoryItems.length === 0) {\n  return [];\n}\n\nconst now = new Date();\n\n// 2) Convert & score each memory\nconst scoredMemories = memoryItems\n  .map(item => item.json)\n  .map(m => {\n    // Importance score (0‚Äì1, default 0.5)\n    const importance =\n      typeof m.importance_score === 'number'\n        ? m.importance_score\n        : 0.5;\n\n    // Recency score from temporal_context (if parseable as date)\n    let recencyScore = 0;\n    if (m.temporal_context) {\n      const parsed = Date.parse(m.temporal_context);\n      if (!isNaN(parsed)) {\n        const ageMs = now - new Date(parsed);\n        const ageDays = ageMs / (1000 * 60 * 60 * 24);\n        // Newer memories = higher score (ageDays small)\n        // Cap to avoid crazy values\n        const cappedAge = Math.min(Math.max(ageDays, -7), 365);\n        recencyScore = -cappedAge; // smaller age => higher score\n      }\n    }\n\n    // Memory type boost (preferences & relationships are more ‚Äúcore‚Äù)\n    const typeBoost =\n      m.memory_type === 'preference' || m.memory_type === 'relationship'\n        ? 1\n        : 0;\n\n    // Topic boost (reminders, customers, etc)\n    let topicBoost = 0;\n    try {\n      if (typeof m.entities === 'string') {\n        // entities is JSON string in your table\n        const ent = JSON.parse(m.entities);\n        const topics = Array.isArray(ent.topics) ? ent.topics.join(' ').toLowerCase() : '';\n        if (topics.includes('reminder')) topicBoost += 0.5;\n        if (topics.includes('customer')) topicBoost += 0.3;\n      }\n    } catch (e) {\n      // Ignore parsing errors, keep topicBoost = 0\n    }\n\n    // Final score (tweak weights as you like)\n    const score =\n      importance * 2 +      // importance is strong signal\n      typeBoost +           // preferences/relationships are sticky\n      topicBoost +          // domain-specific boost\n      recencyScore * 0.02;  // mild recency influence\n\n    return {\n      ...m,\n      _score: score,\n    };\n  });\n\n// 3) Sort by score (desc), then by created_at (desc)\nscoredMemories.sort((a, b) => {\n  if (b._score !== a._score) return b._score - a._score;\n  const ad = new Date(a.created_at || 0);\n  const bd = new Date(b.created_at || 0);\n  return bd - ad;\n});\n\n// 4) Limit how many memories to send forward\nconst MAX_MEMORIES = 20;\nconst selected = scoredMemories.slice(0, MAX_MEMORIES);\n\n// 5) Return in n8n format\nreturn selected.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2576,
        2080
      ],
      "id": "9b6de09b-981d-4d16-a818-1ab8fc412762",
      "name": "Get Relevant Memories"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ara_brain_rules",
        "limit": 100,
        "filters": {
          "conditions": [
            {
              "keyName": "is_active",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2128,
        1888
      ],
      "id": "2c2f1d83-c351-440c-b666-cdb535d9b89a",
      "name": "Get ARA Brain",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Format ARA brain rows into a single text block\n\n// Get all rows from previous node\nconst items = $input.all();\nconst rows = items.map(i => i.json);\n\n// Group by category\nconst byCategory = {};\n\nfor (const row of rows) {\n  const category = row.category || 'General';\n  const sub = row.subcategory || '';\n  const content = (row.content || '').trim();\n\n  if (!content) continue;\n\n  if (!byCategory[category]) {\n    byCategory[category] = [];\n  }\n\n  const label = sub ? `(${sub})` : '';\n  byCategory[category].push(`- ${label ? label + ' ' : ''}${content}`);\n}\n\n// Build the final brain text\nlet brainText = '';\n\nfor (const [category, lines] of Object.entries(byCategory)) {\n  brainText += `\\n\\n[${category.toUpperCase()}]\\n` + lines.join('\\n');\n}\n\nbrainText = brainText.trim();\n\n// Return a single item with brain_text\nreturn [\n  {\n    json: {\n      brain_text: brainText,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1904,
        1888
      ],
      "id": "900fef36-5db8-4c76-bf1f-bca066425b66",
      "name": "Format Brain"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.home_timezone }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "e7b487c6-4190-43b3-a402-4d93f58f1f90"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "No home time"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a14c596f-8821-4f43-8884-fc07dd2f95b4",
                    "leftValue": "",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "default"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -4144,
        1456
      ],
      "id": "e4760d14-714e-4ea1-ae15-661f2478cc6d",
      "name": "Check Time Zone"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3680,
        848
      ],
      "id": "0c216c47-6293-419e-9bbe-0f00b16ebe54",
      "name": "Get Previous Conversation1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Get all input items\nconst items = $input.all();\n\n// Sort items by created_at in descending order (most recent first)\nitems.sort((a, b) => new Date(b.json.created_at) - new Date(a.json.created_at));\n\n// Take the first 1 item (latest 1)\nconst latestOne = items.slice(0, 1);\n\nreturn latestOne;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3472,
        560
      ],
      "id": "c2f51ad8-c4f3-4f7b-b84b-032d5870588e",
      "name": "Sort1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ara_brain_rules",
        "limit": 100,
        "filters": {
          "conditions": [
            {
              "keyName": "is_active",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2352,
        560
      ],
      "id": "f1105f3b-6887-4cf6-a615-7c789fbf9c68",
      "name": "Get ARA Brain1",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Format ARA brain rows into a single text block\n\n// Get all rows from previous node\nconst items = $input.all();\nconst rows = items.map(i => i.json);\n\n// Group by category\nconst byCategory = {};\n\nfor (const row of rows) {\n  const category = row.category || 'General';\n  const sub = row.subcategory || '';\n  const content = (row.content || '').trim();\n\n  if (!content) continue;\n\n  if (!byCategory[category]) {\n    byCategory[category] = [];\n  }\n\n  const label = sub ? `(${sub})` : '';\n  byCategory[category].push(`- ${label ? label + ' ' : ''}${content}`);\n}\n\n// Build the final brain text\nlet brainText = '';\n\nfor (const [category, lines] of Object.entries(byCategory)) {\n  brainText += `\\n\\n[${category.toUpperCase()}]\\n` + lines.join('\\n');\n}\n\nbrainText = brainText.trim();\n\n// Return a single item with brain_text\nreturn [\n  {\n    json: {\n      brain_text: brainText,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2128,
        560
      ],
      "id": "d1a5d3e6-f080-44fd-b71d-6de81e20473c",
      "name": "Format Brain1"
    },
    {
      "parameters": {
        "jsCode": "// FORMAT CONTEXT WITH MEMORY\n// This node prepares \"ara_context\" for ARA Main Agent.\n\n// ============= STEP 1: ARA BRAIN =============\nlet araBrain = '';\ntry {\n  const brainNode = $('Format Brain1').first();\n  if (brainNode && brainNode.json && brainNode.json.brain_text) {\n    araBrain = brainNode.json.brain_text;\n  }\n} catch (e) {\n  console.log('No ARA brain available yet');\n}\n\n// ============= STEP 1.5: LOAD CONVERSATIONS =============\nconst convItems = $('Wait for Memory & Session1').all() || [];\n\n// Flatten and sort oldest ‚Üí newest\nlet conversations = convItems\n  .map(i => i.json || i) // adjust if your data is under i.json\n  .filter(c => c && c.created_at)\n  .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));\n\nconst MAX_DETAILED = 12;\nconst detailedConversations = conversations.slice(-MAX_DETAILED);\nconst olderConversations = conversations.slice(\n  0,\n  Math.max(0, conversations.length - MAX_DETAILED)\n);\n\n// Build compact summaries for older convos\nconst olderSummaries = olderConversations.map(c => {\n  const userMsg = c.user_message || '';\n  const assistantMsg = c.assistant_response || '';\n  const summaryField = c.session_summary || c.context_summary || null;\n\n  return {\n    id: c.id,\n    session_id: c.session_id || null,\n    created_at: c.created_at,\n    user_message_preview: userMsg.slice(0, 120),\n    assistant_response_summary: summaryField || assistantMsg.slice(0, 160)\n  };\n});\n\n// IMPORTANT: latest conversation row (could be user OR assistant)\nconst lastConversation =\n  conversations.length > 0 ? conversations[conversations.length - 1] : null;\n\n// IMPORTANT: latest assistant message with non-empty response\nconst lastAssistant =\n  [...conversations]\n    .reverse()\n    .find(c => (c.assistant_response || '').trim() !== '') || null;\n\n// ============= STEP 2: LOAD USER + MEMORIES =============\nlet userData = {};\ntry {\n  const userNode = $('Get User1').first().json; // adjust node name if needed\n  userData = userNode || {};\n} catch (e) {\n  userData = {};\n}\n\nlet userMemories = [];\ntry {\n  const memNode = $('Get User Memories1').first().json;\n  userMemories = memNode.data || memNode.memories || [];\n} catch (e) {\n  userMemories = [];\n}\n\nconst importantMemories = userMemories.filter(m => {\n  const score = typeof m.importance_score === 'number' ? m.importance_score : 1;\n  return score >= 0.7;\n});\n\n// ============= STEP 3: UNDERSTAND CURRENT MESSAGE =============\nconst current = $json || {};\nconst currentText =\n  current.user_message ||\n  current.message ||\n  current.text ||\n  '';\nconst currentLower = (currentText || '').trim().toLowerCase();\n\n// ============= STEP 4: PENDING ACTION & YES/NO DETECTION =============\n\n// Helper: simple yes/no detection for short replies\nfunction isShortYesNo(text) {\n  if (!text) return null;\n  const t = text.trim().toLowerCase();\n  if (t.length === 0 || t.length > 40) return null;\n\n  const YES = [\n    'yes','ya','yaaa','yup','ok','okay','okey','ok lah','okla','boleh',\n    'boleh je','proceed','confirm','set kan','buat','buat je','jom','ye'\n  ];\n  const NO = [\n    'no','tak','tak nak','tidak','jangan','nope','later','nanti',\n    'bukan sekarang','skip','tak payah'\n  ];\n\n  if (YES.includes(t)) return 'yes';\n  if (NO.includes(t)) return 'no';\n  return null;\n}\n\n// Helper: time guard for pending actions\nfunction isWithinHours(dateStr, hours) {\n  if (!dateStr) return false;\n  const then = new Date(dateStr).getTime();\n  const now = Date.now();\n  const diffH = (now - then) / (1000 * 60 * 60);\n  return diffH <= hours;\n}\n\nlet isActiveResponse = false;\nlet activeResponseType = null;   // 'yes' | 'no'\nlet questionType = 'general';\nlet offerContext = null;\nlet pendingAction = null;\n\n// ---- Build pendingAction from DB fields, with ARA_PENDING as fallback ----\nlet lastAssistantText = lastAssistant ? (lastAssistant.assistant_response || '') : '';\n\nif (lastAssistant) {\n  // 1) Prefer structured fields from the conversations table\n  if (\n    lastAssistant.pending_action_type &&\n    lastAssistant.pending_action_type !== 'none'\n  ) {\n    pendingAction = {\n      type: lastAssistant.pending_action_type,\n      payload: lastAssistant.pending_action_payload || null,\n      resolved: !!lastAssistant.pending_action_resolved,\n      created_at: lastAssistant.created_at,\n    };\n  } else if (lastAssistantText) {\n    // 2) Backwards-compatible support for old ARA_PENDING footer\n    const match = lastAssistantText.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})\\s*$/);\n    if (match) {\n      try {\n        const pa = JSON.parse(match[1]);\n        if (pa.type && pa.type !== 'none') {\n          pendingAction = {\n            type: pa.type,\n            payload: pa.payload || null,\n            resolved: false,\n            created_at: lastAssistant.created_at,\n          };\n        }\n      } catch (e) {\n        // ignore parse errors\n      }\n    }\n  }\n}\n\n// YES/NO on current message\nconst shortYesNo = isShortYesNo(currentText);\n\n\n// 1) If we have a pending action and user sends short yes/no recently\nif (\n  pendingAction &&\n  pendingAction.type &&\n  pendingAction.type !== 'none' &&\n  isWithinHours(pendingAction.created_at, 48) &&\n  shortYesNo\n) {\n  isActiveResponse = true;\n  activeResponseType = shortYesNo;\n  questionType = 'offer';\n  offerContext = pendingAction.type;\n}\n\n// 2) Fallback: classify last assistant message question type (for general yes/no replies)\nif (!isActiveResponse && lastAssistantText) {\n  const lastText = lastAssistantText.toLowerCase();\n\n  const hasQuestionMark = lastText.includes('?');\n  const hasOfferPattern = /would you like|nak tak|mahu tak|do you want|shall i|should i|may i|can i help|if you‚Äôd like|kalau nak/i.test(lastText);\n  const hasClarificationPattern = /could you clarify|apa yang dimaksud|what do you mean|which one do you mean|yang mana satu/i.test(lastText);\n  const hasConfirmationPattern = /is this correct|is that right|betul tak|setuju tak|confirm/i.test(lastText);\n  const hasChoicePattern = /\\bor\\b|atau\\b/i.test(lastText);\n\n  if (hasOfferPattern) questionType = 'offer';\n  else if (hasClarificationPattern) questionType = 'clarification';\n  else if (hasConfirmationPattern) questionType = 'confirmation';\n  else if (hasChoicePattern) questionType = 'choice';\n  else if (hasQuestionMark) questionType = 'general';\n\n  const yn = shortYesNo;\n  if (yn && (hasOfferPattern || hasConfirmationPattern || hasChoicePattern)) {\n    isActiveResponse = true;\n    activeResponseType = yn;\n\n    if (hasOfferPattern) offerContext = 'offer';\n    else if (hasConfirmationPattern) offerContext = 'confirmation';\n    else if (hasChoicePattern) offerContext = 'choice';\n  }\n}\n\n// ============= STEP 5: BUILD ARA CONTEXT =============\nconst araContext = {\n  user: {\n  id: userData.id || null,\n  name: userData.name || userData.full_name || null,\n  phone: userData.phone || userData.telegram_id || null,\n  features_enabled: userData.features_enabled || null,\n\n  // Main timezone ARA should use\n  timezone:\n    userData.current_timezone ||\n    userData.home_timezone ||\n    userData.timezone ||\n    'Asia/Kuala_Lumpur',\n\n  // Extra fields so the main agent sees both explicitly\n  home_timezone: userData.home_timezone || null,\n  current_timezone: userData.current_timezone || null,\n},\n\n  current_message: {\n    text: currentText,\n    language_hint: null\n  },\n  history: {\n    detailed: detailedConversations.map(c => ({\n      created_at: c.created_at,\n      role: c.role || null,\n      user_message: c.user_message || '',\n      assistant_response: c.assistant_response || '',\n      session_id: c.session_id || null\n    })),\n    older_summaries: olderSummaries\n  },\n  memories: {\n    important: importantMemories,\n    all: userMemories\n  },\n  last_assistant_message: lastAssistant\n    ? {\n        created_at: lastAssistant.created_at,\n        text: lastAssistant.assistant_response || ''\n      }\n    : null,\n  dialogue_state: {\n    isActiveResponse,\n    activeResponseType,\n    questionType,\n    offerContext,\n    pendingAction\n  }\n};\n\nreturn [\n  {\n    json: {\n      ara_context: araContext,\n      // keep original fields\n      ...current\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1904,
        560
      ],
      "id": "3d5e4299-37ec-449f-a2f7-534b773924aa",
      "name": "Format Context with Memory1"
    },
    {
      "parameters": {
        "url": "https://jjeqmysluzsohwjpyvip.supabase.co/rest/v1/conversations",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ 'eq.' + $json.ara_context.user.id }}"
            },
            {
              "name": "order",
              "value": "created_at.desc"
            },
            {
              "name": "limit",
              "value": "1"
            },
            {
              "name": "select",
              "value": "*"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1680,
        560
      ],
      "id": "9e6bc4e2-cc7d-423f-bef9-2e5893cb0749",
      "name": "Get Latest Conversation1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9ea260fe-5f67-4c13-85db-a8aff7ab65be",
                    "leftValue": "={{ (Date.now() - new Date($json.created_at).getTime()) / 60000 }}",
                    "rightValue": 30,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Within 30 Mins"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.session_id }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "13a1d046-89ee-4896-b133-7081657d0eec"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Never talked"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3248,
        448
      ],
      "id": "a2f546a1-1fae-4cb4-a699-5b9127c060a6",
      "name": "Session Manager1"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $item(0).$node[\"Get User1\"].json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ Date.now() + '_' + Math.floor(Math.random() * 1000000) }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3008,
        704
      ],
      "id": "11354411-cc84-4e59-819a-a0c617bc7548",
      "name": "Create New Session1",
      "alwaysOutputData": true,
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get User1').item.json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}\n"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}\n"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3024,
        368
      ],
      "id": "a3dfcb92-8997-4d7c-ba79-399e39f0ae96",
      "name": "Continue Session1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "limit": 100,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2800,
        464
      ],
      "id": "ba3d36c9-d980-4aae-aaac-5fb603137f08",
      "name": "Fetch Session History2",
      "alwaysOutputData": true,
      "notesInFlow": false
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ai_memories",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Get User1').item.json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3024,
        1072
      ],
      "id": "162eaa25-3bac-4d03-9128-35eb6075e45d",
      "name": "Get User Memories1",
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2576,
        560
      ],
      "id": "9eb5966c-65ef-4f74-b6bb-fd83eb32a05f",
      "name": "Wait for Memory & Session1"
    },
    {
      "parameters": {
        "jsCode": "// GET RELEVANT MEMORIES\n// This node reads all rows from \"Get User Memories\",\n// scores them by importance + recency, and returns\n// only the top N memories to the next node.\n\n// Make sure this node is set to:\n// - Mode: \"Run Once for All Items\"\n// - Language: JavaScript\n\n// 1) Safely get all items from \"Get User Memories\"\nlet memoryItems;\ntry {\n  memoryItems = $items('Get User Memories1', 0, 0);\n} catch (e) {\n  // If node name is wrong or no items, fail gracefully\n  return [];\n}\n\n// If no memories, just return an empty list\nif (!Array.isArray(memoryItems) || memoryItems.length === 0) {\n  return [];\n}\n\nconst now = new Date();\n\n// 2) Convert & score each memory\nconst scoredMemories = memoryItems\n  .map(item => item.json)\n  .map(m => {\n    // Importance score (0‚Äì1, default 0.5)\n    const importance =\n      typeof m.importance_score === 'number'\n        ? m.importance_score\n        : 0.5;\n\n    // Recency score from temporal_context (if parseable as date)\n    let recencyScore = 0;\n    if (m.temporal_context) {\n      const parsed = Date.parse(m.temporal_context);\n      if (!isNaN(parsed)) {\n        const ageMs = now - new Date(parsed);\n        const ageDays = ageMs / (1000 * 60 * 60 * 24);\n        // Newer memories = higher score (ageDays small)\n        // Cap to avoid crazy values\n        const cappedAge = Math.min(Math.max(ageDays, -7), 365);\n        recencyScore = -cappedAge; // smaller age => higher score\n      }\n    }\n\n    // Memory type boost (preferences & relationships are more ‚Äúcore‚Äù)\n    const typeBoost =\n      m.memory_type === 'preference' || m.memory_type === 'relationship'\n        ? 1\n        : 0;\n\n    // Topic boost (reminders, customers, etc)\n    let topicBoost = 0;\n    try {\n      if (typeof m.entities === 'string') {\n        // entities is JSON string in your table\n        const ent = JSON.parse(m.entities);\n        const topics = Array.isArray(ent.topics) ? ent.topics.join(' ').toLowerCase() : '';\n        if (topics.includes('reminder')) topicBoost += 0.5;\n        if (topics.includes('customer')) topicBoost += 0.3;\n      }\n    } catch (e) {\n      // Ignore parsing errors, keep topicBoost = 0\n    }\n\n    // Final score (tweak weights as you like)\n    const score =\n      importance * 2 +      // importance is strong signal\n      typeBoost +           // preferences/relationships are sticky\n      topicBoost +          // domain-specific boost\n      recencyScore * 0.02;  // mild recency influence\n\n    return {\n      ...m,\n      _score: score,\n    };\n  });\n\n// 3) Sort by score (desc), then by created_at (desc)\nscoredMemories.sort((a, b) => {\n  if (b._score !== a._score) return b._score - a._score;\n  const ad = new Date(a.created_at || 0);\n  const bd = new Date(b.created_at || 0);\n  return bd - ad;\n});\n\n// 4) Limit how many memories to send forward\nconst MAX_MEMORIES = 20;\nconst selected = scoredMemories.slice(0, MAX_MEMORIES);\n\n// 5) Return in n8n format\nreturn selected.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2800,
        1072
      ],
      "id": "8a005201-5c97-4711-befd-01e4a1468aaf",
      "name": "Get Relevant Memories1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -336,
        896
      ],
      "id": "698e67aa-b75a-413f-8afe-eef49ce90182",
      "name": "OpenAI Model1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify({\n  latest_user_message: $('Get Latest Conversation1').item.json.user_message || $json.Body || $json.body || '',\n  assistant_response: $('Send Reply1').item.json.body || '',\n  user_context: $('Format Context with Memory1').item.json.ara_context.user || {}\n}) }}",
        "options": {
          "systemMessage": "You are ARA‚Äôs Memory Extraction Agent.\n\nYour ONLY job is to decide what is worth saving into long-term memory for this user, based on the LATEST exchange.\n\nINPUT FORMAT\n\nYou will receive a JSON object with:\n\nlatest_user_message: the most recent WhatsApp message from the user\n\nassistant_response: the reply that ARA just sent to the user\n\nuser_context: basic info about the user (id, phone, timezone, etc.)\n\nCRITICAL CONSTRAINTS\n\nYou MUST ONLY consider:\n\nlatest_user_message\n\nassistant_response\n\nYou MUST NOT scan or ‚Äúimagine‚Äù earlier history, even if you see anything that looks like history or summaries in the input.\n\nTreat this as a single turn: one user message + one assistant reply.\n\nIf you are not clearly sure a fact will help in future conversations, DO NOT save it.\n\nIf there is nothing worth remembering, return an empty JSON array: [].\n\nGOAL\n\nDecide whether this turn contains anything that is worth remembering LATER to help this user:\n\npersonal facts\n\nstable preferences\n\nrelationships\n\nongoing tasks or recurring patterns\n\nbusiness / life context\n\nENTITY & WORLD-KNOWLEDGE SAFETY RULES (VERY IMPORTANT)\n\nThese rules are to prevent wrong ‚Äúpeople‚Äù and messy memories.\n\nPlaces are NEVER people\n\nTreat these as places, not persons, for example:\n\nCountries: Malaysia, Singapore, Indonesia, Thailand, Vietnam, UK, USA, Saudi Arabia, etc.\n\nMalaysian cities / regions: Kuala Lumpur, KL, Selangor, Penang, Johor Bahru, Ipoh, Melaka, Sabah, Sarawak, Kuching, Kota Kinabalu, etc.\n\nHoly places: Makkah/Mecca, Madinah/Medina, Kaabah, Masjidil Haram, Masjid Nabawi, etc.\n\nThey must NOT appear inside entities.people. They may appear in entities.topics or only inside memory_value.\n\nOrganisations, banks, and programmes are NEVER people\n\nAnything that looks like a company, bank, agency, or programme must NOT go into entities.people. Examples:\n\nNames containing: ‚ÄúBank‚Äù, ‚ÄúBerhad‚Äù, ‚ÄúBhd‚Äù, ‚ÄúSdn Bhd‚Äù, ‚ÄúCorp‚Äù, ‚ÄúCompany‚Äù, ‚ÄúUniversity‚Äù, ‚ÄúCollege‚Äù.\n\nKnown Malaysian orgs: MARA, AIM (Amanah Ikhtiar Malaysia), MRANTI, SME Bank, Maybank, CIMB, Bank Rakyat, Petronas, Tenaga Nasional, etc.\n\nPut them in entities.topics if relevant, or leave them only in memory_value.\n\nApps and tools are NEVER people\n\nWhatsApp, Telegram, Facebook, Instagram, TikTok, Google, YouTube, Shopee, Lazada, Grab, Foodpanda, ARA, etc. are tools/apps, not persons.\n\nThey must NOT be inside entities.people.\n\nGeneric roles are allowed but should be simple\n\nPhrases like ‚Äúmy tailor‚Äù, ‚Äúmy designer‚Äù, ‚Äúmy supplier‚Äù, ‚Äúmy mentor‚Äù can appear in memory_value.\nIn entities.people you may use a simple label like \"tailor\" or \"mentor\" if it clearly helps; never invent a personal name that wasn‚Äôt given.\n\nWhen in doubt about person vs place/org ‚Üí DO NOT mark as a person\n\nIf you‚Äôre not clearly sure something is a human name, leave it out of entities.people.\nIt is better to have fewer people than wrong people.\n\nWHAT TO EXTRACT\n\nExtract only information that:\n\nwill still matter in future conversations (hours, days, weeks later), AND\n\nhelps ARA be more helpful or personal.\n\nFocus on:\n\nPERSONAL BACKGROUND\n\nEducation, origin, profession, roles, life events.\n\nExample: ‚ÄúI‚Äôm from Kedah‚Äù, ‚ÄúI run a printing business‚Äù, ‚ÄúI‚Äôm a teacher‚Äù, ‚ÄúI just moved to London.‚Äù\n\nPREFERENCES & OPINIONS\n\nColors, products, styles, routines, habits, food, communication style, language preference, tools they like to use.\n\nExample: ‚ÄúCustomer Ali wants the color green‚Äù, ‚ÄúI prefer English‚Äù, ‚ÄúI like voice notes‚Äù, ‚ÄúI hate long paragraphs‚Äù.\n\nRELATIONSHIPS & ROLES\n\nWho is who: spouse, children, business partners, customers, suppliers, mentors, staff, etc.\n\nExample: ‚ÄúAishah is my wife‚Äù, ‚ÄúAli is my customer‚Äù, ‚ÄúSiti is the event planner for my wedding‚Äù.\n\nTASK PATTERNS & ONGOING CONTEXT\n\nRecurring routines or ongoing projects, not one-off noise.\n\nExample:\n\n‚ÄúEvery Monday I have team meeting at 9am.‚Äù\n\n‚ÄúI‚Äôm working on launching my new cafe in March.‚Äù\n\n‚ÄúI‚Äôm using ARA mainly to manage my business reminders.‚Äù\n\nIMPORTANT REMINDER-LIKE FACTS\n\nOnly if they reveal something stable or recurring.\n\nExample:\n\n‚ÄúI always call my mum every Sunday night.‚Äù\n\n‚ÄúMy rental is due on the 25th every month.‚Äù\n\nOne-off reminders that are already fully handled by the reminder system usually do NOT need to be saved as long-term memory.\n\nWHAT NOT TO SAVE\n\nDO NOT save:\n\nGreetings or filler:\n\n‚ÄúHi‚Äù, ‚ÄúHello‚Äù, ‚ÄúOK‚Äù, ‚ÄúThanks‚Äù, ‚ÄúBetul‚Äù, ‚ÄúDone‚Äù, ‚ÄúYes‚Äù, ‚ÄúNo‚Äù, etc.\n\nPure emotion with no concrete fact:\n\n‚ÄúYou are slow‚Äù, ‚ÄúI‚Äôm angry‚Äù, ‚ÄúService not good‚Äù, ‚ÄúI‚Äôm stressed‚Äù.\n\nTemporary confusion:\n\n‚ÄúI don‚Äôt know‚Äù, ‚ÄúWhat?‚Äù, ‚ÄúWhere is my reminder?‚Äù, ‚ÄúWhy you so slow?‚Äù\n\nTechnical/system-like text, IDs, or internal ARA messages.\n\nDetails that only matter for a single reminder and add no long-term value.\n\nShort, vague, or ambiguous statements that you cannot interpret safely.\n\nAnything that is not clearly about:\n\nthe user,\n\ntheir contacts/relationships,\n\ntheir stable preferences,\n\ntheir ongoing business or life context.\n\nIf unsure, prefer to skip the memory.\n\nMEMORY TYPES\n\nUse these types:\n\n\"preference\" ‚Üí stable likes/dislikes, style, language, choices.\n\n\"relationship\" ‚Üí who people are and how they are connected to the user.\n\n\"context\" ‚Üí facts about their situation, work, business, or long-term goals.\n\n\"interaction\" ‚Üí specific actions, decisions, or promises that may matter later (e.g. ‚Äúuser agreed to try weekly planning with ARA‚Äù).\n\nIf you cannot decide a suitable type with reasonable confidence, DO NOT create the memory.\n\nIMPORTANCE & LIMITS\n\nimportance_score must be between 0.7 and 1.0.\n\nUse 0.9‚Äì1.0 only for very important, identity-level facts (family, core business, strong preferences).\n\nUse 0.7‚Äì0.8 for useful but lighter context.\n\nIf a fact feels minor or very temporary, do NOT save it at all.\n\nTry not to create more than 3 memories per turn. Pick the most useful ones.\n\nSCHEMA\n\nReturn a JSON array. Each memory object MUST have:\n\nmemory_type: \"preference\" | \"relationship\" | \"context\" | \"interaction\"\n\nmemory_key: a short snake_case key you invent (e.g. \"ali_color_preference\")\n\nmemory_value: the full fact in natural language\n\nimportance_score: 0.7‚Äì1.0\n\nentities:\n\n\"people\": [\"list\", \"of\", \"names\"] (real people or clear roles only)\n\n\"topics\": [\"keywords\", \"like\", \"reminder\", \"color\", \"meeting\"]\n\ntemporal_context: a simple string like \"today\" or an ISO date if explicitly mentioned.\n\nRESOLVING PRONOUNS\n\nIf the user says ‚Äúshe‚Äù, ‚Äúhe‚Äù, ‚Äúthat color‚Äù, etc., use ONLY the information in latest_user_message + assistant_response to interpret it.\n\nIf you cannot resolve it clearly to a specific person or thing, DO NOT save the memory.\n\nDUPLICATES\n\nIf the user repeats something you already know (for example: ‚ÄúAli likes green‚Äù) but adds no new detail, you may:\n\neither skip it, OR\n\ninclude it again with the same memory_value (the system will de-duplicate later).\n\nDO NOT assume something is updated unless the message clearly says the old info has changed.\n\nOUTPUT FORMAT\n\nOutput MUST be a valid JSON array.\n\nDO NOT wrap the JSON in ``` or any markdown.\n\nDO NOT include explanations, comments, or extra text.\n\nIf there is nothing useful to save, return exactly: []."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        -416,
        656
      ],
      "id": "397cdd86-85ea-429e-a108-2184ece859dd",
      "name": "Extract Memories1",
      "executeOnce": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{ $('Format Context with Memory1').item.json.is_continuing_session }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              },
              "id": "74ef4d44-2a94-431f-a49c-b470fc2a0996"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        0,
        1072
      ],
      "id": "70726352-dd28-4200-9ac5-2b5f4667ab1b",
      "name": "Session Ended?1"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Memories v2 - simpler, cleaner, per-turn\n// Input: array of validated memory objects (from Validate Memories)\n// Output: array of rows ready for ai_memories table\n\nconst input = $input.all().map(i => i.json);\nlet memories = input;\n\n// If someone wired it differently and we got a single array\nif (input.length === 1 && Array.isArray(input[0])) {\n  memories = input[0];\n}\n\nif (!memories || memories.length === 0) {\n  console.log('Prepare Memories: no memories to process');\n  return [];\n}\n\n// ===== Get user context =====\nlet userId = null;\ntry {\n  const userNode = $('Get User1').first();\n  if (userNode && userNode.json && userNode.json.id) {\n    userId = userNode.json.id;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get user ID', e);\n}\n\nif (!userId) {\n  console.log('Prepare Memories: missing user_id, aborting');\n  return [];\n}\n\n// ===== Get existing memories for this user =====\nlet existing = [];\ntry {\n  const rows = $('Get User Memories1').all() || [];\n  existing = rows\n    .filter(r => r.json && r.json.memory_value)\n    .map(r => r.json);\n} catch (e) {\n  console.log('Prepare Memories: could not get existing memories', e);\n}\n\n// Build quick lookup structures\nconst existingByKey = {};\nconst existingByValue = new Map();\n\nexisting.forEach(mem => {\n  const key = (mem.memory_key || '').toLowerCase();\n  if (key) existingByKey[key] = mem;\n\n  const val = (mem.memory_value || '').toLowerCase().trim();\n  if (val) existingByValue.set(val, mem);\n});\n\n// ===== Helper: normalize base key =====\nconst slugify = (text) => {\n  return text\n    .toString()\n    .toLowerCase()\n    .normalize('NFKD')\n    .replace(/[^a-z0-9]+/g, '_')\n    .replace(/^_+|_+$/g, '');\n};\n\n// ===== Helper: generate unique key with versions =====\nconst versionCache = {}; // baseKey -> highest version\n\n// Initialize versionCache from existing keys\nObject.keys(existingByKey).forEach(k => {\n  const match = k.match(/^(.*)_v(\\d+)$/);\n  if (match) {\n    const base = match[1];\n    const v = parseInt(match[2], 10);\n    if (!versionCache[base] || v > versionCache[base]) {\n      versionCache[base] = v;\n    }\n  }\n});\n\nconst generateKey = (mem, index) => {\n  // Start from provided key if any\n  let base = mem.memory_key\n    ? slugify(mem.memory_key)\n    : slugify(mem.memory_value || `memory_${index}`);\n\n  // Attach first person if available\n  if (mem.entities && mem.entities.people && mem.entities.people.length > 0) {\n    const person = slugify(mem.entities.people[0]);\n    if (person && !base.includes(person)) {\n      base = `${person}_${base}`;\n    }\n  }\n\n  // Strip existing version suffix\n  base = base.replace(/_v\\d+$/, '');\n\n  const type = mem.memory_type || 'context';\n\n  if (type === 'preference' || type === 'context') {\n    // Versioned keys\n    const current = versionCache[base] || 0;\n    const next = current + 1;\n    versionCache[base] = next;\n    return `${base}_v${next}`;\n  }\n\n  if (type === 'relationship') {\n    // Relationship can be stable per session\n    const now = Date.now();\n    return `${base}_rel_${now}`;\n  }\n\n  if (type === 'interaction') {\n    const now = Date.now();\n    return `${base}_int_${now}`;\n  }\n\n  // Fallback\n  const now = Date.now();\n  return `${base}_${type}_${now}`;\n};\n\n// ===== Very simple similarity check (exact / near exact text) =====\nconst isDuplicateByValue = (value) => {\n  if (!value) return false;\n  const valLower = value.toLowerCase().trim();\n  if (existingByValue.has(valLower)) return true;\n  return false;\n};\n\n// ===== Session & timestamps =====\nlet sessionId = null;\ntry {\n  const ctx = $('Format Context with Memory1').first();\n  if (ctx && ctx.json && ctx.json.ara_context && ctx.json.ara_context.history) {\n    sessionId = ctx.json.ara_context.history.detailed?.[0]?.session_id || null;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get session_id from context');\n}\n\nif (!sessionId) {\n  // Fallback session id\n  sessionId = `${Date.now()}_${Math.floor(Math.random() * 100000)}`;\n}\n\nconst nowIso = new Date().toISOString();\n\n// ===== Process memories =====\nconst prepared = [];\n\nmemories.forEach((mem, index) => {\n  if (!mem || !mem.memory_value) return;\n\n  // Skip if same value already exists\n  if (isDuplicateByValue(mem.memory_value)) {\n    console.log('Prepare Memories: skip duplicate by value:', mem.memory_value.substring(0, 60));\n    return;\n  }\n\n  const type = mem.memory_type || 'context';\n  const key = generateKey(mem, index);\n\n  const row = {\n    user_id: userId,\n    memory_type: type,\n    memory_key: key,\n    memory_value: mem.memory_value,\n    importance_score: mem.importance_score ?? 0.8,\n    session_id: sessionId,\n    conversation_date: nowIso,\n    entities: JSON.stringify(mem.entities || { people: [], topics: [] }),\n    temporal_context: mem.temporal_context || 'today',\n    is_active: true,\n    confidence_score: 1,\n    source: 'auto_extracted',\n    context_before: null,\n    context_after: null,\n  };\n\n  prepared.push(row);\n  console.log(`Prepare Memories: ACCEPTED ${key}`);\n});\n\nif (prepared.length === 0) {\n  console.log('Prepare Memories: no new memories after dedupe');\n}\n\nreturn prepared.map(r => ({ json: r }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        768
      ],
      "id": "ff08c679-c179-4a18-8aa2-94a2fa62aa64",
      "name": "Prepare Memories"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "= {{ $json.user_id }}",
              "rightValue": 0,
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              },
              "id": "ebb88b93-4047-405f-9730-737ec9f4b782"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        512,
        768
      ],
      "id": "f050357d-e6ac-4534-87cb-716092ac2cef",
      "name": "Has Memories?"
    },
    {
      "parameters": {
        "tableId": "ai_memories",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "memory_type",
              "fieldValue": "={{ $json.memory_type }}"
            },
            {
              "fieldId": "memory_key",
              "fieldValue": "={{ $json.memory_key }}"
            },
            {
              "fieldId": "memory_value",
              "fieldValue": "={{ $json.memory_value }}"
            },
            {
              "fieldId": "importance_score",
              "fieldValue": "={{ $json.importance_score }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "entities",
              "fieldValue": "={{ $json.entities }}"
            },
            {
              "fieldId": "temporal_context",
              "fieldValue": "={{ $json.temporal_context }}"
            },
            {
              "fieldId": "is_active",
              "fieldValue": "={{ $json.is_active }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        736,
        768
      ],
      "id": "a49da7b6-b0d6-41f6-9c29-d7d2242ea265",
      "name": "Save Memories"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Session Summary Generator v2\n// - Only summarizes completed sessions\n// - Skips very short/test sessions\n// - Produces richer, more structured summaries\n\nconst MIN_MESSAGES = 3;        // Require at least 3 messages in a session\nconst MIN_GAP_MINUTES = 15;    // Session must have ended at least 15 minutes ago\n\n// ---------- 1. Resolve user ID ----------\nlet userId;\n\ntry {\n  const ctx = $('Format Context with Memory1').first();\n  if (ctx?.json?.user_id) {\n    userId = ctx.json.user_id;\n  }\n} catch (e) {\n  console.log('Could not get user ID from Format Context with Memory', e);\n}\n\nif (!userId) {\n  try {\n    const userNode = $('Get User1').first();\n    if (userNode?.json?.id) {\n      userId = userNode.json.id;\n    }\n  } catch (e) {\n    console.log('Could not get user ID from Get User1', e);\n  }\n}\n\n// If we still don't have a userId, we can't safely summarize\nif (!userId) {\n  console.log('No userId found, skipping session summary');\n  return [];\n}\n\n// ---------- 2. Get conversation history for this user ----------\nlet conversations = [];\ntry {\n  conversations = $('Fetch Session History2').all() || [];\n} catch (e) {\n  console.log('Could not get conversations from Fetch Session History', e);\n  return [];\n}\n\n// Convert to plain JS objects and filter by this user (safety)\nconst allConversations = conversations\n  .map(c => c.json)\n  .filter(c => c && c.user_id === userId && c.session_id);\n\nif (allConversations.length < MIN_MESSAGES) {\n  console.log('Not enough conversations overall to summarize');\n  return [];\n}\n\n// Sort descending by created_at (newest first)\nallConversations.sort(\n  (a, b) => new Date(b.created_at) - new Date(a.created_at)\n);\n\n// ---------- 3. Work out current vs completed sessions ----------\nconst currentSessionId = allConversations[0].session_id;\nconsole.log('Current session ID:', currentSessionId);\n\nconst sessionsById = {};\nfor (const conv of allConversations) {\n  if (!sessionsById[conv.session_id]) {\n    sessionsById[conv.session_id] = [];\n  }\n  sessionsById[conv.session_id].push(conv);\n}\n\n// Remove the current session from candidates (we only want completed ones)\ndelete sessionsById[currentSessionId];\n\nconst candidateSessionIds = Object.keys(sessionsById);\nif (candidateSessionIds.length === 0) {\n  console.log('No completed sessions to summarize');\n  return [];\n}\n\n// ---------- 4. Pick the most recent completed session ----------\ncandidateSessionIds.sort((a, b) => {\n  const aRecent = Math.max(\n    ...sessionsById[a].map(c => new Date(c.created_at).getTime())\n  );\n  const bRecent = Math.max(\n    ...sessionsById[b].map(c => new Date(c.created_at).getTime())\n  );\n  return bRecent - aRecent;\n});\n\nconst sessionId = candidateSessionIds[0];\nconst sessionToSummarize = sessionsById[sessionId];\n\n// Ensure this session is ‚Äúreal‚Äù and not just a 1-message ping\nif (sessionToSummarize.length < MIN_MESSAGES) {\n  console.log(\n    `Session ${sessionId} has only ${sessionToSummarize.length} messages, skipping summary`\n  );\n  return [];\n}\n\n// Check how long ago this session ended\nconst mostRecentMessageTs = Math.max(\n  ...sessionToSummarize.map(c => new Date(c.created_at).getTime())\n);\nconst minutesSinceLastMessage =\n  (Date.now() - mostRecentMessageTs) / (1000 * 60);\n\nif (minutesSinceLastMessage < MIN_GAP_MINUTES) {\n  console.log(\n    `Session ${sessionId} ended only ${minutesSinceLastMessage.toFixed(\n      1\n    )} minutes ago, skipping summary`\n  );\n  return [];\n}\n\n// ---------- 5. Extract key info from this session ----------\nconst topics = new Set();\nconst people = new Set();\nconst decisions = [];\nlet firstUserMessage = null;\nlet lastUserMessage = null;\n\nfor (const conv of sessionToSummarize) {\n  if (!conv.user_message) continue;\n\n  const msg = conv.user_message;\n  const msgLower = msg.toLowerCase();\n\n  if (!firstUserMessage) firstUserMessage = msg;\n  lastUserMessage = msg;\n\n  // Topics (you can extend this list anytime)\n  if (msgLower.includes('staff') || msgLower.includes('hire') || msgLower.includes('recruit')) {\n    topics.add('hiring');\n  }\n  if (msgLower.includes('remind') || msgLower.includes('ingat')) {\n    topics.add('reminders');\n  }\n  if (msgLower.includes('meeting') || msgLower.includes('jumpa')) {\n    topics.add('meetings');\n  }\n  if (msgLower.includes('stok') || msgLower.includes('inventory')) {\n    topics.add('inventory');\n  }\n  if (msgLower.includes('duit') || msgLower.includes('bayar') || msgLower.includes('payment')) {\n    topics.add('money');\n  }\n\n  // Rough name detection (single capitalized words)\n  const namePattern = /\\b[A-Z][a-z]{2,}\\b/g;\n  const names = msg.match(namePattern) || [];\n  for (const name of names) {\n    if (!['I', 'Ara', 'ARA'].includes(name)) {\n      people.add(name);\n    }\n  }\n\n  // Decisions / plans (keep first 120 chars)\n  if (\n    msgLower.includes('need') ||\n    msgLower.includes('nak ') ||\n    msgLower.includes('akan ') ||\n    msgLower.includes('plan') ||\n    msgLower.includes('will')\n  ) {\n    decisions.push(msg.substring(0, 120));\n  }\n}\n\n// ---------- 6. Timing & meta info ----------\nsessionToSummarize.sort(\n  (a, b) => new Date(a.created_at) - new Date(b.created_at)\n);\nconst sessionStartTime = new Date(sessionToSummarize[0].created_at);\nconst sessionEndTime = new Date(\n  sessionToSummarize[sessionToSummarize.length - 1].created_at\n);\n\nconst dayOfWeekNames = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n];\nconst dayOfWeek = dayOfWeekNames[sessionStartTime.getDay()];\n\nconst hour = sessionStartTime.getHours();\nconst timeOfDay =\n  hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';\n\nconst durationMinutes = Math.max(\n  1,\n  Math.round((sessionEndTime - sessionStartTime) / (1000 * 60))\n);\n\n// ---------- 7. Build human-readable summary ----------\nlet summaryText = 'User ';\n\nif (topics.has('hiring')) {\n  summaryText += 'discussed getting help with hiring or staff issues';\n} else if (topics.size > 0) {\n  summaryText += `discussed ${Array.from(topics).join(', ')}`;\n} else {\n  summaryText += 'had a general conversation';\n}\n\nif (people.size > 0) {\n  summaryText += `, and mentioned ${Array.from(people).join(', ')}`;\n}\n\nsummaryText += `. Conversation lasted about ${durationMinutes} minute(s).`;\n\nif (decisions.length > 0) {\n  summaryText += ' Key decisions or needs were mentioned.';\n}\n\n// ---------- 8. Construct summary record ----------\nconst summary = {\n  user_id: userId,\n  session_id: sessionId,\n  conversation_date: sessionStartTime.toISOString(),\n  day_of_week: dayOfWeek,\n  time_of_day: timeOfDay,\n  summary: summaryText,\n  key_topics: Array.from(topics),\n  people_mentioned: Array.from(people),\n  decisions_made: decisions,\n  message_count: sessionToSummarize.length,\n  session_duration_minutes: durationMinutes,\n};\n\nconsole.log('Generated summary for completed session:', summary);\n\n// n8n expects an array of items: [{ json: ... }]\nreturn [{ json: summary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        1072
      ],
      "id": "17442ee0-db55-4abb-82f7-cf37ccb7b94d",
      "name": "Generate Session Summary"
    },
    {
      "parameters": {
        "tableId": "conversation_summaries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "day_of_week",
              "fieldValue": "={{ $json.day_of_week }}"
            },
            {
              "fieldId": "time_of_day",
              "fieldValue": "={{ $json.time_of_day }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $json.summary }}"
            },
            {
              "fieldId": "key_topics",
              "fieldValue": "={{ $json.key_topics }}"
            },
            {
              "fieldId": "people_mentioned",
              "fieldValue": "={{ $json.people_mentioned }}"
            },
            {
              "fieldId": "decisions_made",
              "fieldValue": "={{ $json.decisions_made }}"
            },
            {
              "fieldId": "message_count",
              "fieldValue": "={{ $json.message_count }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        512,
        1072
      ],
      "id": "c54ddbfc-9774-440d-9b3b-080cd4ae0030",
      "name": "Save Session Summary"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation1').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $json.body }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $('Extract Pending Action1').item.json.pending_action_type }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $('Extract Pending Action1').item.json.pending_action_payload }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "false"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -352,
        1072
      ],
      "id": "db74af71-dd4c-45e1-a0fc-32a471aa8131",
      "name": "Update Conversation1",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "jsCode": "// Validate Memories\n// Input: whatever Extract Memories returns as .json.output or directly as JSON\n// Output: array of clean memory objects (still abstract, no user_id etc.)\n\nlet raw = $json;\n\n// Some setups wrap the JSON array in an \"output\" field as a string\nlet memoriesRaw = raw.output ?? raw;\n\nlet memories = [];\n\ntry {\n  if (typeof memoriesRaw === 'string') {\n    // Strip markdown fences if they accidentally appear\n    memoriesRaw = memoriesRaw\n      .replace(/```json\\s*/g, '')\n      .replace(/```\\s*/g, '')\n      .trim();\n    memories = JSON.parse(memoriesRaw);\n  } else if (Array.isArray(memoriesRaw)) {\n    memories = memoriesRaw;\n  } else {\n    // If it's a single object instead of array, wrap it\n    memories = [memoriesRaw];\n  }\n} catch (e) {\n  console.log('Validate Memories: failed to parse memories', e);\n  return [];\n}\n\nif (!Array.isArray(memories)) {\n  console.log('Validate Memories: parsed value is not an array');\n  return [];\n}\n\nconst ALLOWED_TYPES = new Set(['preference', 'relationship', 'context', 'interaction']);\n\nconst cleaned = memories\n  .filter(m => m && typeof m === 'object')\n  .map((m, idx) => {\n    const mem = { ...m };\n\n    // Normalize memory_type\n    if (!ALLOWED_TYPES.has(mem.memory_type)) {\n      // Try to map invalid types\n      if (mem.memory_type === 'business/role') {\n        mem.memory_type = 'context';\n      } else {\n        // Unknown type ‚Üí treat as context by default\n        mem.memory_type = 'context';\n      }\n    }\n\n    // Ensure text fields exist\n    mem.memory_value = (mem.memory_value || '').toString().trim();\n    mem.memory_key = (mem.memory_key || `memory_${idx}`).toString().trim();\n\n    // Default importance\n    const importance = Number(mem.importance_score ?? 0.8);\n    mem.importance_score = isNaN(importance) ? 0.8 : importance;\n\n    // Normalize entities\n    const entities = mem.entities || {};\n    mem.entities = {\n      people: Array.isArray(entities.people) ? entities.people : [],\n      topics: Array.isArray(entities.topics) ? entities.topics : [],\n    };\n\n    // Temporal context\n    mem.temporal_context = mem.temporal_context || 'today';\n\n    return mem;\n  })\n  .filter(mem => {\n    // Filter out junk\n    if (!mem.memory_value || mem.memory_value.length < 10) return false;\n    if (mem.importance_score < 0.7) return false;\n    return true;\n  });\n\nreturn cleaned.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        768
      ],
      "id": "a70eef59-6e7a-495a-baec-db83ef3cf29e",
      "name": "Validate Memories1"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ $('Format Context with Memory1').item.json.ara_context.user.phone }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -640,
        928
      ],
      "id": "8e2e7d93-333a-491f-bb1c-a0ec372e7383",
      "name": "Send Reply1"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract Pending Action\n// ----------------------\n// Input from ARA Main Agent / Onboarding Agent:\n//   - Old shape: { output: \"<assistant reply>\" }\n//   - Message Model: { message: { content: \"<assistant reply>\" } }\n//\n// Behaviour:\n// - If reply contains `ARA_PENDING: { ... }`, parse it into:\n//      pending_action_type, pending_action_payload\n// - Remove BOTH the ARA_PENDING and ARA_ACTION blocks\n//   from the text for WhatsApp\n// - Keep the original fields for logging / Update Conversation\n\n// Normalise reply from different node shapes\n// - Old main agent: { output: \"...\" }\n// - Message Model:  { message: { content: \"...\" } }\n// - Raw OpenAI style: { choices: [ { message: { content: \"...\" } } ] }\n\nlet reply = '';\n\n// 1) Old main agent shape\nif (typeof $json.output === 'string' && $json.output.trim() !== '') {\n  reply = $json.output;\n\n// 2) Message Model node shape\n} else if ($json.message && typeof $json.message.content === 'string' && $json.message.content.trim() !== '') {\n  reply = $json.message.content;\n\n// 3) Raw OpenAI-style shape (safety net)\n} else if (Array.isArray($json.choices) && $json.choices[0]?.message?.content) {\n  reply = $json.choices[0].message.content;\n}\n\nlet cleanReply = reply || '';\n\nlet pending_action_type = 'none';\nlet pending_action_payload = null;\n\n// 1) Extract & handle ARA_PENDING\nconst pendingMatch = reply.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})/);\n\nif (pendingMatch) {\n  try {\n    const parsed = JSON.parse(pendingMatch[1]);  // { type, payload }\n    if (parsed && parsed.type) {\n      pending_action_type = parsed.type || 'none';\n      pending_action_payload = parsed.payload || null;\n    }\n  } catch (err) {\n    // If parse fails, we just treat it as no pending action\n  }\n\n  // Remove the ARA_PENDING part from the visible reply\n  cleanReply = cleanReply.replace(pendingMatch[0], '').trim();\n}\n\n// 2) Strip ARA_ACTION from visible reply (we parse it later in Route Confirmed Actions)\nconst actionMatch = reply.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\nif (actionMatch) {\n  cleanReply = cleanReply.replace(actionMatch[0], '').trim();\n}\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Clean text for Send Reply (no ARA_ACTION / ARA_PENDING)\n  assistant_response: cleanReply,\n\n  // Action description from THIS message (pending action only)\n  pending_action_type,\n  pending_action_payload,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1120,
        576
      ],
      "id": "c068a8cc-ba8b-4320-9fb4-5968e3cd6813",
      "name": "Extract Pending Action1"
    },
    {
      "parameters": {
        "jsCode": "// ROUTE CONFIRMED ACTIONS\n// -----------------------\n// INPUT EXPECTED (from Extract Pending Action + previous nodes):\n// - pending_action_type       (from THIS assistant reply's ARA_PENDING)\n// - pending_action_payload\n// - ara_context               (contains dialogue_state with pendingAction from DB)\n// - user_message              (latest user input)\n// - assistant_response        (for passing through to Send Reply)\n\nconst currentType = $json.pending_action_type || 'none';\nconst currentPayload = $json.pending_action_payload || null;\n\n// ara_context comes from \"Format Context with Memory\"\nconst araContext = $json.ara_context || {};\nconst ds = araContext.dialogue_state || {};\nconst pending = ds.pendingAction || null;\nconst isActiveResponse = !!ds.isActiveResponse;\nconst responseType = ds.activeResponseType || null;  // 'yes' | 'no' | null\n\nlet ARA_ACTION = {\n  type: 'none',\n  payload: null,\n};\n\n// CASE 1: User is replying YES/NO to an existing pendingAction\nif (\n  pending &&\n  pending.type &&\n  pending.type !== 'none' &&\n  isActiveResponse &&\n  (responseType === 'yes' || responseType === 'no')\n) {\n  if (responseType === 'yes') {\n    // Confirm the pending action (create/delete/update/...)\n    ARA_ACTION = {\n      type: pending.type,\n      payload: pending.payload || {},\n    };\n  } else if (responseType === 'no') {\n    // Cancel the pending action\n    ARA_ACTION = {\n      type: pending.type + '_cancel',\n      payload: pending.payload || {},\n    };\n  }\n} else {\n  // CASE 2: Immediate actions that do NOT require confirmation\n\n  // Example: escalate to human\n  if (currentType === 'escalate') {\n    ARA_ACTION = {\n      type: 'escalate',\n      payload: currentPayload || {},\n    };\n  }\n\n  // üîπ NEW: direct profile updates (no YES/NO roundtrip)\n  else if (currentType === 'user_update_profile') {\n    ARA_ACTION = {\n      type: 'user_update_profile',\n      payload: currentPayload || {},\n    };\n  }\n}\n\n// CASE 3: User profile updates (ARA_ACTION from main agent or onboarding agent)\n// If the agent outputs ARA_ACTION.update_user_preferences directly inside the text\n\nlet rawOutput = '';\n\n// 1) Old main agent shape: { output: \"...\" }\nif (typeof $json.output === 'string' && $json.output.trim() !== '') {\n  rawOutput = $json.output;\n\n// 2) Message Model / onboarding shape: { message: { content: \"...\" } }\n} else if ($json.message && typeof $json.message.content === 'string' && $json.message.content.trim() !== '') {\n  rawOutput = $json.message.content;\n\n// 3) Raw OpenAI-style shape: { choices: [ { message: { content: \"...\" } } ] }\n} else if (Array.isArray($json.choices) && $json.choices[0]?.message?.content) {\n  rawOutput = $json.choices[0].message.content;\n}\n\nconst actionMatch = rawOutput.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\n\nif (actionMatch) {\n  try {\n    const parsedAction = JSON.parse(actionMatch[1]);\n\n    if (parsedAction.type === 'update_user_preferences') {\n      // Build payload ONLY with non-null fields\n      const payload = {};\n\n      if (\n        typeof parsedAction.preferred_name === 'string' &&\n        parsedAction.preferred_name.trim() !== ''\n      ) {\n        payload.preferred_name = parsedAction.preferred_name.trim();\n      }\n\n      if (\n        typeof parsedAction.preferred_language === 'string' &&\n        parsedAction.preferred_language.trim() !== ''\n      ) {\n        payload.preferred_language = parsedAction.preferred_language.trim();\n      }\n\n      // Only overwrite ARA_ACTION if we have something real to update\n      if (Object.keys(payload).length > 0) {\n        ARA_ACTION = {\n          type: 'update_user_preferences',\n          payload,\n        };\n      }\n      // else: no valid fields ‚Üí keep whatever ARA_ACTION was before\n    }\n  } catch (err) {\n    // ignore JSON parsing error, fall back to existing ARA_ACTION\n  }\n}\n\n\n// -----------------------------\n// SAFETY GUARDS (AILOOP PROTECT)\n// -----------------------------\n\n// 1) Whitelist allowed action types only\nconst allowedTypes = [\n  'none',\n  'reminder_create',\n  'reminder_delete',\n  'timezone_update',\n  'escalate',\n  'update_user_preferences',          // üîπ NEW\n\n  'reminder_create_cancel',\n  'reminder_delete_cancel',\n  'timezone_update_cancel',\n  'user_update_profile_cancel',   // optional future use\n];\n\nif (!allowedTypes.includes(ARA_ACTION.type)) {\n  ARA_ACTION = {\n    type: 'none',\n    payload: null,\n  };\n}\n\n// 2) Payload validation for specific actions\n\n// Reminder Create must have topic + suggested_time\nif (ARA_ACTION.type === 'reminder_create') {\n  const p = ARA_ACTION.payload || {};\n  const hasTopic =\n    typeof p.topic === 'string' && p.topic.trim().length > 0;\n  const hasTime =\n    typeof p.suggested_time === 'string' && p.suggested_time.trim().length > 0;\n\n  if (!hasTopic || !hasTime) {\n    // Invalid payload ‚Üí cancel action instead of firing broken data downstream\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Reminder Delete must have reminder_id\nif (ARA_ACTION.type === 'reminder_delete') {\n  const p = ARA_ACTION.payload || {};\n  const hasReminderId =\n    typeof p.reminder_id === 'string' && p.reminder_id.trim().length > 0;\n\n  if (!hasReminderId) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Timezone Update must have timezone + timezone_label\nif (ARA_ACTION.type === 'timezone_update') {\n  const p = ARA_ACTION.payload || {};\n  const hasTz =\n    typeof p.timezone === 'string' && p.timezone.trim().length > 0;\n  const hasLabel =\n    typeof p.timezone_label === 'string' && p.timezone_label.trim().length > 0;\n\n  if (!hasTz || !hasLabel) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Profile Update must have at least one field to update\nif (ARA_ACTION.type === 'user_update_profile') {\n  const p = ARA_ACTION.payload || {};\n  const updates = p.profile_updates || null;\n\n  const valid =\n    updates &&\n    typeof updates === 'object' &&\n    Object.keys(updates).length > 0;\n\n  if (!valid) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Preferences Update must have at least one field\nif (ARA_ACTION.type === 'update_user_preferences') {\n  const p = ARA_ACTION.payload || {};\n  const hasName = Object.prototype.hasOwnProperty.call(p, 'preferred_name');\n  const hasLang = Object.prototype.hasOwnProperty.call(p, 'preferred_language');\n\n  if (!hasName && !hasLang) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n\n\n// (We let 'escalate' and *_cancel pass even with minimal payload)\n\n// -----------------------------\n// Text back to user = assistant_response from previous node\n// -----------------------------\nconst final_reply = ($json.assistant_response || '').trim();\n\n// Safely pull the latest conversation row so we can attach ids\nconst latestItems = $items('Get Latest Conversation1');\nconst latest = latestItems.length ? latestItems[0].json : {};\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Ensure these four are present from Get Latest Conversation\n  id: latest.id ?? $json.id,\n  user_id: latest.user_id ?? $json.user_id,\n  telegram_chat_id: latest.telegram_chat_id ?? $json.telegram_chat_id,\n  message_id: latest.message_id ?? $json.message_id,\n\n  ARA_ACTION,\n  final_reply,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -640,
        192
      ],
      "id": "08894949-8d20-454f-a805-cddbd3d08d58",
      "name": "Route Confirmed Actions1"
    },
    {
      "parameters": {
        "tableId": "reminders",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation').item.json.user_id }}"
            },
            {
              "fieldId": "reminder_text",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.topic }}"
            },
            {
              "fieldId": "reminder_time",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.suggested_time }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "{{ $now }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "045d3438-f156-4014-ba9c-a28467cca1bd",
      "name": "Create Reminder1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_create",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "0d51000f-6a84-4eb8-8e74-e2190366c0dd"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Create"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7effae48-3c8b-445c-bdaf-8043843459f1",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f18fc6df-6c26-4714-ba28-fa4560fcec67",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "escalate",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Escalate"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4995634b-8db5-4173-8c98-866642aee254",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "timezone_update",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Timezone update"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "6695a56f-6968-4e5d-a459-9d98fe92a1ef",
                    "leftValue": "={{ $json[\"ARA_ACTION\"].type }}",
                    "rightValue": "update_user_preferences",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update User Profile"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -352,
        160
      ],
      "id": "6f5fc986-f735-471f-ac1f-69a57de51676",
      "name": "Route Actions Switch1"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "reminders",
        "filters": {
          "conditions": [
            {
              "keyName": "reminder_text",
              "condition": "ilike",
              "keyValue": "={{ $json.pending_action_payload.topic }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        0,
        192
      ],
      "id": "c323f1bf-ef2b-4472-8cd6-749039deb241",
      "name": "Delete Reminder1"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "home_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "current_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1120,
        1840
      ],
      "id": "a7d856c3-243f-4061-a84a-2d94aaee0aa0",
      "name": "Update Timezone"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "home_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "current_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        0,
        384
      ],
      "id": "da8311e6-c03e-4fa4-8a00-5338c38e6b95",
      "name": "Update Timezone1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "46456542-8f2a-447d-b598-1713986577a7",
              "name": "user_name",
              "value": "={{    $node[\"Get User1\"].json.first_name    || $node[\"Get User1\"].json.telegram_username    || $json.telegram_chat_id  }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        912,
        1648
      ],
      "id": "a9f07eac-5960-48b2-b0d5-d286084dc9bd",
      "name": "Get User name"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "46456542-8f2a-447d-b598-1713986577a7",
              "name": "user_name",
              "value": "={{    $node[\"Get User1\"].json.first_name    || $node[\"Get User1\"].json.telegram_username    || $json.telegram_chat_id  }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        0,
        576
      ],
      "id": "5e5e4f88-8332-4218-a3ad-c00886d9d3ca",
      "name": "Get User name1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.twilio.com/2010-04-01/Accounts/AC_REDACTED/Messages.json",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "twilioApi",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "From",
              "value": "=whatsapp:+601125911400"
            },
            {
              "name": "To",
              "value": "whatsapp:+601136521251"
            },
            {
              "name": "ContentSid",
              "value": "HXce8e8c9580065acd9c86815c679a0dbe"
            },
            {
              "name": "ContentVariables",
              "value": "={{ JSON.stringify({\n  \"1\": $json.user_name,\n  \"2\": $('Route Confirmed Actions').item.json.telegram_chat_id,\n  \"3\": $('Route Confirmed Actions').item.json.ARA_ACTION.payload.reason\n       + \". \"\n       + $('Route Confirmed Actions').item.json.ARA_ACTION.payload.summary,\n  \"4\": $('Route Confirmed Actions').item.json.ARA_ACTION.payload.last_user_message,\n  \"5\": $now\n}) }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1136,
        1648
      ],
      "id": "8066256a-668d-4cbf-b2b3-f8dfc7bd3f3f",
      "name": "Escalate"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.twilio.com/2010-04-01/Accounts/AC_REDACTED/Messages.json",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "twilioApi",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "From",
              "value": "=whatsapp:+601125911400"
            },
            {
              "name": "To",
              "value": "whatsapp:+601136521251"
            },
            {
              "name": "ContentSid",
              "value": "HXce8e8c9580065acd9c86815c679a0dbe"
            },
            {
              "name": "ContentVariables",
              "value": "={{ JSON.stringify({\n  \"1\": $json.user_name,\n  \"2\": $('Route Confirmed Actions1').item.json.telegram_chat_id,\n  \"3\": $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.reason\n       + \". \"\n       + $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.summary,\n  \"4\": $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.last_user_message,\n  \"5\": $now\n}) }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        288,
        576
      ],
      "id": "bc8756c2-c694-44df-916d-ad1d48a77807",
      "name": "Escalate1"
    },
    {
      "parameters": {
        "tableId": "escalations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.user_id }}"
            },
            {
              "fieldId": "user_name",
              "fieldValue": "={{ $('Get User name').item.json.user_name }}"
            },
            {
              "fieldId": "user_phone",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.telegram_chat_id }}"
            },
            {
              "fieldId": "reason",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.reason }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.summary }}"
            },
            {
              "fieldId": "last_user_message",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.last_user_message }}"
            },
            {
              "fieldId": "urgency",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.urgency }}"
            },
            {
              "fieldId": "admin_phone",
              "fieldValue": "={{ '601136521251' }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "={{ 'open' }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1360,
        1648
      ],
      "id": "9368fa71-62a3-463a-b741-6d2966cee611",
      "name": "Create Escalation Log"
    },
    {
      "parameters": {
        "tableId": "escalations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.user_id }}"
            },
            {
              "fieldId": "user_name",
              "fieldValue": "={{ $('Get User name1').item.json.user_name }}"
            },
            {
              "fieldId": "user_phone",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.telegram_chat_id }}"
            },
            {
              "fieldId": "reason",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.reason }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.summary }}"
            },
            {
              "fieldId": "last_user_message",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.last_user_message }}"
            },
            {
              "fieldId": "urgency",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.urgency }}"
            },
            {
              "fieldId": "admin_phone",
              "fieldValue": "={{ '601136521251' }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "={{ 'open' }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        512,
        576
      ],
      "id": "064cd5c2-4928-4254-b0ed-2fbc5fed138e",
      "name": "Create Escalation Log1"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ $json.telegram_id }}",
        "toWhatsapp": true,
        "message": "HI! üòä Welcome to ARA (Ai-Ready Assistant). Sebentar ye, saya sedang daftar user baru.\n\n_By continuing to chat, you agree to ARA‚Äôs Terms & Privacy Policy_\n_https://araaisolution.com/terms-of-service_\n_https://araaisolution.com/privacy-policy_\n\n",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -3984,
        704
      ],
      "id": "dcb09910-3850-48f1-bd00-feacc302387b",
      "name": "Send 1st Message"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.error }}",
                    "rightValue": "duplicate key value violates unique constraint \"users_telegram_id_key\"",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "40c674dd-ce02-4977-a627-ada421b19aaf"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Existing user"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -4224,
        944
      ],
      "id": "8eb9cf80-c471-4586-8289-08e4c2eb737d",
      "name": "New User?",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "content": "## Changed"
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1136,
        1824
      ],
      "typeVersion": 1,
      "id": "07c70056-1547-4267-8ec9-28fed3e9e942",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "jsCode": "const replyRaw = ($json.assistant_response || '').trim();\n\n// Simple language guess from latest user message (if available)\nconst userMsg = ($json.user_message || '').trim().toLowerCase();\n\nfunction buildFallback(msg) {\n  const hasMalayHints = /lah|tak|awak|saya|boleh|ingatkan|esok|pukul/.test(msg);\n  if (hasMalayHints) {\n    return \"Maaf, ada masalah teknikal sekejap. Cuba hantar semula mesej tadi ya. üôè\";\n  }\n  return \"Sorry, something went wrong on my side. Please send your last message again. üôè\";\n}\n\nlet safeReply = replyRaw;\nlet fallback_used = false;\n\nif (!safeReply) {\n  safeReply = buildFallback(userMsg);\n  fallback_used = true;\n}\n\n// Return everything + guaranteed reply text\nreturn {\n  ...$json,\n  assistant_response: safeReply,\n  fallback_used,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -192,
        2064
      ],
      "id": "2345d4de-2d05-464a-b0ff-5f98bf2d2ee3",
      "name": "Prepare Reply (Fail-Safe)"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "event_type",
              "fieldValue": "incoming_message"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{   {     source: \"whatsapp\",     direction: \"inbound\",     message_id: $json.SmsMessageSid || $json.MessageSid || $json.message_id || null,     from: $json.From || $json.from || null,     to: $json.To || $json.to || null,     raw_body: $json.Body || $json.body || $json.user_message || \"\"   } }}"
            },
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -4224,
        1680
      ],
      "id": "d1b7dcd9-9f32-4481-ae7c-68cd6a529ae4",
      "name": "Log Incoming Message"
    },
    {
      "parameters": {
        "content": "## Changed"
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -4336,
        1648
      ],
      "typeVersion": 1,
      "id": "b16a4026-193a-4bd9-bb8b-be5183c6ae61",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "reminder_created"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  type: \"reminder\",\n  action: \"created\",\n  reminder_id: $json.id || null,\n  reminder_text: $json.reminder_text || null,\n  reminder_time: $json.reminder_time || null,\n  is_sent: $json.is_sent\n} }}\n"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1120,
        1264
      ],
      "id": "3dc1e3d8-f2ff-444e-a291-3b8b4e9b24df",
      "name": "Log Reminder Created"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "memory_extracted"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {   source: \"whatsapp\",   type: \"memory\",   action: \"saved\",   memory_id: $json.id || null,   memory_category: $json.category || null,   memory_title: $json.title || null } }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1792,
        2032
      ],
      "id": "25dffe55-d5de-49a4-b429-e4171e710daf",
      "name": "Log Memory Extracted"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "fallback_triggered"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  scope: \"main_agent\",\n  reason: \"assistant_response_empty_or_invalid\",\n  last_user_message: $json.user_message || null\n} }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        80,
        2496
      ],
      "id": "b03e57eb-c9a9-46fd-8cd5-e5489bc974cc",
      "name": "log Main Fallback"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.fallback_used }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "32a5b251-f43e-40f7-bda8-b82ec3edfbf7"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        -64,
        2320
      ],
      "id": "1af0e4ea-0a9d-44bc-9c73-4aafc4e75e9e",
      "name": "IF Fallback Used?"
    },
    {
      "parameters": {
        "jsCode": "const replyRaw = ($json.assistant_response || '').trim();\n\n// Simple language guess from latest user message (if available)\nconst userMsg = ($json.user_message || '').trim().toLowerCase();\n\nfunction buildFallback(msg) {\n  const hasMalayHints = /lah|tak|awak|saya|boleh|ingatkan|esok|pukul/.test(msg);\n  if (hasMalayHints) {\n    return \"Maaf, ada masalah teknikal sekejap. Cuba hantar semula mesej tadi ya. üôè\";\n  }\n  return \"Sorry, something went wrong on my side. Please send your last message again. üôè\";\n}\n\nlet safeReply = replyRaw;\nlet fallback_used = false;\n\nif (!safeReply) {\n  safeReply = buildFallback(userMsg);\n  fallback_used = true;\n}\n\n// Return everything + guaranteed reply text\nreturn {\n  ...$json,\n  assistant_response: safeReply,\n  fallback_used,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -912,
        848
      ],
      "id": "900669c7-13d5-4627-ab37-7ffc2094f279",
      "name": "Prepare Reply (Fail-Safe)1"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation1').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "fallback_triggered"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  scope: \"main_agent\",\n  reason: \"assistant_response_empty_or_invalid\",\n  last_user_message: $json.user_message || null\n} }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -512,
        1280
      ],
      "id": "e6c3b845-2a67-40c2-9d0e-78867eef34ac",
      "name": "log Main Fallback1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.fallback_used }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "32a5b251-f43e-40f7-bda8-b82ec3edfbf7"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        -720,
        1184
      ],
      "id": "451e90f1-82cd-4dbf-9e01-ba305aa64715",
      "name": "IF Fallback Used?1"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "memory_extracted"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {   source: \"whatsapp\",   type: \"memory\",   action: \"saved\",   memory_id: $json.id || null,   memory_category: $json.category || null,   memory_title: $json.title || null } }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1024,
        784
      ],
      "id": "678ca394-65c2-43ef-a296-5e1eb859c733",
      "name": "Log Memory Extracted1"
    },
    {
      "parameters": {
        "jsCode": "// This code cleans relative-day words from reminder topic\n// and leaves other flows untouched.\n\nconst RELATIVE_DAY_REGEX = /\\b(hari ini|esok|lusa|minggu depan|bulan depan|malam ini|pagi esok|today|tomorrow|tonight|next week|next month|this morning|this evening)\\b/gi;\n\nreturn items.map(item => {\n  const data = item.json || {};\n\n  let payload = data.pending_action_payload;\n\n  // Some flows store payload as JSON string, some as object\n  if (typeof payload === 'string') {\n    try {\n      payload = JSON.parse(payload);\n    } catch (e) {\n      // If parsing fails, just skip cleaning and pass through\n      item.json = data;\n      return item;\n    }\n  }\n\n  if (payload && typeof payload === 'object' && typeof payload.topic === 'string') {\n    payload.topic = payload.topic\n      .replace(RELATIVE_DAY_REGEX, '')   // remove relative-day words\n      .replace(/\\s+/g, ' ')             // collapse double spaces\n      .trim();\n  }\n\n  // Put payload back in its original shape\n  data.pending_action_payload = payload;\n\n  item.json = data;\n  return item;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        1264
      ],
      "id": "36d459d4-2c15-4a99-bed9-20bbc4796a24",
      "name": "Sanitise Reminder Topic"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE public.users\nSET\n  preferred_name = COALESCE(NULLIF($1::text, 'null'), preferred_name),\n  preferred_language = CASE\n    WHEN $2 IS NULL OR $2 = '__KEEP__' THEN preferred_language\n    ELSE $2\n  END\nWHERE id = $3;\n",
        "options": {
          "queryReplacement": "={{ $json[\"ARA_ACTION\"].payload.preferred_name ?? null }}, {{ \n  $json[\"ARA_ACTION\"].payload.preferred_language === undefined\n    ? '__KEEP__'\n    : $json[\"ARA_ACTION\"].payload.preferred_language\n}}, {{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        656,
        1744
      ],
      "id": "cdbb595f-b8e6-4e66-8da2-5b110e6dfdf9",
      "name": "PG ‚Äì Update user preferences"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE public.users\nSET\n preferred_name = COALESCE(NULLIF($1::text, 'null'), preferred_name),\n  preferred_language = CASE\n    WHEN $2 IS NULL OR $2 = '__KEEP__' THEN preferred_language\n    ELSE $2\n  END\nWHERE id = $3;\n",
        "options": {
          "queryReplacement": "={{ $json[\"ARA_ACTION\"].payload.preferred_name ?? null }}, {{    $json[\"ARA_ACTION\"].payload.preferred_language === undefined     ? '__KEEP__'     : $json[\"ARA_ACTION\"].payload.preferred_language }}, {{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -224,
        480
      ],
      "id": "50e68e0b-81f3-412e-8685-dcd6eb66cb85",
      "name": "PG ‚Äì Update user preferences1"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Mixed-Offer Override (SAFE GUARDRAIL)\n// Run mode: \"Run Once for Each Item\"  ‚úÖ must return a SINGLE object (not an array)\n\nconst item = $json;\n\nconst currentType = (item.pending_action_type || 'none').toString();\n\n// Pass through if extractor already found an action\nif (currentType !== 'none') {\n  return item;\n}\n\nconst assistantText = (item.assistant_response || '').toString().trim();\nif (!assistantText) return item;\n\n// 1) Must look like a REMINDER offer (not generic offers)\nconst hasReminderWords = /\\b(remind|reminder|ingatkan|peringat)\\b/i.test(assistantText);\n\nconst hasOfferAsk =\n  /\\b(would you like me to|do you want me to|shall i|should i|can i|may i)\\b/i.test(assistantText) ||\n  /\\b(just to confirm|to confirm)\\b/i.test(assistantText) ||\n  /\\b(nak saya|mahu saya|boleh saya)\\b/i.test(assistantText);\n\nif (!hasReminderWords || !hasOfferAsk) {\n  return item;\n}\n\n// 2) Require explicit day anchor (no guessing dates)\nconst isTomorrow = /\\b(tomorrow|esok)\\b/i.test(assistantText);\nconst isToday = /\\b(today|harini|hari ini)\\b/i.test(assistantText);\nif (!isTomorrow && !isToday) return item;\n\n// 3) Extract clock time\nlet hour = null;\nlet minute = 0;\n\nlet m = assistantText.match(/\\b([01]?\\d|2[0-3])[:.](\\d{2})\\s*(am|pm)?\\b/i);\nif (m) {\n  hour = parseInt(m[1], 10);\n  minute = parseInt(m[2], 10);\n  const ampm = (m[3] || '').toLowerCase();\n  if (ampm === 'pm' && hour < 12) hour += 12;\n  if (ampm === 'am' && hour === 12) hour = 0;\n} else {\n  m = assistantText.match(/\\b([1-9]|1[0-2])\\s*(am|pm)\\b/i);\n  if (m) {\n    hour = parseInt(m[1], 10);\n    minute = 0;\n    const ampm = (m[2] || '').toLowerCase();\n    if (ampm === 'pm' && hour < 12) hour += 12;\n    if (ampm === 'am' && hour === 12) hour = 0;\n  }\n}\n\nif (hour === null) return item;\n\n// 4) Build suggested_time safely for +08 zones only\nconst tz = item?.ara_context?.user?.timezone || 'Asia/Kuala_Lumpur';\nconst plus8Zones = new Set(['Asia/Kuala_Lumpur', 'Asia/Kuching', 'Asia/Singapore']);\nif (!plus8Zones.has(tz)) return item;\n\nfunction pad2(n) { return String(n).padStart(2, '0'); }\n\nconst nowUtc = new Date();\nconst nowPlus8 = new Date(nowUtc.getTime() + 8 * 60 * 60 * 1000);\n\nlet y = nowPlus8.getUTCFullYear();\nlet mo = nowPlus8.getUTCMonth() + 1;\nlet d = nowPlus8.getUTCDate();\n\nif (isTomorrow) d += 1;\n\nconst suggested_time = `${y}-${pad2(mo)}-${pad2(d)}T${pad2(hour)}:${pad2(minute)}:00+08:00`;\n\n// 5) Topic extraction (SAFE): derive from THIS assistant offer sentence, not history\nlet topic = null;\n\n// Try English \"about <topic>\" pattern\nlet t = assistantText.match(/\\babout\\s+(.+?)(\\?|$)/i);\nif (t && t[1]) {\n  topic = t[1].trim();\n}\n\n// Try Malay \"pasal/mengenai/tentang <topic>\" pattern\nif (!topic) {\n  t = assistantText.match(/\\b(pasal|mengenai|tentang)\\s+(.+?)(\\?|$)/i);\n  if (t && t[2]) topic = t[2].trim();\n}\n\n// Clean trailing filler words\nif (topic) {\n  topic = topic.replace(/\\s+(right|ya|betul)\\s*$/i, '').trim();\n}\n\n// Fallback 1: use current user message text (still safer than scanning long history)\nif (!topic) {\n  topic = (item?.ara_context?.current_message?.text || item?.user_message || '').toString().trim();\n}\n\n// Fallback 2: safe snippet of assistant\nif (!topic) {\n  topic = assistantText.slice(0, 120);\n}\n\n\n// Apply override\nreturn {\n  ...item,\n  pending_action_type: 'reminder_offer',\n  pending_action_payload: {\n    topic,\n    suggested_time,\n  },\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -256,
        1744
      ],
      "id": "24280ef3-bd8d-427d-bc2f-72305d1b8dfe",
      "name": "Mixed-Offer Override"
    }
  ],
  "connections": {
    "ARA Main Agent": {
      "main": [
        [
          {
            "node": "Extract Pending Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Model": {
      "ai_languageModel": [
        [
          {
            "node": "Extract Memories",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Search Memory Tool": {
      "ai_tool": [
        [
          {
            "node": "ARA Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Extract Memories": {
      "main": [
        [
          {
            "node": "Validate Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Ended?": {
      "main": [
        [],
        [
          {
            "node": "Generate Session Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [],
        [
          {
            "node": "Within 30 days?1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Within 30 days?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Manager": {
      "main": [
        [
          {
            "node": "Continue Session",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Session": {
      "main": [
        [
          {
            "node": "Fetch Session History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Session": {
      "main": [
        [
          {
            "node": "Fetch Session History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Session History": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sort": {
      "main": [
        [
          {
            "node": "Session Manager",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get User Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Previous Conversation": {
      "main": [
        [
          {
            "node": "Sort",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Memories": {
      "main": [
        [
          {
            "node": "Get Relevant Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Memory & Session": {
      "main": [
        [
          {
            "node": "Get ARA Brain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context with Memory": {
      "main": [
        [
          {
            "node": "Get Latest Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Within 30 days?": {
      "main": [
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User1": {
      "main": [
        [
          {
            "node": "Check Time Zone",
            "type": "main",
            "index": 0
          },
          {
            "node": "Log Incoming Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Memories1": {
      "main": [
        [
          {
            "node": "Has Memories?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Memories?1": {
      "main": [
        [
          {
            "node": "Save Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Session Summary1": {
      "main": [
        [
          {
            "node": "Save Session Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Conversation": {
      "main": [
        [
          {
            "node": "Session Ended?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List Reminders Tool": {
      "ai_tool": [
        [
          {
            "node": "ARA Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Validate Memories": {
      "main": [
        [
          {
            "node": "Prepare Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "ARA Main Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Twilio Webhook": {
      "main": [
        [
          {
            "node": "Prepare Incoming Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Within 30 days?1": {
      "main": [
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Incoming Message": {
      "main": [
        [
          {
            "node": "Ensure User Exist",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Free User Onboarding": {
      "main": [
        [
          {
            "node": "Extract Pending Action1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure User Exist": {
      "main": [
        [
          {
            "node": "Get User1",
            "type": "main",
            "index": 0
          },
          {
            "node": "New User?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply": {
      "main": [
        [
          {
            "node": "Extract Memories",
            "type": "main",
            "index": 0
          },
          {
            "node": "Update Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Latest Conversation": {
      "main": [
        [
          {
            "node": "ARA Main Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Pending Action": {
      "main": [
        [
          {
            "node": "Prepare Reply (Fail-Safe)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Mixed-Offer Override",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Confirmed Actions": {
      "main": [
        [
          {
            "node": "Route Actions Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Actions Switch": {
      "main": [
        [
          {
            "node": "Sanitise Reminder Topic",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Delete Reminder",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get User name",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Timezone",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "PG ‚Äì Update user preferences",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Relevant Memories": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get ARA Brain": {
      "main": [
        [
          {
            "node": "Format Brain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Brain": {
      "main": [
        [
          {
            "node": "Format Context with Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Time Zone": {
      "main": [
        [
          {
            "node": "Get Previous Conversation1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Previous Conversation1": {
      "main": [
        [
          {
            "node": "Sort1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sort1": {
      "main": [
        [
          {
            "node": "Session Manager1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get User Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get ARA Brain1": {
      "main": [
        [
          {
            "node": "Format Brain1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Brain1": {
      "main": [
        [
          {
            "node": "Format Context with Memory1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context with Memory1": {
      "main": [
        [
          {
            "node": "Get Latest Conversation1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Latest Conversation1": {
      "main": [
        [
          {
            "node": "Free User Onboarding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Manager1": {
      "main": [
        [
          {
            "node": "Continue Session1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Session1": {
      "main": [
        [
          {
            "node": "Fetch Session History2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Session1": {
      "main": [
        [
          {
            "node": "Fetch Session History2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Session History2": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Memories1": {
      "main": [
        [
          {
            "node": "Get Relevant Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Relevant Memories1": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Wait for Memory & Session1": {
      "main": [
        [
          {
            "node": "Get ARA Brain1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Extract Memories1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Extract Memories1": {
      "main": [
        [
          {
            "node": "Validate Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Ended?1": {
      "main": [
        [],
        [
          {
            "node": "Generate Session Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Memories": {
      "main": [
        [
          {
            "node": "Has Memories?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Memories?": {
      "main": [
        [
          {
            "node": "Save Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Session Summary": {
      "main": [
        [
          {
            "node": "Save Session Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Conversation1": {
      "main": [
        [
          {
            "node": "Session Ended?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Memories1": {
      "main": [
        [
          {
            "node": "Prepare Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply1": {
      "main": [
        [
          {
            "node": "Extract Memories1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Update Conversation1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Pending Action1": {
      "main": [
        [
          {
            "node": "Route Confirmed Actions1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Reply (Fail-Safe)1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Confirmed Actions1": {
      "main": [
        [
          {
            "node": "Route Actions Switch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Actions Switch1": {
      "main": [
        [
          {
            "node": "Create Reminder1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Delete Reminder1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get User name1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Timezone1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "PG ‚Äì Update user preferences1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User name": {
      "main": [
        [
          {
            "node": "Escalate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User name1": {
      "main": [
        [
          {
            "node": "Escalate1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Escalate": {
      "main": [
        [
          {
            "node": "Create Escalation Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Escalate1": {
      "main": [
        [
          {
            "node": "Create Escalation Log1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "New User?": {
      "main": [
        [],
        [
          {
            "node": "Send 1st Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Reply (Fail-Safe)": {
      "main": [
        [
          {
            "node": "Send Reply",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF Fallback Used?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Reminder": {
      "main": [
        [
          {
            "node": "Log Reminder Created",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Memories1": {
      "main": [
        [
          {
            "node": "Log Memory Extracted",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Fallback Used?": {
      "main": [
        [
          {
            "node": "log Main Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Reply (Fail-Safe)1": {
      "main": [
        [
          {
            "node": "IF Fallback Used?1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send Reply1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Fallback Used?1": {
      "main": [
        [
          {
            "node": "log Main Fallback1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Memories": {
      "main": [
        [
          {
            "node": "Log Memory Extracted1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitise Reminder Topic": {
      "main": [
        [
          {
            "node": "Create Reminder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mixed-Offer Override": {
      "main": [
        [
          {
            "node": "Route Confirmed Actions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true
  }
}

{
  "id": "mRY9BIAdrXO202A7",
  "name": "ARA | Check-in | Segment A | v4.0",
  "active": 0,
  "createdAt": "2025-12-25 17:32:55.277",
  "updatedAt": "2026-01-25 14:34:24.516",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 3
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.3,
      "position": [
        -96,
        -224
      ],
      "id": "0500c064-764a-4c4e-808d-bdbe3f62947a",
      "name": "Cron Trigger (Every 3 hours)"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select\n  u.id as user_id,\n\n  -- WhatsApp / Telegram identifiers\n  u.telegram_id as wa_number,\n  u.telegram_id as telegram_chat_id,\n\n  -- Language & timezone\n  coalesce(u.current_timezone, u.home_timezone, u.timezone, 'Asia/Kuala_Lumpur') as timezone,\n  coalesce(u.preferred_language, 'en') as preferred_language,\n\n  -- Name fields (raw)\n  u.preferred_name,\n  u.first_name,\n  u.telegram_username,\n\n  -- SAFE display name (single source of truth)\n  nullif(\n    trim(\n      coalesce(\n        u.preferred_name,\n        u.first_name,\n        u.telegram_username,\n        ''\n      )\n    ),\n    ''\n  ) as display_name,\n\n  -- Metadata (optional but useful later)\n  u.last_interaction,\n  u.plan_type\n\nfrom public.users u\nwhere u.is_active = true\n  and u.telegram_id is not null\n  and u.telegram_id ~ '^[1-9][0-9]{7,14}$';\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        128,
        -224
      ],
      "id": "568f68a2-6dc3-4a3f-99d7-817ea40d1fff",
      "name": "Fetch Candidate Users"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        384,
        -224
      ],
      "id": "380a7d9d-f9b8-402d-bd00-16bee588e99c",
      "name": "Split In Batches"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select max(created_at) as last_inbound_user_message_at\nfrom public.conversations\nwhere user_id = $1\n  and user_message is not null;\n",
        "options": {
          "queryReplacement": "={{$json.user_id}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        672,
        -208
      ],
      "id": "9096ad0b-dc00-4475-b190-3c1937d8020f",
      "name": "Get Last Inbound"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const user = $node[\"Split In Batches\"].json;\nconst inbound = $node[\"Get Last Inbound\"].json;\n\n// ================= SAFE TEST TOGGLE =================\nconst TEST_MODE = false; // ðŸ” change to true when testing only\n\nconst TEST_USER_IDS = new Set([\n  \"2a4e5985-1b49-4cb6-bfc0-a85b296d8f30\" // Joe\n]);\n\nconst isTestUser = TEST_MODE && TEST_USER_IDS.has(user.user_id);\n// ===================================================\n\nconst lastInbound = inbound.last_inbound_user_message_at;\n\n// If no inbound message â†’ block (test user may pass only in TEST_MODE)\nif (!lastInbound && !isTestUser) {\n  return {\n    ...user,\n    segmentA_eligible: false,\n    reason: \"no_inbound\"\n  };\n}\n\nconst tz = (user.timezone && user.timezone.trim())\n  ? user.timezone.trim()\n  : \"Asia/Kuala_Lumpur\";\n\nfunction localHour(date, timeZone) {\n  const fmt = new Intl.DateTimeFormat(\"en-GB\", {\n    timeZone, hour: \"2-digit\", hour12: false\n  });\n  return Number(fmt.format(date));\n}\n\nfunction localYMD(date, timeZone) {\n  const fmt = new Intl.DateTimeFormat(\"en-GB\", {\n    timeZone, year: \"numeric\", month: \"2-digit\", day: \"2-digit\"\n  });\n  const parts = fmt.formatToParts(date);\n  const m = Object.fromEntries(parts.map(p => [p.type, p.value]));\n  return `${m.year}-${m.month}-${m.day}`;\n}\n\nconst now = new Date();\nconst lastInboundDate = new Date(lastInbound);\n\nconst minutesSinceInbound = (now - lastInboundDate) / 60000;\nconst hoursSinceInbound = minutesSinceInbound / 60;\n\nconst isWindowOpen = hoursSinceInbound < 24;\nconst isActiveChat = minutesSinceInbound <= 60;\nconst hourLocal = localHour(now, tz);\nconst isHumaneTime = hourLocal >= 9 && hourLocal < 21;\n\n/**\n * SEGMENT A ELIGIBILITY RULE\n * - Humane time is NEVER bypassed\n * - Test user only relaxes \"window open\"\n */\nconst segmentA_eligible =\n  (isWindowOpen || isTestUser) &&\n  !isActiveChat &&\n  isHumaneTime;\n\nreturn {\n  ...user,\n  last_inbound_user_message_at: lastInbound,\n  tz_effective: tz,\n  local_hour: hourLocal,\n  local_ymd: localYMD(now, tz),\n  hoursSinceInbound,\n  isWindowOpen,\n  isActiveChat,\n  isHumaneTime,\n  isTestUser,\n  segmentA_eligible\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        896,
        -208
      ],
      "id": "91cf8ff6-a0b3-46d3-b8b9-22aef69b70cc",
      "name": "Compute Segment A Eligibility"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "6ccc83b0-820b-4e8a-80df-c842528b58eb",
              "leftValue": "={{$json.segmentA_eligible}}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1120,
        -240
      ],
      "id": "595f6cf8-694e-4c1e-a36e-44466f1a75c6",
      "name": "Segment A eligible?"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select\n  max(c.created_at) as last_power_tip_at\nfrom public.conversations c\nwhere c.user_id = $1\n  and c.message_type = 'proactive_power_tip';\n",
        "options": {
          "queryReplacement": "={{$json.user_id}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1376,
        -192
      ],
      "id": "1cb5d83e-96da-45bf-ae59-d97d74ddf040",
      "name": "Get Last Power Tip",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const user = $json; // includes last_power_tip_at if the SQL returned it\n\n// If query returned no rows, last_power_tip_at may be undefined\nconst lastAt = user.last_power_tip_at ? new Date(user.last_power_tip_at) : null;\nconst now = new Date();\n\nfunction toLocalYMD(date, tz) {\n  return new Intl.DateTimeFormat('en-CA', {\n    timeZone: tz,\n    year: 'numeric', month: '2-digit', day: '2-digit',\n  }).format(date); // YYYY-MM-DD\n}\n\nconst tz = (user.tz_effective || user.timezone || 'Asia/Kuala_Lumpur').toString();\nconst nowLocalYMD = toLocalYMD(now, tz);\n\nlet pass_daily_cap = true;\nlet pass_12h_guard = true;\n\nif (lastAt) {\n  const lastLocalYMD = toLocalYMD(lastAt, tz);\n  pass_daily_cap = (lastLocalYMD !== nowLocalYMD);\n\n  const hoursSinceLast = (now.getTime() - lastAt.getTime()) / (1000 * 60 * 60);\n  pass_12h_guard = (hoursSinceLast >= 12);\n}\n\n// Final decision = both must pass\nconst pass_frequency = pass_daily_cap && pass_12h_guard;\n\nreturn {\n  ...user,\n  pass_daily_cap,\n  pass_12h_guard,\n  pass_frequency,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1776,
        -160
      ],
      "id": "59a81720-b07c-412b-b73c-9c0cab6ea257",
      "name": "Frequency Guards (1/day + 12h)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "a93856d5-6c0a-42c4-aea6-9772fab2a303",
              "leftValue": "={{$json.pass_frequency}}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        2000,
        -160
      ],
      "id": "6795d6b7-b160-40dd-95db-22424b7324bf",
      "name": "Pass frequency?"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "500f9330-573d-4627-91df-2adf2fa4a185",
              "leftValue": "={{$json.tip_id}}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        3200,
        -336
      ],
      "id": "24af51e4-2749-4113-a2a1-23a40ffaa64c",
      "name": "Tip found?"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select *\nfrom public.ara_power_tips\nwhere status = 'active'\norder by random()\nlimit 1;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3360,
        -128
      ],
      "id": "c75364bc-560e-4433-a07c-1ad9ccff7b5e",
      "name": "Select Fallback Tip"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "7abf1d2b-7656-4673-b6d4-f49878cc77c6",
              "leftValue": "={{$json.tip_id}}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        3776,
        -160
      ],
      "id": "0ac51ee3-491f-475a-adfb-5891bc62ad75",
      "name": "Tip found?1"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ $('Merge Tip + User Context').item.json.wa_number }}",
        "toWhatsapp": true,
        "message": "={{$json.final_message}}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        5040,
        -336
      ],
      "id": "30c7567b-c4f1-41b5-b5fc-8a157cd574b9",
      "name": "Send WhatsApp (Free-form)"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "conversations",
          "mode": "list",
          "cachedResultName": "conversations"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "is_complete": false,
            "onboarding_sent": false,
            "pending_action_resolved": false,
            "user_id": "={{ $('Tip found?').item.json.user_id }}",
            "message_id": "={{ $json.sid }}",
            "assistant_response": "={{ $json.body }}",
            "created_at": "={{ $now }}",
            "message_type": "proactive_power_tip",
            "message_data": "={{ {\n  context_tags: $json.context_tags,\n  selected_tip_id: $json.selected_tip_id,\n  selected_tip_category: $json.selected_tip_category\n} }}",
            "telegram_chat_id": "={{ $('Tip found?').item.json.telegram_chat_id }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "user_id",
              "displayName": "user_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "telegram_chat_id",
              "displayName": "telegram_chat_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "message_id",
              "displayName": "message_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "message_type",
              "displayName": "message_type",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "user_message",
              "displayName": "user_message",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "message_data",
              "displayName": "message_data",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": true
            },
            {
              "id": "assistant_response",
              "displayName": "assistant_response",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "context_summary",
              "displayName": "context_summary",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "emotion_detected",
              "displayName": "emotion_detected",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "action_taken",
              "displayName": "action_taken",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "session_id",
              "displayName": "session_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "is_complete",
              "displayName": "is_complete",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "canBeUsedToMatch": true
            },
            {
              "id": "topics_discussed",
              "displayName": "topics_discussed",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "array",
              "canBeUsedToMatch": true
            },
            {
              "id": "people_mentioned",
              "displayName": "people_mentioned",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "array",
              "canBeUsedToMatch": true
            },
            {
              "id": "onboarding_sent",
              "displayName": "onboarding_sent",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "canBeUsedToMatch": true
            },
            {
              "id": "pending_action_type",
              "displayName": "pending_action_type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "pending_action_payload",
              "displayName": "pending_action_payload",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            },
            {
              "id": "pending_action_resolved",
              "displayName": "pending_action_resolved",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "canBeUsedToMatch": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        5408,
        -112
      ],
      "id": "25daf695-0c65-46b9-8e30-b74df4121fc1",
      "name": "Log to conversations"
    },
    {
      "parameters": {
        "jsCode": "// ===================================================\n// Build Message (SAFE, NON-HALLUCINATING)\n// Input: single item, Simplify Output = ON\n// ===================================================\n\nconst item = $input.first().json;\n\n// ---------------------------------------------------\n// Helpers\n// ---------------------------------------------------\nconst clean = (s) =>\n  (s || \"\")\n    .toString()\n    .replace(/\\s+/g, \" \")\n    .trim();\n\nconst clip = (s, n = 80) => {\n  s = clean(s);\n  return s.length > n ? s.slice(0, n - 1) + \"â€¦\" : s;\n};\n\n// Messages that are NOT meaningful context\nconst BORING_MESSAGES = new Set([\n  \"ok\",\n  \"okay\",\n  \"great\",\n  \"yes\",\n  \"yes pls\",\n  \"thanks\",\n  \"thank you\",\n  \"done\",\n  \"show it\",\n  \"show\",\n]);\n\nfunction isMeaningful(text) {\n  const t = clean(text).toLowerCase();\n  if (!t) return false;\n  if (t.length < 6) return false;\n  if (BORING_MESSAGES.has(t)) return false;\n  return true;\n}\n\n// ---------------------------------------------------\n// 1ï¸âƒ£ Determine USER NAME (safe)\n// ---------------------------------------------------\nconst name =\n  clean(item.display_name) ||\n  clean(item.preferred_name) ||\n  clean(item.first_name) ||\n  clean(item.telegram_username) ||\n  null;\n\n// ---------------------------------------------------\n// 2ï¸âƒ£ Determine LAST MEANINGFUL USER MESSAGE\n// ---------------------------------------------------\nlet lastMeaningfulUserMessage = \"\";\n\n// Prefer recent_context (newest â†’ oldest)\nif (Array.isArray(item.recent_context)) {\n  for (let i = item.recent_context.length - 1; i >= 0; i--) {\n    const msg = item.recent_context[i]?.user_message;\n    if (isMeaningful(msg)) {\n      lastMeaningfulUserMessage = clean(msg);\n      break;\n    }\n  }\n}\n\n// Fallback to last_inbound_user_message\nif (!lastMeaningfulUserMessage && isMeaningful(item.last_inbound_user_message)) {\n  lastMeaningfulUserMessage = clean(item.last_inbound_user_message);\n}\n\n// ---------------------------------------------------\n// 3ï¸âƒ£ Determine TOPIC PHRASE (VERY STRICT)\n// ---------------------------------------------------\nlet topicPhrase = \"\";\n\n// Use AI topic ONLY if it looks sane\nconst aiTopic = clean(item.topic_phrase_ai);\n\nif (\n  aiTopic &&\n  aiTopic.length >= 6 &&\n  aiTopic.length <= 60 &&\n  !aiTopic.toLowerCase().includes(\"extract\") &&\n  !aiTopic.toLowerCase().includes(\"topic\") &&\n  !aiTopic.toLowerCase().includes(\"general\")\n) {\n  topicPhrase = aiTopic;\n}\n\n// Otherwise derive from real user message\nif (!topicPhrase && lastMeaningfulUserMessage) {\n  topicPhrase = clip(lastMeaningfulUserMessage, 60);\n}\n\n// Final fallback\nif (!topicPhrase) {\n  topicPhrase = \"your task\";\n}\n\n// ---------------------------------------------------\n// 4ï¸âƒ£ Build TIP BODY (safe replacement)\n// ---------------------------------------------------\nlet tipBody = clean(item.tip_body);\n\nif (tipBody.includes(\"{{context}}\")) {\n  tipBody = tipBody.replaceAll(\"{{context}}\", topicPhrase);\n}\n\nif (!tipBody) {\n  tipBody =\n    \"You can say what you want to do and Iâ€™ll help you organise, remember, or follow up â€” all here in WhatsApp.\";\n}\n\n// ---------------------------------------------------\n// 5ï¸âƒ£ Time-aware opener (no creep)\n// ---------------------------------------------------\nconst hour = Number(item.local_hour ?? 12);\n\nlet opener;\nif (hour >= 22 || hour <= 5) {\n  opener = name ? `Hey ${name} ðŸ˜Š quick one before you rest:` : `Hey ðŸ˜Š quick one before you rest:`;\n} else if (hour <= 11) {\n  opener = name ? `Good morning ${name} ðŸ˜Š quick tip:` : `Good morning ðŸ˜Š quick tip:`;\n} else if (hour <= 17) {\n  opener = name ? `Hey ${name} ðŸ˜Š quick tip for your day:` : `Hey ðŸ˜Š quick tip for your day:`;\n} else {\n  opener = name ? `Good evening ${name} ðŸ˜Š quick tip:` : `Good evening ðŸ˜Š quick tip:`;\n}\n\n// ---------------------------------------------------\n// 6ï¸âƒ£ Framing (ONLY when required)\n// ---------------------------------------------------\nlet framing = \"\";\n\nif (item.requires_context && topicPhrase === \"your task\") {\n  framing = \"This might help with what you were doing earlier:\";\n}\n\n// ---------------------------------------------------\n// 7ï¸âƒ£ Final message assembly\n// ---------------------------------------------------\nconst closer =\n  \"If you want, tell me what youâ€™re working on â€” Iâ€™ll suggest the next best step.\";\n\nconst finalMessage = framing\n  ? `${opener}\\n\\n${framing}\\n\\nðŸ’¡ ${tipBody}\\n\\n${closer}`\n  : `${opener}\\n\\nðŸ’¡ ${tipBody}\\n\\n${closer}`;\n\n// ---------------------------------------------------\n// 8ï¸âƒ£ Output\n// ---------------------------------------------------\nitem.final_message = finalMessage;\nitem.message_body = finalMessage;\nitem.outgoing_message_type = \"power_tips\";\nitem.used_topic_phrase = topicPhrase;\n\nreturn [{ json: item }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4752,
        -384
      ],
      "id": "198e487f-cde9-45c0-8d0a-856e2bcf1746",
      "name": "Build Message"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select\n  created_at,\n  message_type,\n  user_message,\n  assistant_response\nfrom public.conversations\nwhere user_id = $1\n  and message_type = 'whatsapp'\norder by created_at desc\nlimit 10;\n",
        "options": {
          "queryReplacement": "={{$json.user_id}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2208,
        -256
      ],
      "id": "7b76b2f0-8c5b-46a5-932a-a69f55a24ee0",
      "name": "Get Recent Context",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Context Tags (Run Once for All Items)\n\n// 1) Grab identity / user info from an upstream node that still has it\n// Change \"Pass frequency?\" to whichever node still contains user_id/wa_number in your run.\nconst base = $node[\"Pass frequency?\"].json;\n\n// 2) Grab the 10 recent conversation rows from input\nconst rows = $input.all().map(i => i.json);\n\n// Ensure newest -> oldest (optional, your SQL already orders desc)\nrows.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));\n\n// 3) Build a compact text block for LLM later (optional but useful)\nconst context_text = rows.map(r => {\n  const t = r.created_at ? new Date(r.created_at).toISOString() : \"\";\n  const u = (r.user_message || \"\").trim();\n  const a = (r.assistant_response || \"\").trim();\n  return `(${t}) U: ${u}\\nA: ${a}`;\n}).join(\"\\n\\n\");\n\n// 4) (Optional) lightweight tags â€” you can improve later\nconst tags = [];\nconst blob = (rows.map(r => `${r.user_message || \"\"}\\n${r.assistant_response || \"\"}`).join(\"\\n\")).toLowerCase();\nif (blob.includes(\"remind\")) tags.push(\"reminders\");\nif (blob.includes(\"pay\") || blob.includes(\"pricing\") || blob.includes(\"price\")) tags.push(\"pricing\");\nif (blob.includes(\"call\")) tags.push(\"calls\");\n\nreturn [\n  {\n    json: {\n      ...base,                 // âœ… restores user_id, wa_number, tz, etc\n      recent_context: rows,     // âœ… full 10-row array\n      context_text,             // âœ… optional\n      context_tags: tags        // âœ… optional\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2416,
        -256
      ],
      "id": "10ddf058-2490-4819-848b-f0ac13d10216",
      "name": "Build Context Tags"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "with tags as (\n  select coalesce(array_agg(value), '{}'::text[]) as arr\n  from jsonb_array_elements_text($1::jsonb) as value\n),\nsent as (\n  -- last time each tip was sent to this user (power tips only)\n  select\n    (c.message_data->>'selected_tip_id') as tip_id,\n    max(c.created_at) as last_sent_at\n  from public.conversations c\n  where c.user_id = $2\n    and c.message_type = 'proactive_power_tip'\n    and c.message_data ? 'selected_tip_id'\n  group by (c.message_data->>'selected_tip_id')\n)\nselect\n  t.*,\n  s.last_sent_at\nfrom public.ara_power_tips t\ncross join tags\nleft join sent s\n  on s.tip_id = t.tip_id\nwhere t.status = 'active'\n  and (\n    t.requires_context = false\n    or t.context_tags && tags.arr\n  )\norder by\n  -- Unseen-first\n  (s.last_sent_at is null) desc,\n\n  -- Relevance\n  (t.context_tags && tags.arr) desc,\n  cardinality(\n    array(\n      select unnest(t.context_tags)\n      intersect\n      select unnest(tags.arr)\n    )\n  ) desc,\n\n  -- If seen, rotate oldest-sent first\n  s.last_sent_at asc nulls first,\n\n  -- Stable tie-break\n  t.created_at desc\nlimit 1;\n",
        "options": {
          "queryReplacement": "={{ JSON.stringify($json.context_tags ?? []) }}, {{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2656,
        -160
      ],
      "id": "2ea27ff2-ac3d-4c0f-af20-6dbee09c40db",
      "name": "Select Best Tip (ranked)",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1584,
        -240
      ],
      "id": "6e463299-8d26-47cf-a4d3-5f2d4cad2f3d",
      "name": "Merge"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2896,
        -256
      ],
      "id": "62873b86-0302-4299-9205-b143b647d6db",
      "name": "Merge Tip + User Context"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3568,
        -192
      ],
      "id": "525f604f-3fc3-45a5-964a-14674d7de913",
      "name": "Merge Fallback Tip + User Context"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "GPT-4.1-MINI-2025-04-14"
        },
        "responses": {
          "values": [
            {
              "content": "=={{ $json.last_inbound_user_message \n   || ($json.recent_context && $json.recent_context.length ? $json.recent_context[$json.recent_context.length - 1].user_message : \"\")\n   || \"\" }}"
            },
            {
              "role": "system",
              "content": "You extract a short topic phrase from the user's most recent message.\n\nRules:\n- Output ONLY 2â€“6 words in the same language as the user's message.\n- No punctuation, no quotes, no emojis.\n- Do NOT translate.\n- Do NOT output instructions like \"extract topic phrase\".\n- If the message is too vague (e.g. \"Hi\", \"Ok\", \"Great\", \"Yes\"), output: general tasks\n"
            }
          ]
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 2.1,
      "position": [
        3936,
        -352
      ],
      "id": "14896a6a-bc79-452a-9d23-68f39faba271",
      "name": "Topic Phrase Ai"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        4304,
        -480
      ],
      "id": "cd696b51-35ec-453e-80cc-155a01156fb5",
      "name": "Merge1"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first().json;\n\n// 1) If simplify-output gives a direct field\nconst direct =\n  (item.topic_phrase_ai ?? \"\").toString().trim() ||\n  (item.text ?? \"\").toString().trim() ||\n  (item.output_text ?? \"\").toString().trim();\n\nif (direct) {\n  item.topic_phrase_ai = direct;\n  return [{ json: item }];\n}\n\n// 2) Otherwise parse the structured output you showed\ntry {\n  const out0 = item.output?.[0];\n  const content = Array.isArray(out0?.content) ? out0.content : [];\n  const outText = content.find(c => c?.type === \"output_text\")?.text;\n\n  if (typeof outText === \"string\" && outText.trim()) {\n    item.topic_phrase_ai = outText.trim();\n  }\n} catch (e) {\n  // do nothing, just don't crash\n}\n\nreturn [{ json: item }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4512,
        -480
      ],
      "id": "a99bca6b-93ff-42e0-8e9c-394920955786",
      "name": "Extract Ai Phrase"
    },
    {
      "parameters": {
        "content": "##Toggle to test"
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        800,
        -272
      ],
      "typeVersion": 1,
      "id": "96668653-c434-4ded-a555-1eacffba942c",
      "name": "Sticky Note"
    }
  ],
  "connections": {
    "Cron Trigger (Every 3 hours)": {
      "main": [
        [
          {
            "node": "Fetch Candidate Users",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Candidate Users": {
      "main": [
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split In Batches": {
      "main": [
        [],
        [
          {
            "node": "Get Last Inbound",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Last Inbound": {
      "main": [
        [
          {
            "node": "Compute Segment A Eligibility",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Segment A Eligibility": {
      "main": [
        [
          {
            "node": "Segment A eligible?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Segment A eligible?": {
      "main": [
        [
          {
            "node": "Get Last Power Tip",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Last Power Tip": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Frequency Guards (1/day + 12h)": {
      "main": [
        [
          {
            "node": "Pass frequency?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass frequency?": {
      "main": [
        [
          {
            "node": "Get Recent Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tip found?": {
      "main": [
        [
          {
            "node": "Topic Phrase Ai",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Select Fallback Tip",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Select Fallback Tip": {
      "main": [
        [
          {
            "node": "Merge Fallback Tip + User Context",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Tip found?1": {
      "main": [
        [
          {
            "node": "Topic Phrase Ai",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send WhatsApp (Free-form)": {
      "main": [
        [
          {
            "node": "Log to conversations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Message": {
      "main": [
        [
          {
            "node": "Send WhatsApp (Free-form)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log to conversations": {
      "main": [
        [
          {
            "node": "Split In Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Recent Context": {
      "main": [
        [
          {
            "node": "Build Context Tags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Context Tags": {
      "main": [
        [
          {
            "node": "Select Best Tip (ranked)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Tip + User Context",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Fallback Tip + User Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Select Best Tip (ranked)": {
      "main": [
        [
          {
            "node": "Merge Tip + User Context",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Frequency Guards (1/day + 12h)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Tip + User Context": {
      "main": [
        [
          {
            "node": "Tip found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Fallback Tip + User Context": {
      "main": [
        [
          {
            "node": "Tip found?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Topic Phrase Ai": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Extract Ai Phrase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Ai Phrase": {
      "main": [
        [
          {
            "node": "Build Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": {
    "node:Cron Trigger (Every 3 hours)": {
      "recurrenceRules": [
        21
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true
  }
}

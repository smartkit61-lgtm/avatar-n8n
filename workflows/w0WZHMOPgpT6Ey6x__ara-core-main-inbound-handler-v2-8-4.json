{
  "id": "w0WZHMOPgpT6Ey6x",
  "name": "ARA | Core | Main Inbound Handler | v2.8.4",
  "active": 1,
  "createdAt": "2026-02-02 13:25:58.315",
  "updatedAt": "2026-02-23 18:02:50.885",
  "nodes": [
    {
      "parameters": {
        "promptType": "define",
        "text": "=Current message:\n{{$node[\"Get Latest Conversation\"].json[\"user_message\"]\n  || $node[\"Patch Dialogue State\"].json[\"ara_context\"].current_message.text\n  || $json[\"user_message\"]\n  || $json[\"message\"]\n  || \"\"}}\n\nLast assistant message (most recent):\n{{$node[\"Patch Dialogue State\"].json[\"ara_context\"].last_assistant_message?.text\n  || \"\"}}\n\nARA context (JSON):\n{{JSON.stringify($node[\"Patch Dialogue State\"].json[\"ara_context\"])}}\n",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "=ABOUT ARA\nYou are ARA, a human-like WhatsApp assistant built by Coach Joe (Joeherry Gani) under ARA Ai Solution, a Malaysian AI company.\nYour job is to help users stay organised, remember important things, and manage daily tasks.\nYou always reply in the language specified by ara_context.reply_language (deterministic). Match the user‚Äôs energy/tone.\nYou remember past conversations and use them naturally.\n\nABOUT COACH JOE\nCoach Joe is your founder and CEO of ARA Ai Solution. He is a Malaysian business coach who helps entrepreneurs improve their systems, mindset, and daily operations.\nYou speak about him confidently, respectfully, and naturally ‚Äî like an assistant who knows her boss well.\n\nABOUT ARA AI SOLUTION\nARA Ai Solution is the company behind you. The company‚Äôs mission is to deliver simpoutputle, human-first AI assistance through WhatsApp without any apps or technical setup.\nThe vision: to help people run their life and business more smoothly using a caring, smart assistant. the company website is www.araaisolution.com. this whatsapp number +60 11-259 11400 is the number users contact you. to contact a human in the company, user can email at admin@araaisolution.com\n\nHOW YOU TALK ABOUT YOURSELF\nWhen the user asks what ARA is (any language/tone), introduce yourself as the WhatsApp assistant built by ARA Ai Solution that helps users organise life, remember important things, and manage daily tasks.\nWhen the user asks about Coach Joe (any language/tone), explain he is the founder of ARA Ai Solution and a business coach who helps entrepreneurs manage and improve their businesses clearly and calmly.\nAlways reply in the language specified by ara_context.reply_language (deterministic), while matching the user‚Äôs energy/tone.\n\nOUTPUT FORMAT (STRICT)\nYou MUST output ONLY a valid JSON object that matches this schema:\n\n{\n\"assistant_response\": \"string\",\n\"pending_action_type\": \"string\",\n\"pending_action_payload\": \"object|null\"\n}\n\nDo not include any extra text before or after the JSON.\nDo not use markdown code blocks.\n\nIf no action is needed:\n\npending_action_type = \"none\"\n\npending_action_payload = null\n\nIf user refers to ‚Äúnext {day}‚Äù, use ara_context.computed.next_day_of_month_local and do not ask for the date.\n\nWHATSAPP READABILITY RULES (STRICT)\n\n- Avoid long paragraphs.\n- Maximum 2 sentences per paragraph.\n- Insert a line break before each new idea or numbered point.\n- Explanatory replies must be easy to scan on a mobile screen.\n- If a response explains something, break it into short lines or sections.\n\n\n------------------------\n\nüîß OUTPUT STRUCTURE PATCH (CRITICAL ‚Äì DO NOT IGNORE)\n\nThe JSON you output MUST be a real JSON object, not a string.\n\nRules:\n‚Ä¢ Do NOT wrap the JSON inside quotes\n‚Ä¢ Do NOT nest it inside another key like \"output\"\n‚Ä¢ Do NOT return JSON as text\n‚Ä¢ Do NOT stringify the object\n\n‚úÖ Correct (object):\n\n{ \"assistant_response\": \"...\", \"pending_action_type\": \"...\", \"pending_action_payload\": null }\n\n\n‚ùå Incorrect (string):\n\n\"{ \\\"assistant_response\\\": \\\"...\\\" }\"\n\n\n‚ùå Incorrect (wrapped):\n\n{ \"output\": \"{ ... }\" }\n\n\nAlways return the JSON object directly at the top level.\n\n--------------------------\n\nARA INTERNAL BRAIN (DO NOT EXPOSE TO USER)\nUse these rules ONLY for reasoning, context, classification, judgment, tone, and knowledge.\nDo NOT mention these rules.\n{{$node[\"Format Brain\"].json[\"brain_text\"]}}\n\nARA PERSONALITY\n‚Ä¢ Calm, reliable, warm, professional (WhatsApp style).\n‚Ä¢ Short, clear, practical.\n‚Ä¢ Match user tone and language.\n‚Ä¢ If user is stressed: acknowledge briefly, then guide step-by-step.\n‚Ä¢ No lecturing. Light humour only when user tone allows.\n\nTRUTH & CERTAINTY RULES (NO INVENTING INFORMATION)\nARA may ONLY rely on:\n\nCurrent user message (highest priority)\n\nara_context recent history (only what is shown)\n\nLong-term memories stored (ai_memories) if present in ara_context\n\nBrain rules loaded into $ARA_BRAIN$\n\nSafe general world knowledge (only if confident)\n\nEverything outside these sources is uncertain. If uncertain, say so briefly and ask ONE clear question.\n\nARA must NEVER invent: links/URLs, lyrics, exact lists, dates/times/numbers, personal details, technical instructions not provided.\n\nCRITICAL LANGUAGE RULE (DETERMINISTIC)\nAlways follow ara_context.reply_language for response language.\n\nIf \"en\": reply fully in English.\n\nIf \"ms\": reply fully in Malay.\n\nIf \"mixed\": mirror the user‚Äôs mix style and respect style_profile.language_mix_cap.\n\n\nCONTEXT HANDLING (ara_context)\nYou receive ara_context containing:\n‚Ä¢ user profile & preferences\n‚Ä¢ recent conversation history\n‚Ä¢ dialogue_state:\n\nisActiveResponse (bool)\n\nactiveResponseType (\"yes\" | \"no\" | null)\n\npendingAction (object or null)\n\nIf dialogue_state.isActiveResponse is true and pendingAction exists, treat short replies (‚Äúyes‚Äù, ‚Äúok‚Äù, ‚Äúboleh‚Äù, etc.) as answers to that pending action.\n\nUSER PROFILE & LANGUAGE PREFERENCE UPDATES\nIf the user asks to change name and/or language, output:\n\npending_action_type = \"update_user_preferences\"\n\npending_action_payload = {\n\"preferred_name\": \"<string or null>\",\n\"preferred_language\": \"ms\" | \"en\" | \"id\" | null\n}\n\nRules:\n\nOnly include fields explicitly changed.\n\nIf ambiguous: ask ONE clarifying question and output pending_action_type=\"none\".\nLanguage code mapping:\n\nMalay/BM/Bahasa/Bahasa Melayu ‚Üí \"ms\"\n\nEnglish/Inggeris ‚Üí \"en\"\n\nIndonesian/Bahasa Indonesia/Indo ‚Üí \"id\"\n\nPENDING ACTION CONFIRMATION LOGIC (IMPORTANT)\nWhen ara_context.dialogue_state.pendingAction exists AND isActiveResponse is true:\n\nReminder offer confirmation\nIf pendingAction.type === \"reminder_offer\":\n\nIf activeResponseType === \"yes\":\nOutput pending_action_type=\"reminder_create\"\nOutput pending_action_payload = pendingAction.payload\n\nIf activeResponseType === \"no\":\nOutput pending_action_type=\"none\"\nOutput pending_action_payload=null\n\nTimezone offer confirmation\nIf pendingAction.type === \"timezone_offer\":\n\nIf activeResponseType === \"yes\":\nOutput pending_action_type=\"timezone_update\"\nOutput pending_action_payload = pendingAction.payload\n\nIf activeResponseType === \"no\":\nOutput pending_action_type=\"none\"\nOutput pending_action_payload=null\n\nDelete offer confirmation\nIf pendingAction.type === \"reminder_delete_offer\":\n\nIf activeResponseType === \"yes\":\nOutput pending_action_type=\"reminder_delete\"\nOutput pending_action_payload = { \"reminder_id\": pendingAction.payload.reminder_id }\n\nIf activeResponseType === \"no\":\nOutput pending_action_type=\"none\"\nOutput pending_action_payload=null\n\nDelete-all offer confirmation\nIf pendingAction.type === \"reminder_delete_all\":\n\nIf activeResponseType === \"yes\":\n\nOutput pending_action_type=\"reminder_delete\"\n\nOutput pending_action_payload = { \"delete_scope\": \"all_active\", \"user_id\": \"<ara_context.user.id>\" }\n\nIf activeResponseType === \"no\":\n\nOutput pending_action_type=\"none\"\n\nOutput pending_action_payload=null\n\nIn all confirmation replies:\n\nassistant_response must confirm what will happen (1‚Äì2 short WhatsApp sentences)\n\nDo NOT propose a new action in the same message.\n\nREMINDERS / FOLLOW-UP RULES\n\nREMINDER CREATION RULE (OVERRIDES OFFER)\nIf the user message contains reminder intent AND includes exact time(s), you MUST create immediately (do NOT use reminder_offer).\n\nA) Single reminder (one task + one time):\npending_action_type = \"reminder_create\"\npending_action_payload = {\n\"topic\": \"<short day-neutral topic>\",\n\"suggested_time\": \"<ISO 8601 datetime with timezone>\"\n}\n\nB) Bulk reminders (multiple tasks and/or multiple times):\npending_action_type = \"reminder_create\"\npending_action_payload = {\n\"reminders\": [\n{ \"topic\": \"<day-neutral topic>\", \"suggested_time\": \"<ISO>\" },\n{ \"topic\": \"<day-neutral topic>\", \"suggested_time\": \"<ISO>\" }\n]\n}\n\nOnly use reminder_offer if YOU asked a confirmation question.\n\nWhen to treat as reminder request\nTreat as reminder request only when user clearly indicates reminder intent (remind/ingatkan/peringatan/alarm/etc) AND includes a task.\n\nNo reminders without exact time\nIf user gives a day but no exact time (e.g. ‚Äútomorrow‚Äù, ‚Äúesok‚Äù, ‚Äúpetang‚Äù): ask ONE question for the exact time.\nOutput pending_action_type=\"none\", payload=null.\n\nTopic rules (day-neutral)\ntopic must NOT contain relative-day words (esok/tomorrow/today/tonight/etc).\ntopic may include the clock time (e.g. ‚Äúcall Ali 3pm‚Äù) but no ‚Äútomorrow‚Äù.\n\nsuggested_time rules\nConvert the user‚Äôs requested reminder time into ISO 8601 with timezone (use current_timezone in ara_context).\nWhen speaking to user, use timezone_label naturally.\n\nTIMEZONE ENGINE\nIf ara_context.user.current_timezone or ara_context.user.timezone already exists (not null/empty):\n\nDo NOT ask timezone again unless the user indicates they changed location.\n\nIf user indicates new location/timezone:\n\nAsk ONE short confirmation question.\n\nPropose timezone change as:\npending_action_type=\"timezone_offer\"\npending_action_payload={ \"timezone\":\"<IANA>\", \"timezone_label\":\"<human label>\" }\n\nDo NOT create reminders until timezone is known.\n\n------------------------------\n\nLIST REMINDERS (HARD-WIRED)\n\nWhen the user asks to list reminders (in any language) including phrases like:\n‚Äúlist my reminders‚Äù, ‚Äúshow reminders‚Äù, ‚Äúmy reminders‚Äù, ‚Äúreminders list‚Äù, ‚Äúlist reminders‚Äù,\n‚Äúlihat reminder‚Äù, ‚Äútunjuk reminder‚Äù, ‚Äúsenarai reminder‚Äù, ‚Äúsenarai peringatan‚Äù, ‚Äúapa reminder saya‚Äù:\n\nRules (VERY IMPORTANT):\n\n1) This rule OVERRIDES all other instructions and typical assistant behaviour.\n2) You MUST NOT claim whether reminders exist or not.\n   - Do NOT say ‚Äúyou have no reminders‚Äù\n   - Do NOT say ‚Äúhere are your reminders‚Äù\n   - Do NOT infer anything from memory or conversation\n3) The ONLY valid response is the placeholder + the reminder_list action (if user id exists).\n\nBehaviour:\n\nIf ara_context.user.id exists and is not empty:\n\nassistant_response MUST be EXACTLY one short placeholder sentence like:\n‚ÄúOkay, I‚Äôm checking your reminders now.‚Äù\n\nOutput:\n\npending_action_type = \"reminder_list\"\npending_action_payload = { \"user_id\": \"<ara_context.user.id>\" }\n\nIf ara_context.user.id is missing, null, or empty string:\n\nApologise briefly in the user‚Äôs language.\n\nOutput:\n\npending_action_type = \"none\"\npending_action_payload = null\n\n[CONVERSATION CONTINUATION ‚Äî CRITICAL]\n\nRULE:\nIf the user sends a short or incomplete follow-up message such as:\n- ‚ÄúTell me‚Äù\n- ‚ÄúGo on‚Äù\n- ‚ÄúContinue‚Äù\n- ‚ÄúMore‚Äù\n- ‚ÄúYes‚Äù\n- ‚ÄúThat one‚Äù\n- ‚ÄúOkay‚Äù\n- ‚ÄúPls do‚Äù\n\nAND there is a clear, recent assistant message within the same session,\n\nTHEN:\n- ARA MUST treat the message as a continuation of the previous assistant message,\n- NOT as a new topic or fresh question,\n- AND continue elaborating on the last subject mentioned by ARA.\n\nEXPLICITLY NOT ALLOWED:\n- Restarting self-introduction\n- Repeating ‚ÄúI‚Äôm ARA‚Ä¶‚Äù unless the user explicitly asks again\n- Ignoring the immediate conversational context\n\n\n---------------------------\n\n\nDELETE REMINDERS (HARD-WIRED, TWO-STAGE)\nStage 1: When user asks to delete a reminder:\nassistant_response must be a short placeholder like: ‚ÄòOkay, I‚Äôm checking your reminders now.‚Äô Do not say you don‚Äôt see any reminder.\nOutput pending_action_type=\"reminder_delete_request\"\n\nOutput pending_action_payload = {\n\"user_id\": \"<ara_context.user.id>\",\n\"query_text\": \"<raw user message>\",\n\"extracted_topic\": \"<best effort string or null>\",\n\"extracted_time_text\": \"<best effort string or null>\"\n}\n\nStage 2 is handled ONLY via confirmation logic when pendingAction.type is \"reminder_delete_offer\".\n\nENHANCED ESCALATION TRIGGERS (NO CONFIRMATION NEEDED)\n1) Negative escalation trigger rules\n\nEscalate with intent:\"negative\" when ANY of these are true:\n\nA. Clear dissatisfaction / complaint (direct)\n\nUser expresses anger, disappointment, mistrust, or ‚Äúyou‚Äôre not helping‚Äù\n\nMentions scam, cheating, useless, waste of time, ‚Äúbad service‚Äù\n\nB. Repeated failure\n\nThe same issue persists after 2 assistant attempts (or user says ‚Äústill not working‚Äù, ‚Äúsame problem‚Äù)\n\nC. Human request due to problem\n\n‚ÄúLet me talk to human/admin/support‚Äù in the context of an issue\n\nD. High-risk topics\n\nBilling/charges/refunds\n\nPrivacy/data/security\n\nLegal threats or public complaint (‚ÄúI will report you / post on social media‚Äù)\n\nE. Strong negative language (auto high urgency)\nIf message includes insults/threats or ‚ÄúI‚Äôm very angry‚Äù, set:\n\nurgency: \"high\"\n\n‚úÖ Don‚Äôt escalate just because user is brief (‚Äú??‚Äù, ‚Äúbro‚Äù) or confused once.\nWait for either clear negative sentiment OR second failure.\n\n2) Positive escalation trigger rules\n\nEscalate with intent:\"positive\" when ANY of these are true:\n\nA. Contact request\n\nUser asks to contact Coach Joe / ARA team / sales / partnership\n\nB. Buying intent\n\nPricing, packages, subscription, enterprise, ‚Äúhow to join‚Äù, ‚Äúhow to sign up‚Äù\n\nWants demo, onboarding for company/team\n\nC. Program interest\n\nCoaching, courses, training, speaking, collaboration\n\n‚úÖ If it‚Äôs just ‚Äútell me about ARA‚Äù, you can answer normally first.\nEscalate only when they want direct contact or show purchase intent.\n\nSMOOTHER RESPONSE STYLE (so it feels human)\nNegative escalation response pattern (3 beats)\n\nAcknowledge + apologize\n\nConfirm escalation done\n\nReassure next step (no email needed)\n\nExample:\n\n‚ÄúSorry about that üôè I understand. I‚Äôve escalated this to the ARA Ai Solution team so a human can review it. You don‚Äôt need to do anything else‚Äîsomeone will follow up.‚Äù\n\nPositive escalation response pattern (3 beats)\n\nEnthusiastic acknowledgement\n\nConfirm escalation done\n\nReassure next step (no email needed)\n\nExample:\n\n‚ÄúYes, can üòä I‚Äôve escalated your request to the ARA Ai Solution team so Coach Joe (or the team) can follow up. You don‚Äôt need to do anything else‚Äîsomeone will reach out.‚Äù\n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        16,
        3120
      ],
      "id": "4dd23aa3-4861-49ca-ae63-701b727b30a7",
      "name": "ARA Main Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1472,
        3504
      ],
      "id": "bb307a29-5d83-42e4-938b-1add2120fb00",
      "name": "OpenAI Model"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify({\n  latest_user_message: $('Get Latest Conversation').item.json.user_message || $json.Body || $json.body || '',\n  assistant_response: $('Send Reply').item.json.body || '',\n  user_context: $('Format Context with Memory').item.json.ara_context.user || {}\n}) }}",
        "options": {
          "systemMessage": "You are ARA‚Äôs Memory Extraction Agent.\n\nYour ONLY job is to decide what is worth saving into long-term memory for this user, based on the LATEST exchange.\n\nINPUT FORMAT\n\nYou will receive a JSON object with:\n\nlatest_user_message: the most recent WhatsApp message from the user\n\nassistant_response: the reply that ARA just sent to the user\n\nuser_context: basic info about the user (id, phone, timezone, etc.)\n\nCRITICAL CONSTRAINTS\n\nYou MUST ONLY consider:\n\nlatest_user_message\n\nassistant_response\n\nYou MUST NOT scan or ‚Äúimagine‚Äù earlier history, even if you see anything that looks like history or summaries in the input.\n\nTreat this as a single turn: one user message + one assistant reply.\n\nIf you are not clearly sure a fact will help in future conversations, DO NOT save it.\n\nIf there is nothing worth remembering, return an empty JSON array: [].\n\nGOAL\n\nDecide whether this turn contains anything that is worth remembering LATER to help this user:\n\npersonal facts\n\nstable preferences\n\nrelationships\n\nongoing tasks or recurring patterns\n\nbusiness / life context\n\nENTITY & WORLD-KNOWLEDGE SAFETY RULES (VERY IMPORTANT)\n\nThese rules are to prevent wrong ‚Äúpeople‚Äù and messy memories.\n\nPlaces are NEVER people\n\nTreat these as places, not persons, for example:\n\nCountries: Malaysia, Singapore, Indonesia, Thailand, Vietnam, UK, USA, Saudi Arabia, etc.\n\nMalaysian cities / regions: Kuala Lumpur, KL, Selangor, Penang, Johor Bahru, Ipoh, Melaka, Sabah, Sarawak, Kuching, Kota Kinabalu, etc.\n\nHoly places: Makkah/Mecca, Madinah/Medina, Kaabah, Masjidil Haram, Masjid Nabawi, etc.\n\nThey must NOT appear inside entities.people. They may appear in entities.topics or only inside memory_value.\n\nOrganisations, banks, and programmes are NEVER people\n\nAnything that looks like a company, bank, agency, or programme must NOT go into entities.people. Examples:\n\nNames containing: ‚ÄúBank‚Äù, ‚ÄúBerhad‚Äù, ‚ÄúBhd‚Äù, ‚ÄúSdn Bhd‚Äù, ‚ÄúCorp‚Äù, ‚ÄúCompany‚Äù, ‚ÄúUniversity‚Äù, ‚ÄúCollege‚Äù.\n\nKnown Malaysian orgs: MARA, AIM (Amanah Ikhtiar Malaysia), MRANTI, SME Bank, Maybank, CIMB, Bank Rakyat, Petronas, Tenaga Nasional, etc.\n\nPut them in entities.topics if relevant, or leave them only in memory_value.\n\nApps and tools are NEVER people\n\nWhatsApp, Telegram, Facebook, Instagram, TikTok, Google, YouTube, Shopee, Lazada, Grab, Foodpanda, ARA, etc. are tools/apps, not persons.\n\nThey must NOT be inside entities.people.\n\nGeneric roles are allowed but should be simple\n\nPhrases like ‚Äúmy tailor‚Äù, ‚Äúmy designer‚Äù, ‚Äúmy supplier‚Äù, ‚Äúmy mentor‚Äù can appear in memory_value.\nIn entities.people you may use a simple label like \"tailor\" or \"mentor\" if it clearly helps; never invent a personal name that wasn‚Äôt given.\n\nWhen in doubt about person vs place/org ‚Üí DO NOT mark as a person\n\nIf you‚Äôre not clearly sure something is a human name, leave it out of entities.people.\nIt is better to have fewer people than wrong people.\n\nWHAT TO EXTRACT\n\nExtract only information that:\n\nwill still matter in future conversations (hours, days, weeks later), AND\n\nhelps ARA be more helpful or personal.\n\nFocus on:\n\nPERSONAL BACKGROUND\n\nEducation, origin, profession, roles, life events.\n\nExample: ‚ÄúI‚Äôm from Kedah‚Äù, ‚ÄúI run a printing business‚Äù, ‚ÄúI‚Äôm a teacher‚Äù, ‚ÄúI just moved to London.‚Äù\n\nPREFERENCES & OPINIONS\n\nColors, products, styles, routines, habits, food, communication style, language preference, tools they like to use.\n\nExample: ‚ÄúCustomer Ali wants the color green‚Äù, ‚ÄúI prefer English‚Äù, ‚ÄúI like voice notes‚Äù, ‚ÄúI hate long paragraphs‚Äù.\n\nRELATIONSHIPS & ROLES\n\nWho is who: spouse, children, business partners, customers, suppliers, mentors, staff, etc.\n\nExample: ‚ÄúAishah is my wife‚Äù, ‚ÄúAli is my customer‚Äù, ‚ÄúSiti is the event planner for my wedding‚Äù.\n\nTASK PATTERNS & ONGOING CONTEXT\n\nRecurring routines or ongoing projects, not one-off noise.\n\nExample:\n\n‚ÄúEvery Monday I have team meeting at 9am.‚Äù\n\n‚ÄúI‚Äôm working on launching my new cafe in March.‚Äù\n\n‚ÄúI‚Äôm using ARA mainly to manage my business reminders.‚Äù\n\nIMPORTANT REMINDER-LIKE FACTS\n\nOnly if they reveal something stable or recurring.\n\nExample:\n\n‚ÄúI always call my mum every Sunday night.‚Äù\n\n‚ÄúMy rental is due on the 25th every month.‚Äù\n\nOne-off reminders that are already fully handled by the reminder system usually do NOT need to be saved as long-term memory.\n\nWHAT NOT TO SAVE\n\nDO NOT save:\n\nGreetings or filler:\n\n‚ÄúHi‚Äù, ‚ÄúHello‚Äù, ‚ÄúOK‚Äù, ‚ÄúThanks‚Äù, ‚ÄúBetul‚Äù, ‚ÄúDone‚Äù, ‚ÄúYes‚Äù, ‚ÄúNo‚Äù, etc.\n\nPure emotion with no concrete fact:\n\n‚ÄúYou are slow‚Äù, ‚ÄúI‚Äôm angry‚Äù, ‚ÄúService not good‚Äù, ‚ÄúI‚Äôm stressed‚Äù.\n\nTemporary confusion:\n\n‚ÄúI don‚Äôt know‚Äù, ‚ÄúWhat?‚Äù, ‚ÄúWhere is my reminder?‚Äù, ‚ÄúWhy you so slow?‚Äù\n\nTechnical/system-like text, IDs, or internal ARA messages.\n\nDetails that only matter for a single reminder and add no long-term value.\n\nShort, vague, or ambiguous statements that you cannot interpret safely.\n\nAnything that is not clearly about:\n\nthe user,\n\ntheir contacts/relationships,\n\ntheir stable preferences,\n\ntheir ongoing business or life context.\n\nIf unsure, prefer to skip the memory.\n\nMEMORY TYPES\n\nUse these types:\n\n\"preference\" ‚Üí stable likes/dislikes, style, language, choices.\n\n\"relationship\" ‚Üí who people are and how they are connected to the user.\n\n\"context\" ‚Üí facts about their situation, work, business, or long-term goals.\n\n\"interaction\" ‚Üí specific actions, decisions, or promises that may matter later (e.g. ‚Äúuser agreed to try weekly planning with ARA‚Äù).\n\nIf you cannot decide a suitable type with reasonable confidence, DO NOT create the memory.\n\nIMPORTANCE & LIMITS\n\nimportance_score must be between 0.7 and 1.0.\n\nUse 0.9‚Äì1.0 only for very important, identity-level facts (family, core business, strong preferences).\n\nUse 0.7‚Äì0.8 for useful but lighter context.\n\nIf a fact feels minor or very temporary, do NOT save it at all.\n\nTry not to create more than 3 memories per turn. Pick the most useful ones.\n\nSCHEMA\n\nReturn a JSON array. Each memory object MUST have:\n\nmemory_type: \"preference\" | \"relationship\" | \"context\" | \"interaction\"\n\nmemory_key: a short snake_case key you invent (e.g. \"ali_color_preference\")\n\nmemory_value: the full fact in natural language\n\nimportance_score: 0.7‚Äì1.0\n\nentities:\n\n\"people\": [\"list\", \"of\", \"names\"] (real people or clear roles only)\n\n\"topics\": [\"keywords\", \"like\", \"reminder\", \"color\", \"meeting\"]\n\ntemporal_context: a simple string like \"today\" or an ISO date if explicitly mentioned.\n\nRESOLVING PRONOUNS\n\nIf the user says ‚Äúshe‚Äù, ‚Äúhe‚Äù, ‚Äúthat color‚Äù, etc., use ONLY the information in latest_user_message + assistant_response to interpret it.\n\nIf you cannot resolve it clearly to a specific person or thing, DO NOT save the memory.\n\nDUPLICATES\n\nIf the user repeats something you already know (for example: ‚ÄúAli likes green‚Äù) but adds no new detail, you may:\n\neither skip it, OR\n\ninclude it again with the same memory_value (the system will de-duplicate later).\n\nDO NOT assume something is updated unless the message clearly says the old info has changed.\n\nOUTPUT FORMAT\n\nOutput MUST be a valid JSON array.\n\nDO NOT wrap the JSON in ``` or any markdown.\n\nDO NOT include explanations, comments, or extra text.\n\nIf there is nothing useful to save, return exactly: []."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        1392,
        3280
      ],
      "id": "2a0cc67d-3cca-4431-95c9-b9b67b9c7300",
      "name": "Extract Memories",
      "executeOnce": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{ $('Format Context with Memory').item.json.is_continuing_session }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              },
              "id": "74ef4d44-2a94-431f-a49c-b470fc2a0996"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1744,
        3920
      ],
      "id": "86564225-3622-45c7-8a5c-eb50b51f5d2f",
      "name": "Session Ended?"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "40c674dd-ce02-4977-a627-ada421b19aaf"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "New User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "851aad05-d43c-49fa-8bed-adea56f65fe3",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "=free",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Free User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9d9e4661-e183-4451-89f6-3ec892be9164",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "smart",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Smart User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "15cd8d3d-d97a-4340-a7ef-ad8f3c9c4d5e",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "pro",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Pro User"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3344,
        3088
      ],
      "id": "e313bc02-ef9b-4594-9a12-1e47212ec8c1",
      "name": "Switch",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9ea260fe-5f67-4c13-85db-a8aff7ab65be",
                    "leftValue": "={{ (Date.now() - new Date($json.created_at).getTime()) / 60000 }}",
                    "rightValue": 30,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Within 30 Mins"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.session_id }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "13a1d046-89ee-4896-b133-7081657d0eec"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Never talked"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -2448,
        2048
      ],
      "id": "79a3eb8a-c5bc-44dd-9ddd-4079c4ab8c60",
      "name": "Session Manager"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $item(0).$node[\"Get User1\"].json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ Date.now() + '_' + Math.floor(Math.random() * 1000000) }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2224,
        2256
      ],
      "id": "dfba9728-a313-4e43-be99-924f8ab6b255",
      "name": "Create New Session",
      "alwaysOutputData": true,
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get User1').item.json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2224,
        2064
      ],
      "id": "f9f8ae4d-9a68-4cff-84cf-4a9a0fccaa3a",
      "name": "Continue Session",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "limit": 100,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2000,
        2064
      ],
      "id": "2eeded9c-6935-41fc-aa6e-f2192fded3ef",
      "name": "Fetch Session History",
      "alwaysOutputData": true,
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "// Get all input items\nconst items = $input.all();\n\n// Sort items by created_at in descending order (most recent first)\nitems.sort((a, b) => new Date(b.json.created_at) - new Date(a.json.created_at));\n\n// Take the first 1 item (latest 1)\nconst latestOne = items.slice(0, 1);\n\nreturn latestOne;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2672,
        3120
      ],
      "id": "45acebf0-e866-4e2a-8920-6495eadb11ea",
      "name": "Sort",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2896,
        3120
      ],
      "id": "16c73751-f8d6-49f9-b6ac-6ce32a7ae428",
      "name": "Get Previous Conversation",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ai_memories",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Get User1').item.json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2224,
        3312
      ],
      "id": "92efd7d4-e9bb-48e6-a202-35e1bc81c96f",
      "name": "Get User Memories",
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1776,
        3120
      ],
      "id": "b7ea8266-9b8b-4853-8629-7d7ccff1c2a5",
      "name": "Wait for Memory & Session"
    },
    {
      "parameters": {
        "jsCode": "// FORMAT CONTEXT WITH MEMORY (SAFE VERSION)\n// This node prepares \"ara_context\" for ARA Main Agent.\n// Mode: Run Once for All Items ‚úÖ\n\n// ============= BOOTSTRAP: CURRENT ITEM (IMPORTANT) =============\nconst current = $input.first()?.json ?? $json ?? {};\n\n// ============= SAFE HELPERS (IMPORTANT) =============\nfunction safeFirst(nodeName) {\n  try {\n    const arr = $items(nodeName);\n    return arr?.[0]?.json ?? null;\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction safeAll(nodeName) {\n  try {\n    const arr = $items(nodeName);\n    return (arr || []).map(i => i?.json ?? i).filter(Boolean);\n  } catch (e) {\n    return [];\n  }\n}\n\n// ============= STEP 1: ARA BRAIN =============\nlet araBrain = '';\ntry {\n  const brainNode = safeFirst('Format Brain');\n  if (brainNode?.brain_text) araBrain = brainNode.brain_text;\n} catch (e) {\n  // ignore\n}\n\n// ============= STEP 1.5: LOAD CONVERSATIONS =============\nconst convItems = safeAll('Wait for Memory & Session');\n\n// Flatten and sort oldest ‚Üí newest\nlet conversations = convItems\n  .filter(c => c && c.created_at)\n  .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));\n\nconst MAX_DETAILED = 12;\nconst detailedConversations = conversations.slice(-MAX_DETAILED);\nconst olderConversations = conversations.slice(0, Math.max(0, conversations.length - MAX_DETAILED));\n\nconst olderSummaries = olderConversations.map(c => {\n  const userMsg = c.user_message || '';\n  const assistantMsg = c.assistant_response || '';\n  const summaryField = c.session_summary || c.context_summary || null;\n\n  return {\n    id: c.id,\n    session_id: c.session_id || null,\n    created_at: c.created_at,\n    user_message_preview: userMsg.slice(0, 120),\n    assistant_response_summary: summaryField || assistantMsg.slice(0, 160),\n  };\n});\n\nconst lastConversation = conversations.length ? conversations[conversations.length - 1] : null;\n\nconst lastAssistant =\n  [...conversations].reverse().find(c => (c.assistant_response || '').trim() !== '') || null;\n\n// ============= STEP 2: LOAD USER + MEMORIES =============\nlet userData = {};\ntry {\n  userData = safeFirst('Get User1') || {};\n} catch (e) {\n  userData = {};\n}\n\nlet userMemories = [];\ntry {\n  const memNode = safeFirst('Get User Memories') || {};\n  userMemories = memNode.data || memNode.memories || [];\n} catch (e) {\n  userMemories = [];\n}\n\nconst importantMemories = userMemories.filter(m => {\n  const score = typeof m.importance_score === 'number' ? m.importance_score : 1;\n  return score >= 0.7;\n});\n\n// ============= STEP 3: CURRENT MESSAGE TEXT (DETERMINISTIC) =============\nfunction pickFirstText() {\n  // IMPORTANT: Continue Session might NOT run. Create New Session might run instead.\n  const cont = safeFirst('Continue Session');\n  const create = safeFirst('Create New Session');\n\n  const a = cont?.user_message;\n  if (typeof a === 'string' && a.trim()) return a.trim();\n\n  const a2 = create?.user_message;\n  if (typeof a2 === 'string' && a2.trim()) return a2.trim();\n\n  const b = safeFirst('Prepare Incoming Message')?.chatInput;\n  if (typeof b === 'string' && b.trim()) return b.trim();\n\n  const c = safeFirst('Twilio Webhook')?.body?.Body;\n  if (typeof c === 'string' && c.trim()) return c.trim();\n\n  const d = current?.user_message || current?.message || current?.text;\n  if (typeof d === 'string' && d.trim()) return d.trim();\n\n  return '';\n}\n\nconst currentText = pickFirstText();\nconst currentLower = (currentText || '').toLowerCase();\n\n// ============= STEP 3A: LANGUAGE DETECTION HELPERS =============\nfunction detectLangFromText(t = '') {\n  const s = (t || '').toLowerCase();\n  const msHits = /\\b(saya|awak|anda|boleh|tak|tidak|jangan|macam|kenapa|tq|terima kasih|semula|kejap|sekejap|nak|ingatkan|padam|perlu|tolong)\\b/i.test(s);\n  const enHits = /\\b(i|you|can|please|pls|thanks|thank you|again|later|now|what|why|sure|ok)\\b/i.test(s);\n\n  if (msHits && !enHits) return 'ms';\n  if (enHits && !msHits) return 'en';\n  if (msHits && enHits) return 'mixed';\n  return null;\n}\n\nfunction lastNonEmptyUserMsgFromHistory(convos) {\n  const c = [...(convos || [])].reverse().find(x => (x.user_message || '').trim() !== '');\n  return c?.user_message || '';\n}\n\nfunction langFromPreference(u) {\n  const pref = (u?.preferred_language || u?.language_preference || '').toString().toLowerCase();\n  if (pref.startsWith('ms') || pref.includes('bm') || pref.includes('malay')) return 'ms';\n  if (pref.startsWith('en')) return 'en';\n  if (pref.startsWith('id')) return 'id';\n  return null;\n}\n\nfunction emptyNudge(lang) {\n  if (lang === 'ms') return \"Hmm, saya tak dapat mesej tadi üòÖ\\nBoleh taip semula sikit?\";\n  if (lang === 'id') return \"Hmm, aku nggak nangkep pesan tadi üòÖ\\nBisa ketik ulang sebentar?\";\n  return \"Hmm, I didn‚Äôt catch that üòÖ\\nCould you type it again?\";\n}\n\n// ============= STEP 3B: REPLY LANGUAGE (DETERMINISTIC) =============\nlet replyLanguage = detectLangFromText(currentText);\n\nif (!replyLanguage) {\n  const lastUserMsg = lastNonEmptyUserMsgFromHistory(conversations);\n  replyLanguage = detectLangFromText(lastUserMsg);\n}\n\nif (!replyLanguage) replyLanguage = langFromPreference(userData);\nif (!replyLanguage) replyLanguage = 'en';\n\n// ============= STEP 3C: EMPTY MESSAGE GUARD =============\nif (!currentText) {\n  const lastUserMsg = lastNonEmptyUserMsgFromHistory(conversations);\n  const lang = detectLangFromText(lastUserMsg) || langFromPreference(userData) || 'en';\n\n  const minimalAraContext = {\n    reply_language: lang,\n    user: {\n      id: userData.id || null,\n      preferred_name: userData.preferred_name || null,\n      language_preference: userData.preferred_language || 'auto',\n      timezone: userData.current_timezone || userData.home_timezone || userData.timezone || 'Asia/Kuala_Lumpur',\n      home_timezone: userData.home_timezone || null,\n      current_timezone: userData.current_timezone || null,\n      style_profile: { ...(userData.style_profile || {}), language_mix_cap: 0.3 },\n    },\n    current_message: { text: '' },\n    history: {\n      detailed: detailedConversations.map(c => ({\n        created_at: c.created_at,\n        role: c.role || null,\n        user_message: c.user_message || '',\n        assistant_response: c.assistant_response || '',\n        session_id: c.session_id || null,\n      })),\n      older_summaries: olderSummaries,\n    },\n    memories: { important: importantMemories, all: userMemories },\n    last_assistant_message: lastAssistant ? { created_at: lastAssistant.created_at, text: lastAssistant.assistant_response || '' } : null,\n    dialogue_state: { isActiveResponse: false, activeResponseType: null, questionType: 'general', offerContext: null, pendingAction: null },\n  };\n\n  return [\n    {\n      json: {\n        ara_context: minimalAraContext,\n        assistant_response: emptyNudge(lang),\n        pending_action_type: 'none',\n        pending_action_payload: null,\n        ...current,\n      },\n    },\n  ];\n}\n\n// ============= STEP 4: PENDING ACTION & YES/NO DETECTION =============\nfunction isShortYesNo(text) {\n  if (!text) return null;\n  const t = text.trim().toLowerCase();\n  if (t.length === 0 || t.length > 40) return null;\n\n  const YES = ['yes','ya','yaaa','yup','ok','okay','okey','ok lah','okla','boleh','boleh je','proceed','confirm','set kan','buat','buat je','jom','ye','sure','baik','okey dokey'];\n  const NO  = ['no','tak','tak nak','tidak','jangan','nope','later','nanti','bukan sekarang','skip','tak payah','cancel','batal'];\n\n  if (YES.includes(t)) return 'yes';\n  if (NO.includes(t)) return 'no';\n  return null;\n}\n\nfunction isWithinHours(dateStr, hours) {\n  if (!dateStr) return false;\n  const then = new Date(dateStr).getTime();\n  const now = Date.now();\n  const diffH = (now - then) / (1000 * 60 * 60);\n  return diffH <= hours;\n}\n\nlet isActiveResponse = false;\nlet activeResponseType = null;\nlet questionType = 'general';\nlet offerContext = null;\nlet pendingAction = null;\n\nconst lastAssistantText = lastAssistant ? (lastAssistant.assistant_response || '') : '';\n\nif (lastAssistant) {\n  if (lastAssistant.pending_action_type && lastAssistant.pending_action_type !== 'none') {\n    pendingAction = {\n      type: lastAssistant.pending_action_type,\n      payload: lastAssistant.pending_action_payload || null,\n      resolved: !!lastAssistant.pending_action_resolved,\n      created_at: lastAssistant.created_at,\n    };\n  } else if (lastAssistantText) {\n    const match = lastAssistantText.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})\\s*$/);\n    if (match) {\n      try {\n        const pa = JSON.parse(match[1]);\n        if (pa.type && pa.type !== 'none') {\n          pendingAction = { type: pa.type, payload: pa.payload || null, resolved: false, created_at: lastAssistant.created_at };\n        }\n      } catch (e) {}\n    }\n  }\n}\n\nconst shortYesNo = isShortYesNo(currentText);\n\nif (pendingAction?.type && pendingAction.type !== 'none' && isWithinHours(pendingAction.created_at, 48) && shortYesNo) {\n  isActiveResponse = true;\n  activeResponseType = shortYesNo;\n  questionType = 'offer';\n  offerContext = pendingAction.type;\n}\n\nif (!isActiveResponse && lastAssistantText) {\n  const lastText = lastAssistantText.toLowerCase();\n\n  const hasQuestionMark = lastText.includes('?');\n  const hasOfferPattern = /would you like|nak tak|mahu tak|do you want|shall i|should i|may i|can i help|if you‚Äôd like|kalau nak/i.test(lastText);\n  const hasClarificationPattern = /could you clarify|apa yang dimaksud|what do you mean|which one do you mean|yang mana satu/i.test(lastText);\n  const hasConfirmationPattern = /is this correct|is that right|betul tak|setuju tak|confirm/i.test(lastText);\n  const hasChoicePattern = /\\bor\\b|atau\\b/i.test(lastText);\n\n  if (hasOfferPattern) questionType = 'offer';\n  else if (hasClarificationPattern) questionType = 'clarification';\n  else if (hasConfirmationPattern) questionType = 'confirmation';\n  else if (hasChoicePattern) questionType = 'choice';\n  else if (hasQuestionMark) questionType = 'general';\n\n  if (shortYesNo && (hasOfferPattern || hasConfirmationPattern || hasChoicePattern)) {\n    isActiveResponse = true;\n    activeResponseType = shortYesNo;\n    offerContext = hasOfferPattern ? 'offer' : hasConfirmationPattern ? 'confirmation' : 'choice';\n  }\n}\n\n// ============= STEP 5: BUILD ARA CONTEXT =============\nconst araContext = {\n  reply_language: replyLanguage,\n  user: {\n    id: userData.id || null,\n    name: userData.name || userData.full_name || null,\n    phone: userData.phone || userData.telegram_id || null,\n    preferred_name: userData.preferred_name || null,\n    language_preference: userData.preferred_language || 'auto',\n    features_enabled: userData.features_enabled || null,\n    timezone: userData.current_timezone || userData.home_timezone || userData.timezone || 'Asia/Kuala_Lumpur',\n    home_timezone: userData.home_timezone || null,\n    current_timezone: userData.current_timezone || null,\n    style_profile: { ...(userData.style_profile || {}), language_mix_cap: 0.3 },\n  },\n  current_message: { text: currentText, language_hint: null },\n  history: {\n    detailed: detailedConversations.map(c => ({\n      created_at: c.created_at,\n      role: c.role || null,\n      user_message: c.user_message || '',\n      assistant_response: c.assistant_response || '',\n      session_id: c.session_id || null,\n    })),\n    older_summaries: olderSummaries,\n  },\n  memories: { important: importantMemories, all: userMemories },\n  last_assistant_message: lastAssistant ? { created_at: lastAssistant.created_at, text: lastAssistant.assistant_response || '' } : null,\n  dialogue_state: { isActiveResponse, activeResponseType, questionType, offerContext, pendingAction },\n};\n\nreturn [\n  {\n    json: {\n      ara_context: araContext,\n      ...current,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1104,
        3120
      ],
      "id": "90d8bcd2-67f1-402c-a063-5f887b73ff49",
      "name": "Format Context with Memory"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e13dd0b2-6b72-4cc0-a466-e9677a549c1f",
              "leftValue": "={{ DateTime.fromISO($json.updated_at) < $today.minus({ days: 30 }) }}",
              "rightValue": "=",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3120,
        3216
      ],
      "id": "1c0f852b-33ce-479e-b623-78188af38675",
      "name": "Within 30 days?"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "telegram_id",
              "condition": "eq",
              "keyValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.WaId }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3792,
        2256
      ],
      "id": "2f93a553-ad58-4baf-bfd4-97a6e0297f8d",
      "name": "Get User1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Prepare Memories v2 - simpler, cleaner, per-turn\n// Input: array of validated memory objects (from Validate Memories)\n// Output: array of rows ready for ai_memories table\n\nconst input = $input.all().map(i => i.json);\nlet memories = input;\n\n// If someone wired it differently and we got a single array\nif (input.length === 1 && Array.isArray(input[0])) {\n  memories = input[0];\n}\n\nif (!memories || memories.length === 0) {\n  console.log('Prepare Memories: no memories to process');\n  return [];\n}\n\n// ===== Get user context =====\nlet userId = null;\ntry {\n  const userNode = $('Get User1').first();\n  if (userNode && userNode.json && userNode.json.id) {\n    userId = userNode.json.id;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get user ID', e);\n}\n\nif (!userId) {\n  console.log('Prepare Memories: missing user_id, aborting');\n  return [];\n}\n\n// ===== Get existing memories for this user =====\nlet existing = [];\ntry {\n  const rows = $('Get User Memories').all() || [];\n  existing = rows\n    .filter(r => r.json && r.json.memory_value)\n    .map(r => r.json);\n} catch (e) {\n  console.log('Prepare Memories: could not get existing memories', e);\n}\n\n// Build quick lookup structures\nconst existingByKey = {};\nconst existingByValue = new Map();\n\nexisting.forEach(mem => {\n  const key = (mem.memory_key || '').toLowerCase();\n  if (key) existingByKey[key] = mem;\n\n  const val = (mem.memory_value || '').toLowerCase().trim();\n  if (val) existingByValue.set(val, mem);\n});\n\n// ===== Helper: normalize base key =====\nconst slugify = (text) => {\n  return text\n    .toString()\n    .toLowerCase()\n    .normalize('NFKD')\n    .replace(/[^a-z0-9]+/g, '_')\n    .replace(/^_+|_+$/g, '');\n};\n\n// ===== Helper: generate unique key with versions =====\nconst versionCache = {}; // baseKey -> highest version\n\n// Initialize versionCache from existing keys\nObject.keys(existingByKey).forEach(k => {\n  const match = k.match(/^(.*)_v(\\d+)$/);\n  if (match) {\n    const base = match[1];\n    const v = parseInt(match[2], 10);\n    if (!versionCache[base] || v > versionCache[base]) {\n      versionCache[base] = v;\n    }\n  }\n});\n\nconst generateKey = (mem, index) => {\n  // Start from provided key if any\n  let base = mem.memory_key\n    ? slugify(mem.memory_key)\n    : slugify(mem.memory_value || `memory_${index}`);\n\n  // Attach first person if available\n  if (mem.entities && mem.entities.people && mem.entities.people.length > 0) {\n    const person = slugify(mem.entities.people[0]);\n    if (person && !base.includes(person)) {\n      base = `${person}_${base}`;\n    }\n  }\n\n  // Strip existing version suffix\n  base = base.replace(/_v\\d+$/, '');\n\n  const type = mem.memory_type || 'context';\n\n  if (type === 'preference' || type === 'context') {\n    // Versioned keys\n    const current = versionCache[base] || 0;\n    const next = current + 1;\n    versionCache[base] = next;\n    return `${base}_v${next}`;\n  }\n\n  if (type === 'relationship') {\n    // Relationship can be stable per session\n    const now = Date.now();\n    return `${base}_rel_${now}`;\n  }\n\n  if (type === 'interaction') {\n    const now = Date.now();\n    return `${base}_int_${now}`;\n  }\n\n  // Fallback\n  const now = Date.now();\n  return `${base}_${type}_${now}`;\n};\n\n// ===== Very simple similarity check (exact / near exact text) =====\nconst isDuplicateByValue = (value) => {\n  if (!value) return false;\n  const valLower = value.toLowerCase().trim();\n  if (existingByValue.has(valLower)) return true;\n  return false;\n};\n\n// ===== Session & timestamps =====\nlet sessionId = null;\ntry {\n  const ctx = $('Format Context with Memory').first();\n  if (ctx && ctx.json && ctx.json.ara_context && ctx.json.ara_context.history) {\n    sessionId = ctx.json.ara_context.history.detailed?.[0]?.session_id || null;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get session_id from context');\n}\n\nif (!sessionId) {\n  // Fallback session id\n  sessionId = `${Date.now()}_${Math.floor(Math.random() * 100000)}`;\n}\n\nconst nowIso = new Date().toISOString();\n\n// ===== Process memories =====\nconst prepared = [];\n\nmemories.forEach((mem, index) => {\n  if (!mem || !mem.memory_value) return;\n\n  // Skip if same value already exists\n  if (isDuplicateByValue(mem.memory_value)) {\n    console.log('Prepare Memories: skip duplicate by value:', mem.memory_value.substring(0, 60));\n    return;\n  }\n\n  const type = mem.memory_type || 'context';\n  const key = generateKey(mem, index);\n\n  const row = {\n    user_id: userId,\n    memory_type: type,\n    memory_key: key,\n    memory_value: mem.memory_value,\n    importance_score: mem.importance_score ?? 0.8,\n    session_id: sessionId,\n    conversation_date: nowIso,\n    entities: JSON.stringify(mem.entities || { people: [], topics: [] }),\n    temporal_context: mem.temporal_context || 'today',\n    is_active: true,\n    confidence_score: 1,\n    source: 'auto_extracted',\n    context_before: null,\n    context_after: null,\n  };\n\n  prepared.push(row);\n  console.log(`Prepare Memories: ACCEPTED ${key}`);\n});\n\nif (prepared.length === 0) {\n  console.log('Prepare Memories: no new memories after dedupe');\n}\n\nreturn prepared.map(r => ({ json: r }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        3280
      ],
      "id": "188cdd2f-3f9f-402e-9f3c-5dfe30e68c37",
      "name": "Prepare Memories1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "= {{ $json.user_id }}",
              "rightValue": 0,
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              },
              "id": "ebb88b93-4047-405f-9730-737ec9f4b782"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2192,
        3536
      ],
      "id": "26697973-d245-491f-b088-059b570c3332",
      "name": "Has Memories?1"
    },
    {
      "parameters": {
        "tableId": "ai_memories",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "memory_type",
              "fieldValue": "={{ $json.memory_type }}"
            },
            {
              "fieldId": "memory_key",
              "fieldValue": "={{ $json.memory_key }}"
            },
            {
              "fieldId": "memory_value",
              "fieldValue": "={{ $json.memory_value }}"
            },
            {
              "fieldId": "importance_score",
              "fieldValue": "={{ $json.importance_score }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "entities",
              "fieldValue": "={{ $json.entities }}"
            },
            {
              "fieldId": "temporal_context",
              "fieldValue": "={{ $json.temporal_context }}"
            },
            {
              "fieldId": "is_active",
              "fieldValue": "={{ $json.is_active }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2416,
        3536
      ],
      "id": "79988651-4611-42cf-9629-695b2c6067ab",
      "name": "Save Memories1"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Session Summary Generator v2\n// - Only summarizes completed sessions\n// - Skips very short/test sessions\n// - Produces richer, more structured summaries\n\nconst MIN_MESSAGES = 3;        // Require at least 3 messages in a session\nconst MIN_GAP_MINUTES = 15;    // Session must have ended at least 15 minutes ago\n\n// ---------- 1. Resolve user ID ----------\nlet userId;\n\ntry {\n  const ctx = $('Format Context with Memory').first();\n  if (ctx?.json?.user_id) {\n    userId = ctx.json.user_id;\n  }\n} catch (e) {\n  console.log('Could not get user ID from Format Context with Memory', e);\n}\n\nif (!userId) {\n  try {\n    const userNode = $('Get User1').first();\n    if (userNode?.json?.id) {\n      userId = userNode.json.id;\n    }\n  } catch (e) {\n    console.log('Could not get user ID from Get User1', e);\n  }\n}\n\n// If we still don't have a userId, we can't safely summarize\nif (!userId) {\n  console.log('No userId found, skipping session summary');\n  return [];\n}\n\n// ---------- 2. Get conversation history for this user ----------\nlet conversations = [];\ntry {\n  conversations = $('Fetch Session History').all() || [];\n} catch (e) {\n  console.log('Could not get conversations from Fetch Session History', e);\n  return [];\n}\n\n// Convert to plain JS objects and filter by this user (safety)\nconst allConversations = conversations\n  .map(c => c.json)\n  .filter(c => c && c.user_id === userId && c.session_id);\n\nif (allConversations.length < MIN_MESSAGES) {\n  console.log('Not enough conversations overall to summarize');\n  return [];\n}\n\n// Sort descending by created_at (newest first)\nallConversations.sort(\n  (a, b) => new Date(b.created_at) - new Date(a.created_at)\n);\n\n// ---------- 3. Work out current vs completed sessions ----------\nconst currentSessionId = allConversations[0].session_id;\nconsole.log('Current session ID:', currentSessionId);\n\nconst sessionsById = {};\nfor (const conv of allConversations) {\n  if (!sessionsById[conv.session_id]) {\n    sessionsById[conv.session_id] = [];\n  }\n  sessionsById[conv.session_id].push(conv);\n}\n\n// Remove the current session from candidates (we only want completed ones)\ndelete sessionsById[currentSessionId];\n\nconst candidateSessionIds = Object.keys(sessionsById);\nif (candidateSessionIds.length === 0) {\n  console.log('No completed sessions to summarize');\n  return [];\n}\n\n// ---------- 4. Pick the most recent completed session ----------\ncandidateSessionIds.sort((a, b) => {\n  const aRecent = Math.max(\n    ...sessionsById[a].map(c => new Date(c.created_at).getTime())\n  );\n  const bRecent = Math.max(\n    ...sessionsById[b].map(c => new Date(c.created_at).getTime())\n  );\n  return bRecent - aRecent;\n});\n\nconst sessionId = candidateSessionIds[0];\nconst sessionToSummarize = sessionsById[sessionId];\n\n// Ensure this session is ‚Äúreal‚Äù and not just a 1-message ping\nif (sessionToSummarize.length < MIN_MESSAGES) {\n  console.log(\n    `Session ${sessionId} has only ${sessionToSummarize.length} messages, skipping summary`\n  );\n  return [];\n}\n\n// Check how long ago this session ended\nconst mostRecentMessageTs = Math.max(\n  ...sessionToSummarize.map(c => new Date(c.created_at).getTime())\n);\nconst minutesSinceLastMessage =\n  (Date.now() - mostRecentMessageTs) / (1000 * 60);\n\nif (minutesSinceLastMessage < MIN_GAP_MINUTES) {\n  console.log(\n    `Session ${sessionId} ended only ${minutesSinceLastMessage.toFixed(\n      1\n    )} minutes ago, skipping summary`\n  );\n  return [];\n}\n\n// ---------- 5. Extract key info from this session ----------\nconst topics = new Set();\nconst people = new Set();\nconst decisions = [];\nlet firstUserMessage = null;\nlet lastUserMessage = null;\n\nfor (const conv of sessionToSummarize) {\n  if (!conv.user_message) continue;\n\n  const msg = conv.user_message;\n  const msgLower = msg.toLowerCase();\n\n  if (!firstUserMessage) firstUserMessage = msg;\n  lastUserMessage = msg;\n\n  // Topics (you can extend this list anytime)\n  if (msgLower.includes('staff') || msgLower.includes('hire') || msgLower.includes('recruit')) {\n    topics.add('hiring');\n  }\n  if (msgLower.includes('remind') || msgLower.includes('ingat')) {\n    topics.add('reminders');\n  }\n  if (msgLower.includes('meeting') || msgLower.includes('jumpa')) {\n    topics.add('meetings');\n  }\n  if (msgLower.includes('stok') || msgLower.includes('inventory')) {\n    topics.add('inventory');\n  }\n  if (msgLower.includes('duit') || msgLower.includes('bayar') || msgLower.includes('payment')) {\n    topics.add('money');\n  }\n\n  // Rough name detection (single capitalized words)\n  const namePattern = /\\b[A-Z][a-z]{2,}\\b/g;\n  const names = msg.match(namePattern) || [];\n  for (const name of names) {\n    if (!['I', 'Ara', 'ARA'].includes(name)) {\n      people.add(name);\n    }\n  }\n\n  // Decisions / plans (keep first 120 chars)\n  if (\n    msgLower.includes('need') ||\n    msgLower.includes('nak ') ||\n    msgLower.includes('akan ') ||\n    msgLower.includes('plan') ||\n    msgLower.includes('will')\n  ) {\n    decisions.push(msg.substring(0, 120));\n  }\n}\n\n// ---------- 6. Timing & meta info ----------\nsessionToSummarize.sort(\n  (a, b) => new Date(a.created_at) - new Date(b.created_at)\n);\nconst sessionStartTime = new Date(sessionToSummarize[0].created_at);\nconst sessionEndTime = new Date(\n  sessionToSummarize[sessionToSummarize.length - 1].created_at\n);\n\nconst dayOfWeekNames = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n];\nconst dayOfWeek = dayOfWeekNames[sessionStartTime.getDay()];\n\nconst hour = sessionStartTime.getHours();\nconst timeOfDay =\n  hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';\n\nconst durationMinutes = Math.max(\n  1,\n  Math.round((sessionEndTime - sessionStartTime) / (1000 * 60))\n);\n\n// ---------- 7. Build human-readable summary ----------\nlet summaryText = 'User ';\n\nif (topics.has('hiring')) {\n  summaryText += 'discussed getting help with hiring or staff issues';\n} else if (topics.size > 0) {\n  summaryText += `discussed ${Array.from(topics).join(', ')}`;\n} else {\n  summaryText += 'had a general conversation';\n}\n\nif (people.size > 0) {\n  summaryText += `, and mentioned ${Array.from(people).join(', ')}`;\n}\n\nsummaryText += `. Conversation lasted about ${durationMinutes} minute(s).`;\n\nif (decisions.length > 0) {\n  summaryText += ' Key decisions or needs were mentioned.';\n}\n\n// ---------- 8. Construct summary record ----------\nconst summary = {\n  user_id: userId,\n  session_id: sessionId,\n  conversation_date: sessionStartTime.toISOString(),\n  day_of_week: dayOfWeek,\n  time_of_day: timeOfDay,\n  summary: summaryText,\n  key_topics: Array.from(topics),\n  people_mentioned: Array.from(people),\n  decisions_made: decisions,\n  message_count: sessionToSummarize.length,\n  session_duration_minutes: durationMinutes,\n};\n\nconsole.log('Generated summary for completed session:', summary);\n\n// n8n expects an array of items: [{ json: ... }]\nreturn [{ json: summary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        3920
      ],
      "id": "b055e244-ce35-4bc0-b2bc-42dad267661f",
      "name": "Generate Session Summary1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "tableId": "conversation_summaries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "day_of_week",
              "fieldValue": "={{ $json.day_of_week }}"
            },
            {
              "fieldId": "time_of_day",
              "fieldValue": "={{ $json.time_of_day }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $json.summary }}"
            },
            {
              "fieldId": "key_topics",
              "fieldValue": "={{ $json.key_topics }}"
            },
            {
              "fieldId": "people_mentioned",
              "fieldValue": "={{ $json.people_mentioned }}"
            },
            {
              "fieldId": "decisions_made",
              "fieldValue": "={{ $json.decisions_made }}"
            },
            {
              "fieldId": "message_count",
              "fieldValue": "={{ $json.message_count }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2192,
        3920
      ],
      "id": "fdfd4d00-01c2-41ba-9aff-4e7a5d22d96c",
      "name": "Save Session Summary1"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $('Extract Pending Action').item.json.assistant_response }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $('Extract Pending Action').item.json.pending_action_type }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $('Extract Pending Action').item.json.pending_action_payload }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "false"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1456,
        3776
      ],
      "id": "b2947698-0865-4370-bd34-ed2c896c2773",
      "name": "Update Conversation",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "jsCode": "// Validate Memories (hardened)\n// Input: Whatever Extract Memories returns (can be JSON, string, or error envelope)\n// Output: array of clean memory objects as { json: ... }\n// If anything looks wrong, we just return [] and let the workflow continue safely.\n\nconst raw = $json;\n\n// 0) If upstream node failed and we got an error envelope, bail out safely.\nif (raw.error || raw.errorMessage || raw.errorDescription) {\n  console.log('Validate Memories: upstream error detected, skipping memories.');\n  return [];\n}\n\n// 1) Unwrap \"output\" if present\nlet memoriesRaw = raw.output ?? raw;\n\nlet memories = [];\n\ntry {\n  if (typeof memoriesRaw === 'string') {\n    let txt = memoriesRaw.trim();\n\n    // Strip accidental code fences\n    txt = txt\n      .replace(/^```json\\s*/i, '')\n      .replace(/^```\\s*/i, '')\n      .replace(/```$/i, '')\n      .trim();\n\n    const parsed = JSON.parse(txt);\n\n    if (Array.isArray(parsed)) {\n      memories = parsed;\n    } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.memories)) {\n      // Sometimes wrapped as { memories: [...] }\n      memories = parsed.memories;\n    } else {\n      memories = [parsed];\n    }\n\n  } else if (Array.isArray(memoriesRaw)) {\n    memories = memoriesRaw;\n\n  } else if (memoriesRaw && typeof memoriesRaw === 'object') {\n    // Maybe already { memories: [...] } or a single object\n    if (Array.isArray(memoriesRaw.memories)) {\n      memories = memoriesRaw.memories;\n    } else {\n      memories = [memoriesRaw];\n    }\n\n  } else {\n    console.log('Validate Memories: unsupported input type, skipping.');\n    return [];\n  }\n\n} catch (e) {\n  console.log('Validate Memories: failed to parse memories JSON, skipping.', e);\n  return [];\n}\n\nif (!Array.isArray(memories)) {\n  console.log('Validate Memories: parsed value is not an array, skipping.');\n  return [];\n}\n\nconst ALLOWED_TYPES = new Set(['preference', 'relationship', 'context', 'interaction']);\n\nconst cleaned = memories\n  .filter(m => m && typeof m === 'object')\n  .map((m, idx) => {\n    const mem = { ...m };\n\n    // Normalise memory_type\n    if (!ALLOWED_TYPES.has(mem.memory_type)) {\n      if (mem.memory_type === 'business/role') {\n        mem.memory_type = 'context';\n      } else {\n        mem.memory_type = 'context';\n      }\n    }\n\n    // Ensure text fields exist\n    mem.memory_value = (mem.memory_value || '').toString().trim();\n    mem.memory_key = (mem.memory_key || `memory_${idx}`).toString().trim();\n\n    // Default importance\n    const importance = Number(mem.importance_score ?? 0.8);\n    mem.importance_score = Number.isFinite(importance) ? importance : 0.8;\n\n    // Normalise entities\n    const entities = mem.entities || {};\n    mem.entities = {\n      people: Array.isArray(entities.people) ? entities.people : [],\n      topics: Array.isArray(entities.topics) ? entities.topics : [],\n    };\n\n    // Temporal context\n    mem.temporal_context = mem.temporal_context || 'today';\n\n    return mem;\n  })\n  .filter(mem => {\n    // Filter out junk (same rules as before)\n    if (!mem.memory_value || mem.memory_value.length < 10) return false;\n    if (mem.importance_score < 0.7) return false;\n    return true;\n  });\n\n// n8n expects an array of items: [{ json: ... }, ...]\nreturn cleaned.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1744,
        3280
      ],
      "id": "b7f81a80-d21a-43e2-a8aa-154b72311c00",
      "name": "Validate Memories"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {
          "maxTokens": 500,
          "temperature": 0.4
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        32,
        3616
      ],
      "id": "b32b8e71-2c0c-48c5-a5b6-417f6c20b8f2",
      "name": "OpenAI Chat Model"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "9999ca61-d7cf-4223-9d4d-a136399d11c6",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -5264,
        2160
      ],
      "id": "7d167692-b520-406f-9d66-33356a25e23e",
      "name": "Twilio Webhook",
      "webhookId": "9999ca61-d7cf-4223-9d4d-a136399d11c6"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e13dd0b2-6b72-4cc0-a466-e9677a549c1f",
              "leftValue": "={{ DateTime.fromISO($json.updated_at) < $today.minus({ days: 30 }) }}",
              "rightValue": "=",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3120,
        2064
      ],
      "id": "4ce69f6f-dce3-4d30-a745-6b4c5157630f",
      "name": "Within 30 days?1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "9ccbba93-3028-4b23-94a5-dc8ec1a53cd5",
              "name": "chatInput",
              "value": "={{$json.body.Body}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -4448,
        2160
      ],
      "id": "d2a3fb5e-8fe1-444a-9ae8-1881995e196a",
      "name": "Prepare Incoming Message"
    },
    {
      "parameters": {
        "tableId": "users",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "telegram_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "plan_type",
              "fieldValue": "free"
            },
            {
              "fieldId": "telegram_username",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.ProfileName }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -4208,
        2160
      ],
      "id": "5aa5b204-71fb-4232-ba13-4d92e7971412",
      "name": "Ensure User Exist",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ $items(\"Get Latest Conversation\")[0].json.telegram_chat_id }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        1168,
        3360
      ],
      "id": "05465905-bb4b-4afa-aef8-93acd3097c4e",
      "name": "Send Reply"
    },
    {
      "parameters": {
        "url": "https://jjeqmysluzsohwjpyvip.supabase.co/rest/v1/conversations",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ 'eq.' + $json.ara_context.user.id }}"
            },
            {
              "name": "order",
              "value": "created_at.desc"
            },
            {
              "name": "limit",
              "value": "1"
            },
            {
              "name": "select",
              "value": "*"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -208,
        3120
      ],
      "id": "dded951c-1756-4e3f-b4b0-e29fd83174cc",
      "name": "Get Latest Conversation"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract Pending Action (PATCHED - structured output + YES/NO override)\n// Input: $json.output is an OBJECT from Structured Output Parser\n// Output: preserves the SAME keys downstream expects:\n// - assistant_response\n// - pending_action_type\n// - pending_action_payload\n//\n// Behavior change ONLY when:\n// - user replies YES/NO\n// - AND a latest pending delete offer exists from node \"Get Latest Pending Offer\"\n// Then we override the LLM output deterministically.\n\nfunction safeString(v) {\n  return (v === null || v === undefined) ? \"\" : String(v);\n}\n\nfunction norm(s = \"\") {\n  return safeString(s).toLowerCase().trim();\n}\n\n// Keep strict + small list to avoid false positives.\n// You can expand later once stable.\nfunction isYes(s) {\n  const t = norm(s);\n  if (!t) return false;\n\n  // exact matches\n  const EXACT = new Set([\"yes\",\"y\",\"ya\",\"yah\",\"yup\",\"ok\",\"okay\",\"confirm\",\"setuju\",\"boleh\"]);\n  if (EXACT.has(t)) return true;\n\n  // starts-with patterns (covers: \"ok just nice\", \"ya boleh\", \"confirm ya\")\n  if (/^(ok|okay|ya|yes|yup|confirm|setuju|boleh)\\b/.test(t)) return true;\n\n  // contains word boundary (covers: \"alright ok\", \"can ok\")\n  if (/\\b(ok|okay|ya|yes|confirm|setuju|boleh)\\b/.test(t)) return true;\n\n  return false;\n}\n\nfunction isNo(s) {\n  const t = norm(s);\n  if (!t) return false;\n\n  const EXACT = new Set([\"no\",\"n\",\"tak\",\"tidak\",\"x\",\"cancel\",\"batal\",\"jangan\",\"nope\"]);\n  if (EXACT.has(t)) return true;\n\n  if (/^(no|tak|tidak|x|cancel|batal|jangan|nope)\\b/.test(t)) return true;\n  if (/\\b(no|tak|tidak|cancel|batal|jangan|nope)\\b/.test(t)) return true;\n\n  return false;\n}\nfunction parseMaybeJson(v) {\n  if (typeof v === \"string\") {\n    const s = v.trim();\n    if (!s) return null;\n    try { return JSON.parse(s); } catch (e) { return v; }\n  }\n  return v;\n}\n\n// --------------------\n// 1) Base LLM output (unchanged behavior)\n// --------------------\nconst o = $json.output ?? {};\nlet assistant_response = safeString(o.assistant_response ?? \"\").trim();\nlet pending_action_type = o.pending_action_type ?? \"none\";\nlet pending_action_payload = o.pending_action_payload ?? null;\n\n// Normalize payload if it came as JSON string\npending_action_payload = parseMaybeJson(pending_action_payload);\n\n// --------------------\n// 2) Detect current user text (for YES/NO)\n// --------------------\nconst currentText =\n  $json.user_message ??\n  $json.message ??\n  $json.text ??\n  $json.current_message?.text ??\n  \"\";\n\n// --------------------\n// 3) Attempt to load latest pending offer (optional)\n//    If node doesn't exist / returns nothing ‚Üí no override\n// --------------------\nlet offer = null;\ntry {\n  const offerItems = $items(\"Get Latest Pending Offer\") || [];\n  offer = offerItems[0]?.json ?? null;\n} catch (e) {\n  offer = null;\n}\n\nconst offerType = offer?.pending_action_type ?? null;\nlet offerPayload = parseMaybeJson(offer?.pending_action_payload ?? null);\n\n// --------------------\n// 4) Deterministic override for YES/NO confirmations\n//    ONLY for delete offers\n// --------------------\nconst yes = isYes(currentText);\nconst no = isNo(currentText);\n\n// Treat these as delete offers that require confirmation\nconst DELETE_OFFER_TYPES = new Set([\n  \"reminder_delete_offer\",\n  \"reminder_delete_all\",\n  \"reminder_delete_all_offer\"\n]);\n\nif ((yes || no) && offerType && DELETE_OFFER_TYPES.has(offerType)) {\n  // IMPORTANT: prevent LLM from claiming success before DB action\n  if (no) {\n    pending_action_type = \"none\";\n    pending_action_payload = null;\n    assistant_response = \"Okay ‚Äî canceled. No reminders were deleted.\";\n  } else if (yes) {\n    // Delete ALL ‚Üí reuse reminder_delete with delete_scope=all_active\n    if (offerType === \"reminder_delete_all\" || offerType === \"reminder_delete_all_offer\") {\n      pending_action_type = \"reminder_delete\";\n      pending_action_payload = { delete_scope: \"all_active\" };\n      assistant_response = \"Okay ‚Äî deleting all your active reminders now.\";\n    } else {\n      // Single delete offer ‚Üí carry reminder_id from offer payload\n      const rid =\n        offerPayload?.reminder_id ??\n        offerPayload?.id ??\n        null;\n\n      if (rid) {\n        pending_action_type = \"reminder_delete\";\n        pending_action_payload = { reminder_id: rid };\n        assistant_response = \"Okay ‚Äî deleting that reminder now.\";\n      } else {\n        // Safety fallback: don't execute a random delete\n        pending_action_type = \"none\";\n        pending_action_payload = null;\n        assistant_response = \"I couldn‚Äôt find which reminder to delete. Please try again.\";\n      }\n    }\n  }\n}\n\n// --------------------\n// 5) Return in the exact same structure as before\n// --------------------\nreturn {\n  ...$json,\n  assistant_response,\n  pending_action_type,\n  pending_action_payload,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        368,
        3120
      ],
      "id": "817307c4-908b-46e0-b38c-6289d08a5f29",
      "name": "Extract Pending Action"
    },
    {
      "parameters": {
        "jsCode": "// ROUTE CONFIRMED ACTIONS\n// -----------------------\n// INPUT EXPECTED (from Extract Pending Action + previous nodes):\n// - pending_action_type       (from THIS assistant reply's ARA_PENDING)\n// - pending_action_payload\n// - ara_context               (contains dialogue_state with pendingAction from DB)\n// - user_message              (latest user input)\n// - assistant_response        (for passing through to Send Reply)\n\nconst currentType = $json.pending_action_type || 'none';\nconst currentPayload = $json.pending_action_payload || null;\n\n// ara_context comes from \"Format Context with Memory\"\nconst araContext = $json.ara_context || {};\nconst ds = araContext.dialogue_state || {};\nconst pending = ds.pendingAction || null;\nconst isActiveResponse = !!ds.isActiveResponse;\nconst responseType = ds.activeResponseType || null;  // 'yes' | 'no' | null\n\nlet ARA_ACTION = {\n  type: 'none',\n  payload: null,\n};\n\n// CASE 1: User is replying YES/NO to an existing pendingAction\nif (\n  pending &&\n  pending.type &&\n  pending.type !== 'none' &&\n  isActiveResponse &&\n  (responseType === 'yes' || responseType === 'no')\n) {\n  if (responseType === 'yes') {\n    // Confirm the pending action (create/delete/update/...)\n    ARA_ACTION = {\n      type: pending.type,\n      payload: pending.payload || {},\n    };\n  } else if (responseType === 'no') {\n    // Cancel the pending action\n    ARA_ACTION = {\n      type: pending.type + '_cancel',\n      payload: pending.payload || {},\n    };\n  }\n} else {\n  // CASE 2: Immediate actions that do NOT require confirmation\n\n  // Example: escalate to human\n  if (currentType === 'escalate') {\n    ARA_ACTION = {\n      type: 'escalate',\n      payload: currentPayload || {},\n    };\n  }\n\n  // üîπ NEW: direct profile updates (no YES/NO roundtrip)\n  else if (currentType === 'user_update_profile') {\n    ARA_ACTION = {\n      type: 'user_update_profile',\n      payload: currentPayload || {},\n    };\n  }\n}\n\n// CASE 3: User profile updates (ARA_ACTION from main agent)\n// If the main agent outputs ARA_ACTION.update_user_preferences directly\n\n// ‚úÖ PATCH: rawOutput might be string (old) OR object (new)\nlet rawOutput = $json.output ?? $json.state ?? $json.text ?? $json.message ?? \"\";\n\n// If object, try common fields, else stringify\nif (typeof rawOutput === \"object\" && rawOutput !== null) {\n  if (typeof rawOutput.state === \"string\") rawOutput = rawOutput.state;\n  else if (typeof rawOutput.final_reply === \"string\") rawOutput = rawOutput.final_reply;\n  else rawOutput = JSON.stringify(rawOutput);\n}\n\nrawOutput = String(rawOutput);\n\n// Now safe to regex-match\nconst actionMatch = rawOutput.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\n\nif (actionMatch) {\n  try {\n    const parsedAction = JSON.parse(actionMatch[1]);\n\n    if (parsedAction.type === \"update_user_preferences\") {\n      // Build payload ONLY with non-null fields\n      const payload = {};\n\n      if (\n        typeof parsedAction.preferred_name === \"string\" &&\n        parsedAction.preferred_name.trim() !== \"\"\n      ) {\n        payload.preferred_name = parsedAction.preferred_name.trim();\n      }\n\n      if (\n        typeof parsedAction.preferred_language === \"string\" &&\n        parsedAction.preferred_language.trim() !== \"\"\n      ) {\n        payload.preferred_language = parsedAction.preferred_language.trim();\n      }\n\n      // Only overwrite ARA_ACTION if we have something real to update\n      if (Object.keys(payload).length > 0) {\n        ARA_ACTION = {\n          type: \"update_user_preferences\",\n          payload,\n        };\n      }\n      // else: no valid fields ‚Üí keep whatever ARA_ACTION was before\n    }\n  } catch (err) {\n    // ignore JSON parsing error, fall back to existing ARA_ACTION\n  }\n}\n\n\n// -----------------------------\n// SAFETY GUARDS (AILOOP PROTECT)\n// -----------------------------\n\n// 1) Whitelist allowed action types only\nconst allowedTypes = [\n  'none',\n  'reminder_create',\n  'reminder_delete',\n  'timezone_update',\n  'escalate',\n  'update_user_preferences',          // üîπ NEW\n\n  'reminder_create_cancel',\n  'reminder_delete_cancel',\n  'timezone_update_cancel',\n  'user_update_profile_cancel',   // optional future use\n];\n\nif (!allowedTypes.includes(ARA_ACTION.type)) {\n  ARA_ACTION = {\n    type: 'none',\n    payload: null,\n  };\n}\n\n// 2) Payload validation for specific actions\n\n// Reminder Create must have topic + suggested_time\nif (ARA_ACTION.type === 'reminder_create') {\n  const p = ARA_ACTION.payload || {};\n  const hasTopic =\n    typeof p.topic === 'string' && p.topic.trim().length > 0;\n  const hasTime =\n    typeof p.suggested_time === 'string' && p.suggested_time.trim().length > 0;\n\n  if (!hasTopic || !hasTime) {\n    // Invalid payload ‚Üí cancel action instead of firing broken data downstream\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Reminder Delete must have reminder_id\nif (ARA_ACTION.type === 'reminder_delete') {\n  const p = ARA_ACTION.payload || {};\n  const hasReminderId =\n    typeof p.reminder_id === 'string' && p.reminder_id.trim().length > 0;\n\n  if (!hasReminderId) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Timezone Update must have timezone + timezone_label\nif (ARA_ACTION.type === 'timezone_update') {\n  const p = ARA_ACTION.payload || {};\n  const hasTz =\n    typeof p.timezone === 'string' && p.timezone.trim().length > 0;\n  const hasLabel =\n    typeof p.timezone_label === 'string' && p.timezone_label.trim().length > 0;\n\n  if (!hasTz || !hasLabel) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Profile Update must have at least one field to update\nif (ARA_ACTION.type === 'user_update_profile') {\n  const p = ARA_ACTION.payload || {};\n  const updates = p.profile_updates || null;\n\n  const valid =\n    updates &&\n    typeof updates === 'object' &&\n    Object.keys(updates).length > 0;\n\n  if (!valid) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Preferences Update must have at least one field\nif (ARA_ACTION.type === 'update_user_preferences') {\n  const p = ARA_ACTION.payload || {};\n  const hasName = Object.prototype.hasOwnProperty.call(p, 'preferred_name');\n  const hasLang = Object.prototype.hasOwnProperty.call(p, 'preferred_language');\n\n  if (!hasName && !hasLang) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n\n\n// (We let 'escalate' and *_cancel pass even with minimal payload)\n\n// -----------------------------\n// Text back to user = assistant_response from previous node\n// -----------------------------\nconst final_reply = ($json.assistant_response || '').trim();\n\n// Safely pull the latest conversation row so we can attach ids\nconst latestItems = $items('Get Latest Conversation');\nconst latest = latestItems.length ? latestItems[0].json : {};\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Ensure these four are present from Get Latest Conversation\n  id: latest.id ?? $json.id,\n  user_id: latest.user_id ?? $json.user_id,\n  telegram_chat_id: latest.telegram_chat_id ?? $json.telegram_chat_id,\n  message_id: latest.message_id ?? $json.message_id,\n\n  ARA_ACTION,\n  final_reply,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        2064
      ],
      "id": "00097790-dc0f-49d3-b346-7391cf063099",
      "name": "Route Confirmed Actions"
    },
    {
      "parameters": {
        "tableId": "reminders",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "reminder_text",
              "fieldValue": "={{ $json.reminder_text }}"
            },
            {
              "fieldId": "reminder_time",
              "fieldValue": "={{ $json.reminder_time }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "{{ $now }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1968,
        1248
      ],
      "id": "2cccd27a-dba9-4f63-98dd-3814c4fd742a",
      "name": "Create Reminder"
    },
    {
      "parameters": {
        "jsCode": "// GET RELEVANT MEMORIES\n// This node reads all rows from \"Get User Memories\",\n// scores them by importance + recency, and returns\n// only the top N memories to the next node.\n\n// Make sure this node is set to:\n// - Mode: \"Run Once for All Items\"\n// - Language: JavaScript\n\n// 1) Safely get all items from \"Get User Memories\"\nlet memoryItems;\ntry {\n  memoryItems = $items('Get User Memories', 0, 0);\n} catch (e) {\n  // If node name is wrong or no items, fail gracefully\n  return [];\n}\n\n// If no memories, just return an empty list\nif (!Array.isArray(memoryItems) || memoryItems.length === 0) {\n  return [];\n}\n\nconst now = new Date();\n\n// 2) Convert & score each memory\nconst scoredMemories = memoryItems\n  .map(item => item.json)\n  .map(m => {\n    // Importance score (0‚Äì1, default 0.5)\n    const importance =\n      typeof m.importance_score === 'number'\n        ? m.importance_score\n        : 0.5;\n\n    // Recency score from temporal_context (if parseable as date)\n    let recencyScore = 0;\n    if (m.temporal_context) {\n      const parsed = Date.parse(m.temporal_context);\n      if (!isNaN(parsed)) {\n        const ageMs = now - new Date(parsed);\n        const ageDays = ageMs / (1000 * 60 * 60 * 24);\n        // Newer memories = higher score (ageDays small)\n        // Cap to avoid crazy values\n        const cappedAge = Math.min(Math.max(ageDays, -7), 365);\n        recencyScore = -cappedAge; // smaller age => higher score\n      }\n    }\n\n    // Memory type boost (preferences & relationships are more ‚Äúcore‚Äù)\n    const typeBoost =\n      m.memory_type === 'preference' || m.memory_type === 'relationship'\n        ? 1\n        : 0;\n\n    // Topic boost (reminders, customers, etc)\n    let topicBoost = 0;\n    try {\n      if (typeof m.entities === 'string') {\n        // entities is JSON string in your table\n        const ent = JSON.parse(m.entities);\n        const topics = Array.isArray(ent.topics) ? ent.topics.join(' ').toLowerCase() : '';\n        if (topics.includes('reminder')) topicBoost += 0.5;\n        if (topics.includes('customer')) topicBoost += 0.3;\n      }\n    } catch (e) {\n      // Ignore parsing errors, keep topicBoost = 0\n    }\n\n    // Final score (tweak weights as you like)\n    const score =\n      importance * 2 +      // importance is strong signal\n      typeBoost +           // preferences/relationships are sticky\n      topicBoost +          // domain-specific boost\n      recencyScore * 0.02;  // mild recency influence\n\n    return {\n      ...m,\n      _score: score,\n    };\n  });\n\n// 3) Sort by score (desc), then by created_at (desc)\nscoredMemories.sort((a, b) => {\n  if (b._score !== a._score) return b._score - a._score;\n  const ad = new Date(a.created_at || 0);\n  const bd = new Date(b.created_at || 0);\n  return bd - ad;\n});\n\n// 4) Limit how many memories to send forward\nconst MAX_MEMORIES = 20;\nconst selected = scoredMemories.slice(0, MAX_MEMORIES);\n\n// 5) Return in n8n format\nreturn selected.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2000,
        3312
      ],
      "id": "dfcbd893-3d06-4a63-85d4-a118215d2a24",
      "name": "Get Relevant Memories"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ara_brain_rules",
        "limit": 100,
        "filters": {
          "conditions": [
            {
              "keyName": "is_active",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1552,
        3120
      ],
      "id": "35fa987d-8ec2-4928-9c17-27bb8af3bcfd",
      "name": "Get ARA Brain",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Format ARA brain rows into a single text block (PRIORITY-SORTED)\n\n// Get all rows from previous node\nconst items = $input.all();\nlet rows = items.map(i => i.json).filter(r => r);\n\n// Keep only active rules (default true if missing)\nrows = rows.filter(r => r.is_active !== false);\n\n// Sort order:\n// 1) category (A‚ÜíZ)\n// 2) priority ASC (1 is strongest)\n// 3) subcategory (A‚ÜíZ)\n// 4) title (A‚ÜíZ)\nrows.sort((a, b) => {\n  const ca = (a.category || 'General').toString().toLowerCase();\n  const cb = (b.category || 'General').toString().toLowerCase();\n  if (ca !== cb) return ca.localeCompare(cb);\n\n  const pa = Number.isFinite(+a.priority) ? +a.priority : 1000;\n  const pb = Number.isFinite(+b.priority) ? +b.priority : 1000;\n  if (pa !== pb) return pa - pb;\n\n  const sa = (a.subcategory || '').toString().toLowerCase();\n  const sb = (b.subcategory || '').toString().toLowerCase();\n  if (sa !== sb) return sa.localeCompare(sb);\n\n  const ta = (a.title || '').toString().toLowerCase();\n  const tb = (b.title || '').toString().toLowerCase();\n  return ta.localeCompare(tb);\n});\n\n// Group by category (in sorted order)\nconst byCategory = new Map();\n\nfor (const row of rows) {\n  const category = (row.category || 'General').toString();\n  const sub = (row.subcategory || '').toString().trim();\n  const title = (row.title || '').toString().trim();\n  const content = (row.content || '').toString().trim();\n\n  if (!content) continue;\n\n  if (!byCategory.has(category)) byCategory.set(category, []);\n\n  // Label: keep compact but informative for debugging\n  // Examples:\n  // (capability_no_false_promises ‚Äî Never promise actions...) <content>\n  // or just (capability_no_false_promises) <content>\n  let label = '';\n  if (sub && title) label = `(${sub} ‚Äî ${title})`;\n  else if (sub) label = `(${sub})`;\n  else if (title) label = `(${title})`;\n\n  byCategory.get(category).push(`- ${label ? label + ' ' : ''}${content}`);\n}\n\n// Build the final brain text\nlet brainText = '';\n\nfor (const [category, lines] of byCategory.entries()) {\n  brainText += `\\n\\n[${category.toUpperCase()}]\\n` + lines.join('\\n');\n}\n\nbrainText = brainText.trim();\n\n// Return a single item with brain_text (same output shape as before)\nreturn [\n  {\n    json: {\n      brain_text: brainText,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1328,
        3120
      ],
      "id": "172cfd74-9774-4cb4-9a5c-0b94ac6da5ef",
      "name": "Format Brain"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.home_timezone }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "e7b487c6-4190-43b3-a402-4d93f58f1f90"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "No home time"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a14c596f-8821-4f43-8884-fc07dd2f95b4",
                    "leftValue": "",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "default"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3568,
        2160
      ],
      "id": "cf2929ee-2a4e-4ccb-8985-ed3da96a74bd",
      "name": "Check Time Zone"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3344,
        864
      ],
      "id": "88fb5b00-b5e2-4f98-a171-c95d003f7e36",
      "name": "Get Previous Conversation1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Get all input items\nconst items = $input.all();\n\n// Sort items by created_at in descending order (most recent first)\nitems.sort((a, b) => new Date(b.json.created_at) - new Date(a.json.created_at));\n\n// Take the first 1 item (latest 1)\nconst latestOne = items.slice(0, 1);\n\nreturn latestOne;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3120,
        864
      ],
      "id": "fb8e87f5-c023-47e2-a331-73ead925d6f5",
      "name": "Sort1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9ea260fe-5f67-4c13-85db-a8aff7ab65be",
                    "leftValue": "={{ (Date.now() - new Date($json.created_at).getTime()) / 60000 }}",
                    "rightValue": 30,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Within 30 Mins"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.session_id }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "13a1d046-89ee-4896-b133-7081657d0eec"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Never talked"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -2896,
        752
      ],
      "id": "01423668-9e80-4276-9983-4a21296ffe7b",
      "name": "Session Manager1"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $item(0).$node[\"Get User1\"].json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ Date.now() + '_' + Math.floor(Math.random() * 1000000) }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2672,
        1664
      ],
      "id": "e9ce999b-9557-4939-b0d5-d395e1f85f38",
      "name": "Create New Session1",
      "alwaysOutputData": true,
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get User1').item.json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}\n"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}\n"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2672,
        672
      ],
      "id": "aff4b314-fb7a-4f05-be60-7973247409be",
      "name": "Continue Session1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "limit": 100,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2448,
        768
      ],
      "id": "8e867b1b-e018-4a90-a309-3143893c8439",
      "name": "Fetch Session History2",
      "alwaysOutputData": true,
      "notesInFlow": false
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ai_memories",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Get User1').item.json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2672,
        1856
      ],
      "id": "b5ab488a-11d1-43f3-99de-68659820493f",
      "name": "Get User Memories1",
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2224,
        864
      ],
      "id": "347e723c-9ba7-40aa-9068-c3e09af7256f",
      "name": "Wait for Memory & Session1"
    },
    {
      "parameters": {
        "jsCode": "// GET RELEVANT MEMORIES\n// This node reads all rows from \"Get User Memories\",\n// scores them by importance + recency, and returns\n// only the top N memories to the next node.\n\n// Make sure this node is set to:\n// - Mode: \"Run Once for All Items\"\n// - Language: JavaScript\n\n// 1) Safely get all items from \"Get User Memories\"\nlet memoryItems;\ntry {\n  memoryItems = $items('Get User Memories1', 0, 0);\n} catch (e) {\n  // If node name is wrong or no items, fail gracefully\n  return [];\n}\n\n// If no memories, just return an empty list\nif (!Array.isArray(memoryItems) || memoryItems.length === 0) {\n  return [];\n}\n\nconst now = new Date();\n\n// 2) Convert & score each memory\nconst scoredMemories = memoryItems\n  .map(item => item.json)\n  .map(m => {\n    // Importance score (0‚Äì1, default 0.5)\n    const importance =\n      typeof m.importance_score === 'number'\n        ? m.importance_score\n        : 0.5;\n\n    // Recency score from temporal_context (if parseable as date)\n    let recencyScore = 0;\n    if (m.temporal_context) {\n      const parsed = Date.parse(m.temporal_context);\n      if (!isNaN(parsed)) {\n        const ageMs = now - new Date(parsed);\n        const ageDays = ageMs / (1000 * 60 * 60 * 24);\n        // Newer memories = higher score (ageDays small)\n        // Cap to avoid crazy values\n        const cappedAge = Math.min(Math.max(ageDays, -7), 365);\n        recencyScore = -cappedAge; // smaller age => higher score\n      }\n    }\n\n    // Memory type boost (preferences & relationships are more ‚Äúcore‚Äù)\n    const typeBoost =\n      m.memory_type === 'preference' || m.memory_type === 'relationship'\n        ? 1\n        : 0;\n\n    // Topic boost (reminders, customers, etc)\n    let topicBoost = 0;\n    try {\n      if (typeof m.entities === 'string') {\n        // entities is JSON string in your table\n        const ent = JSON.parse(m.entities);\n        const topics = Array.isArray(ent.topics) ? ent.topics.join(' ').toLowerCase() : '';\n        if (topics.includes('reminder')) topicBoost += 0.5;\n        if (topics.includes('customer')) topicBoost += 0.3;\n      }\n    } catch (e) {\n      // Ignore parsing errors, keep topicBoost = 0\n    }\n\n    // Final score (tweak weights as you like)\n    const score =\n      importance * 2 +      // importance is strong signal\n      typeBoost +           // preferences/relationships are sticky\n      topicBoost +          // domain-specific boost\n      recencyScore * 0.02;  // mild recency influence\n\n    return {\n      ...m,\n      _score: score,\n    };\n  });\n\n// 3) Sort by score (desc), then by created_at (desc)\nscoredMemories.sort((a, b) => {\n  if (b._score !== a._score) return b._score - a._score;\n  const ad = new Date(a.created_at || 0);\n  const bd = new Date(b.created_at || 0);\n  return bd - ad;\n});\n\n// 4) Limit how many memories to send forward\nconst MAX_MEMORIES = 20;\nconst selected = scoredMemories.slice(0, MAX_MEMORIES);\n\n// 5) Return in n8n format\nreturn selected.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2448,
        1856
      ],
      "id": "5dbe0cf3-75eb-47f1-8e6b-b2714fea825b",
      "name": "Get Relevant Memories1"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "home_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "current_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1456,
        2688
      ],
      "id": "294685ee-525c-4886-a583-da53c0ba5579",
      "name": "Update Timezone"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "46456542-8f2a-447d-b598-1713986577a7",
              "name": "user_name",
              "value": "={{    $node[\"Get User1\"].json.first_name    || $node[\"Get User1\"].json.telegram_username    || $json.telegram_chat_id  }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1456,
        2304
      ],
      "id": "e5ba659d-1195-4553-910f-96a50d3e559d",
      "name": "Get User name"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.twilio.com/2010-04-01/Accounts/AC_REDACTED/Messages.json",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "twilioApi",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "From",
              "value": "=whatsapp:+601125911400"
            },
            {
              "name": "To",
              "value": "whatsapp:+60105910037"
            },
            {
              "name": "ContentSid",
              "value": "HXce8e8c9580065acd9c86815c679a0dbe"
            },
            {
              "name": "ContentVariables",
              "value": "={{ JSON.stringify({\n  \"1\": $json.user_name,\n  \"2\": $('Route Confirmed Actions').item.json.telegram_chat_id,\n  \"3\": $('Route Confirmed Actions').item.json.ARA_ACTION.payload.reason\n       + \". \"\n       + $('Route Confirmed Actions').item.json.ARA_ACTION.payload.summary,\n  \"4\": $('Route Confirmed Actions').item.json.ARA_ACTION.payload.last_user_message,\n  \"5\": $now\n}) }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1744,
        2304
      ],
      "id": "976cfcae-367d-4046-8cef-57dc4572e7ae",
      "name": "Escalate"
    },
    {
      "parameters": {
        "tableId": "escalations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.user_id }}"
            },
            {
              "fieldId": "user_name",
              "fieldValue": "={{ $('Get User name').item.json.user_name }}"
            },
            {
              "fieldId": "user_phone",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.telegram_chat_id }}"
            },
            {
              "fieldId": "reason",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.reason }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.summary }}"
            },
            {
              "fieldId": "last_user_message",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.last_user_message }}"
            },
            {
              "fieldId": "urgency",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.urgency }}"
            },
            {
              "fieldId": "admin_phone",
              "fieldValue": "={{ '601136521251' }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "={{ 'open' }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1968,
        2304
      ],
      "id": "0583d4f9-1905-4d5c-a204-b8969da63a8b",
      "name": "Create Escalation Log"
    },
    {
      "parameters": {
        "jsCode": "const replyRaw = ($json.assistant_response || '').trim();\n\n// Simple language guess from latest user message (if available)\nconst userMsg = ($json.user_message || '').trim().toLowerCase();\n\nfunction buildFallback(msg) {\n  const hasMalayHints = /lah|tak|awak|saya|boleh|ingatkan|esok|pukul/.test(msg);\n  if (hasMalayHints) {\n    return \"Maaf, ada masalah teknikal sekejap. Cuba hantar semula mesej tadi ya. üôè\";\n  }\n  return \"Sorry, something went wrong on my side. Please send your last message again. üôè\";\n}\n\nlet safeReply = replyRaw;\nlet fallback_used = false;\n\nif (!safeReply) {\n  safeReply = buildFallback(userMsg);\n  fallback_used = true;\n}\n\n// Return everything + guaranteed reply text\nreturn {\n  ...$json,\n  assistant_response: safeReply,\n  fallback_used,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        3712
      ],
      "id": "47bf51d0-f719-444a-9862-003c0f185dc9",
      "name": "Prepare Reply (Fail-Safe)"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "event_type",
              "fieldValue": "incoming_message"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{   {     source: \"whatsapp\",     direction: \"inbound\",     message_id: $json.SmsMessageSid || $json.MessageSid || $json.message_id || null,     from: $json.From || $json.from || null,     to: $json.To || $json.to || null,     raw_body: $json.Body || $json.body || $json.user_message || \"\"   } }}"
            },
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3568,
        2352
      ],
      "id": "ec4b56ce-f513-44e8-b5d4-f928db2c6452",
      "name": "Log Incoming Message"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "reminder_created"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  type: \"reminder\",\n  action: \"created\",\n  reminder_id: $json.id || null,\n  reminder_text: $json.reminder_text || null,\n  reminder_time: $json.reminder_time || null,\n  is_sent: $json.is_sent\n} }}\n"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2192,
        1152
      ],
      "id": "619a95c7-37bc-474c-8998-3e2aae6be2d4",
      "name": "Log Reminder Created"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "memory_extracted"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {   source: \"whatsapp\",   type: \"memory\",   action: \"saved\",   memory_id: $json.id || null,   memory_category: $json.category || null,   memory_title: $json.title || null } }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2640,
        3536
      ],
      "id": "fd07c472-7281-4240-bd0b-0ea27207f5b6",
      "name": "Log Memory Extracted"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "fallback_triggered"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  scope: \"main_agent\",\n  reason: \"assistant_response_empty_or_invalid\",\n  last_user_message: $json.user_message || null\n} }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1456,
        3968
      ],
      "id": "79a1a515-919e-400e-ab11-d5be33c498e1",
      "name": "log Main Fallback"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.fallback_used }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "32a5b251-f43e-40f7-bda8-b82ec3edfbf7"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        1168,
        3968
      ],
      "id": "3c419253-797f-48ca-ba5a-a0828430e38d",
      "name": "IF Fallback Used?"
    },
    {
      "parameters": {
        "jsCode": "// This code cleans relative-day words from reminder topic\n// and leaves other flows untouched.\n\nconst RELATIVE_DAY_REGEX = /\\b(hari ini|esok|lusa|minggu depan|bulan depan|malam ini|pagi esok|today|tomorrow|tonight|next week|next month|this morning|this evening)\\b/gi;\n\nreturn items.map(item => {\n  const data = item.json || {};\n\n  let payload = data.pending_action_payload;\n\n  // Some flows store payload as JSON string, some as object\n  if (typeof payload === 'string') {\n    try {\n      payload = JSON.parse(payload);\n    } catch (e) {\n      // If parsing fails, just skip cleaning and pass through\n      item.json = data;\n      return item;\n    }\n  }\n\n  if (payload && typeof payload === 'object' && typeof payload.topic === 'string') {\n    payload.topic = payload.topic\n      .replace(RELATIVE_DAY_REGEX, '')   // remove relative-day words\n      .replace(/\\s+/g, ' ')             // collapse double spaces\n      .trim();\n  }\n\n  // Put payload back in its original shape\n  data.pending_action_payload = payload;\n\n  item.json = data;\n  return item;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1744,
        1248
      ],
      "id": "b51f6532-2c06-4f54-8aad-526075d17f82",
      "name": "Sanitise Reminder Topic"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE public.users\nSET\n  preferred_name = COALESCE(NULLIF($1::text, 'null'), preferred_name),\n  preferred_language = CASE\n    WHEN $2 IS NULL OR $2 = '__KEEP__' THEN preferred_language\n    ELSE $2\n  END\nWHERE id = $3;\n",
        "options": {
          "queryReplacement": "={{ $json.pending_action_payload?.preferred_name ?? null }}, {{ $json.pending_action_payload?.preferred_language === undefined ? '__KEEP__' : $json.pending_action_payload?.preferred_language }}\n, {{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1456,
        2496
      ],
      "id": "0e614a8b-bda1-4586-aea6-70b6d93c7e9d",
      "name": "PG ‚Äì Update user preferences"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Mixed-Offer Override (SAFE GUARDRAIL)\n// Run mode: \"Run Once for Each Item\"  ‚úÖ must return a SINGLE object (not an array)\n\nconst item = $json;\n\nconst currentType = (item.pending_action_type || 'none').toString();\n\n// Pass through if extractor already found an action\nif (currentType !== 'none') {\n  return item;\n}\n\nconst assistantText = (item.assistant_response || '').toString().trim();\nif (!assistantText) return item;\n\n// 1) Must look like a REMINDER offer (not generic offers)\nconst hasReminderWords = /\\b(remind|reminder|ingatkan|peringat)\\b/i.test(assistantText);\n\nconst hasOfferAsk =\n  /\\b(would you like me to|do you want me to|shall i|should i|can i|may i)\\b/i.test(assistantText) ||\n  /\\b(just to confirm|to confirm)\\b/i.test(assistantText) ||\n  /\\b(nak saya|mahu saya|boleh saya)\\b/i.test(assistantText);\n\nif (!hasReminderWords || !hasOfferAsk) {\n  return item;\n}\n\n// 2) Require explicit day anchor (no guessing dates)\nconst isTomorrow = /\\b(tomorrow|esok)\\b/i.test(assistantText);\nconst isToday = /\\b(today|harini|hari ini)\\b/i.test(assistantText);\nif (!isTomorrow && !isToday) return item;\n\n// 3) Extract clock time\nlet hour = null;\nlet minute = 0;\n\nlet m = assistantText.match(/\\b([01]?\\d|2[0-3])[:.](\\d{2})\\s*(am|pm)?\\b/i);\nif (m) {\n  hour = parseInt(m[1], 10);\n  minute = parseInt(m[2], 10);\n  const ampm = (m[3] || '').toLowerCase();\n  if (ampm === 'pm' && hour < 12) hour += 12;\n  if (ampm === 'am' && hour === 12) hour = 0;\n} else {\n  m = assistantText.match(/\\b([1-9]|1[0-2])\\s*(am|pm)\\b/i);\n  if (m) {\n    hour = parseInt(m[1], 10);\n    minute = 0;\n    const ampm = (m[2] || '').toLowerCase();\n    if (ampm === 'pm' && hour < 12) hour += 12;\n    if (ampm === 'am' && hour === 12) hour = 0;\n  }\n}\n\nif (hour === null) return item;\n\n// 4) Build suggested_time safely for +08 zones only\nconst tz = item?.ara_context?.user?.timezone || 'Asia/Kuala_Lumpur';\nconst plus8Zones = new Set(['Asia/Kuala_Lumpur', 'Asia/Kuching', 'Asia/Singapore']);\nif (!plus8Zones.has(tz)) return item;\n\nfunction pad2(n) { return String(n).padStart(2, '0'); }\n\nconst nowUtc = new Date();\nconst nowPlus8 = new Date(nowUtc.getTime() + 8 * 60 * 60 * 1000);\n\nlet y = nowPlus8.getUTCFullYear();\nlet mo = nowPlus8.getUTCMonth() + 1;\nlet d = nowPlus8.getUTCDate();\n\nif (isTomorrow) d += 1;\n\nconst suggested_time = `${y}-${pad2(mo)}-${pad2(d)}T${pad2(hour)}:${pad2(minute)}:00+08:00`;\n\n// 5) Topic extraction (SAFE): derive from THIS assistant offer sentence, not history\nlet topic = null;\n\n// Try English \"about <topic>\" pattern\nlet t = assistantText.match(/\\babout\\s+(.+?)(\\?|$)/i);\nif (t && t[1]) {\n  topic = t[1].trim();\n}\n\n// Try Malay \"pasal/mengenai/tentang <topic>\" pattern\nif (!topic) {\n  t = assistantText.match(/\\b(pasal|mengenai|tentang)\\s+(.+?)(\\?|$)/i);\n  if (t && t[2]) topic = t[2].trim();\n}\n\n// Clean trailing filler words\nif (topic) {\n  topic = topic.replace(/\\s+(right|ya|betul)\\s*$/i, '').trim();\n}\n\n// Fallback 1: use current user message text (still safer than scanning long history)\nif (!topic) {\n  topic = (item?.ara_context?.current_message?.text || item?.user_message || '').toString().trim();\n}\n\n// Fallback 2: safe snippet of assistant\nif (!topic) {\n  topic = assistantText.slice(0, 120);\n}\n\n\n// Apply override\nreturn {\n  ...item,\n  pending_action_type: 'reminder_offer',\n  pending_action_payload: {\n    topic,\n    suggested_time,\n  },\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        592,
        2064
      ],
      "id": "6f78dc02-5ef7-47e0-97e3-8671676fb773",
      "name": "Mixed-Offer Override"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"assistant_response\": { \"type\": \"string\" },\n    \"pending_action_type\": { \"type\": \"string\" },\n    \"pending_action_payload\": { \"type\": [\"object\", \"null\"] }\n  },\n  \"required\": [\"assistant_response\", \"pending_action_type\", \"pending_action_payload\"],\n  \"additionalProperties\": true\n}\n",
        "autoFix": true
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        144,
        3344
      ],
      "id": "f0a75c15-9e66-4e14-b70e-d6d96fbefeae",
      "name": "Structured Output Parser",
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "// Normalize reminder delete payloads into 1-item-per-target outputs\n// ‚úÖ Keeps existing behavior (single + bulk + numbered ids)\n// ‚úÖ NEW: supports delete_scope = all_active/all by emitting reminder_id = \"all\"\n\nconst out = [];\n\nfor (const item of $input.all()) {\n  const j = item.json || {};\n  const p = j.pending_action_payload ?? j.output?.pending_action_payload ?? {};\n\n  // ---------- NEW: DELETE ALL ----------\n  // If agent says delete_scope: \"all_active\" (or \"all\"), emit a single routing token.\n  const scope = (p.delete_scope ?? \"\").toString().toLowerCase().trim();\n  if (scope === \"all_active\" || scope === \"all\") {\n    out.push({\n      json: {\n        reminder_id: \"all\",\n        // keep for safety filter downstream\n        user_id: p.user_id || j.user_id || null,\n      },\n    });\n    continue; // don't also attempt id extraction\n  }\n\n  // ---------- EXISTING: EXTRACT IDS ----------\n  let ids = [];\n\n  // Case 1: array already provided\n  if (Array.isArray(p.reminder_ids)) {\n    ids = p.reminder_ids;\n\n  // Case 2: comma-separated string\n  } else if (typeof p.reminder_ids === \"string\") {\n    ids = p.reminder_ids.split(\",\").map((s) => s.trim());\n\n  // Case 3: single id\n  } else if (p.reminder_id) {\n    ids = [p.reminder_id];\n\n  // Case 4: reminder_id_1, reminder_id_2, reminder_id_3 ... reminder_id_N\n  } else {\n    ids = Object.keys(p)\n      .filter((k) => /^reminder_id_\\d+$/.test(k))\n      .sort(\n        (a, b) => Number(a.split(\"_\").pop()) - Number(b.split(\"_\").pop())\n      )\n      .map((k) => p[k]);\n  }\n\n  // Emit one n8n item per reminder id\n  for (const id of ids.filter(Boolean)) {\n    out.push({\n      json: {\n        reminder_id: id,\n        user_id: j.user_id || p.user_id || null, // keep for safety filter\n      },\n    });\n  }\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1744,
        2112
      ],
      "id": "5631f900-9a36-4add-bbac-f8eeec9c688d",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "reminders",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.reminder_id }}"
            },
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2192,
        3168
      ],
      "id": "5fa5ad64-6994-4875-a234-097a43989a7a",
      "name": "Delete Reminder"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "58254766-51ec-4ad3-ab34-2928e9b7d44c",
              "leftValue": "={{ $json.reminder_id }}",
              "rightValue": "all",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1968,
        2112
      ],
      "id": "eb195e01-f8f2-4895-91ea-4594648540a6",
      "name": "If ALL?"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "reminders",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Code in JavaScript').item.json.user_id }}"
            },
            {
              "keyName": "is_sent",
              "condition": "eq",
              "keyValue": "={{ false }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2192,
        2544
      ],
      "id": "80ca383b-abf0-40d7-b5c8-d0dc17862921",
      "name": "Delete ALL"
    },
    {
      "parameters": {
        "jsCode": "// Explode Reminder (FIXED)\n// Supports BOTH:\n// 1) Bulk: pending_action_payload.reminders = [{topic, suggested_time}, ...]\n// 2) Single: pending_action_payload = {topic, suggested_time}\n\nconst base = $json;\n\nconst payload =\n  base.pending_action_payload ||\n  base.output?.pending_action_payload ||\n  null;\n\nlet reminders = [];\n\nif (payload && Array.isArray(payload.reminders) && payload.reminders.length > 0) {\n  reminders = payload.reminders;\n} else if (payload && payload.topic && payload.suggested_time) {\n  reminders = [{ topic: payload.topic, suggested_time: payload.suggested_time }];\n} else {\n  return [];\n}\n\nconst user_id = base.user_id;\nconst telegram_chat_id = base.telegram_chat_id;\nconst session_id = base.session_id;\nconst message_id = base.message_id;\n\nreturn reminders.map((r, idx) => ({\n  json: {\n    source_message_id: message_id,\n    source_session_id: session_id,\n    batch_index: idx,\n\n    user_id,\n    reminder_text: r.topic,\n    reminder_time: r.suggested_time,\n    is_sent: false,\n\n    telegram_chat_id,\n  }\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1456,
        1248
      ],
      "id": "0401ed75-c39a-48d8-bdb8-53fa7014f76f",
      "name": "Explode Reminder"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_create",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0001"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Create"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_list",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0002"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "List"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete_request",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0003"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete Request"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7effae48-3c8b-445c-bdaf-8043843459f1",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f18fc6df-6c26-4714-ba28-fa4560fcec67",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "escalate",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Escalate"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "602c304b-fae9-4ee9-aea5-3622eea25845",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "timezone_update",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update timezone"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "959a4996-035d-4e07-951b-9fe19d261d98",
                    "leftValue": "={{ $json.pending_action_type || $json.output?.pending_action_type || \"\" }}",
                    "rightValue": "update_user_preferences",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update User Profile"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        1168,
        1984
      ],
      "id": "4e7a6590-5053-48a4-84fd-968d7aae81ee",
      "name": "Route Actions Switch2"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "reminders",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            },
            {
              "keyName": "is_sent",
              "condition": "eq",
              "keyValue": "={{ false }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1456,
        1728
      ],
      "id": "3219a124-5520-42d5-b5f1-952effca082a",
      "name": "List Reminders",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "leftValue": "={{ $('Route Actions Switch2').item.json.output.pending_action_type }}",
              "rightValue": "reminder_list",
              "operator": {
                "type": "string",
                "operation": "equals"
              },
              "id": "acb1dea8-5ea5-49f6-aaee-a44cdb995471"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1744,
        1632
      ],
      "id": "af97be29-f06a-470f-9746-6fc1c2db3245",
      "name": "IF Reminder List?"
    },
    {
      "parameters": {
        "jsCode": "// Format Reminder List (human WhatsApp style)\n// Mode: Run Once for All Items ‚úÖ\n// Input items = rows from \"List Reminders\" node\n\nfunction getTelegramChatId() {\n  // You said Route Actions Switch2 has it ‚Äî keep that as primary\n  const v =\n    $items('Route Actions Switch2')?.[0]?.json?.telegram_chat_id ||\n    $items('Route Confirmed Actions')?.[0]?.json?.telegram_chat_id ||\n    $items('Get Latest Conversation')?.[0]?.json?.telegram_chat_id ||\n    $items('Route Actions Switch')?.[0]?.json?.telegram_chat_id ||\n    null;\n\n  return v ? String(v).trim() : null;\n}\n\nfunction getPreferredLanguage() {\n  // Safest: pull from Get User1 node output\n  const u = $items('Get User1')?.[0]?.json ?? {};\n  return (u.preferred_language || 'en').toString().toLowerCase();\n}\n\nfunction getUserTimezone() {\n  // Try to use ara_context first, else fall back to Malaysia\n  const tz =\n    $json?.ara_context?.user?.current_timezone ||\n    $json?.ara_context?.user?.timezone ||\n    $items('Get User1')?.[0]?.json?.current_timezone ||\n    $items('Get User1')?.[0]?.json?.timezone ||\n    'Asia/Kuala_Lumpur';\n  return tz;\n}\n\nfunction formatDateHeader(d, lang, timeZone) {\n  // Example: Tue, 27 Jan\n  const locale =\n    lang === 'ms' ? 'ms-MY' :\n    lang === 'id' ? 'id-ID' :\n    'en-MY';\n\n  return new Intl.DateTimeFormat(locale, {\n    timeZone,\n    weekday: 'short',\n    day: '2-digit',\n    month: 'short',\n  }).format(d);\n}\n\nfunction formatTime12h(d, lang, timeZone) {\n  // Example: 3:00 PM\n  const locale =\n    lang === 'ms' ? 'en-MY' :   // Malay users usually still prefer \"3:00 PM\" formatting\n    lang === 'id' ? 'en-ID' :\n    'en-MY';\n\n  return new Intl.DateTimeFormat(locale, {\n    timeZone,\n    hour: 'numeric',\n    minute: '2-digit',\n    hour12: true,\n  }).format(d);\n}\n\nfunction getText(lang, key) {\n  const dict = {\n    en: {\n      title: \"Here are your reminders:\",\n      none: \"You don‚Äôt have any active reminders yet.\",\n      tip: \"If you want, just type: ‚ÄúRemind me to ‚Ä¶ at ‚Ä¶‚Äù\",\n    },\n    ms: {\n      title: \"Ini reminder awak:\",\n      none: \"Buat masa sekarang, tak ada reminder yang aktif lagi.\",\n      tip: \"Kalau nak set, boleh taip: ‚ÄúIngatkan saya ‚Ä¶ pukul ‚Ä¶‚Äù\",\n    },\n    id: {\n      title: \"Ini daftar pengingat kamu:\",\n      none: \"Saat ini kamu belum punya pengingat yang aktif.\",\n      tip: \"Kalau mau set, ketik: ‚ÄúIngatkan saya ‚Ä¶ jam ‚Ä¶‚Äù\",\n    },\n  };\n  return (dict[lang] && dict[lang][key]) ? dict[lang][key] : dict.en[key];\n}\n\n// --------------------\n// Main\n// --------------------\nconst telegram_chat_id = getTelegramChatId();   // ‚úÖ PATCH: always carry forward\nconst lang = getPreferredLanguage();            // en | ms | id\nconst timeZone = getUserTimezone();\n\n// All DB rows from List Reminders\nconst rows = items.map(i => i.json).filter(r => r && r.reminder_time);\n\n// No reminders case\nif (!rows.length) {\n  const assistant_response = `${getText(lang, 'none')}\\n${getText(lang, 'tip')}`;\n  return [{\n    json: {\n      ...($json || {}),\n      telegram_chat_id, // ‚úÖ PATCH\n      assistant_response,\n      // IMPORTANT: stop re-triggering list\n      pending_action_type: \"none\",\n      pending_action_payload: null,\n    }\n  }];\n}\n\n// Sort by reminder_time ascending\nrows.sort((a, b) => new Date(a.reminder_time).getTime() - new Date(b.reminder_time).getTime());\n\n// Group by date (YYYY-MM-DD in user's timezone)\nfunction dateKey(d) {\n  const parts = new Intl.DateTimeFormat('en-CA', {\n    timeZone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(d);\n\n  const y = parts.find(p => p.type === 'year')?.value;\n  const m = parts.find(p => p.type === 'month')?.value;\n  const da = parts.find(p => p.type === 'day')?.value;\n  return `${y}-${m}-${da}`;\n}\n\nconst groups = new Map();\nfor (const r of rows) {\n  const d = new Date(r.reminder_time);\n  const key = dateKey(d);\n  if (!groups.has(key)) groups.set(key, []);\n  groups.get(key).push({ ...r, _date: d });\n}\n\n// Build WhatsApp message\nlet lines = [];\nlines.push(getText(lang, 'title'));\n\nfor (const [, list] of groups.entries()) {\n  // Date header\n  const headerDate = list[0]._date;\n  lines.push(`\\n${formatDateHeader(headerDate, lang, timeZone)}`);\n\n  // Items\n  for (const r of list) {\n    const t = formatTime12h(r._date, lang, timeZone);\n    const text = (r.reminder_text || '').toString().trim() || '(no title)';\n    lines.push(`- ${t} ‚Äî ${text}`);\n  }\n}\n\nconst assistant_response = lines.join('\\n');\n\nreturn [{\n  json: {\n    ...($json || {}),\n    telegram_chat_id, // ‚úÖ PATCH\n    assistant_response,\n    // IMPORTANT: stop re-triggering list\n    pending_action_type: \"none\",\n    pending_action_payload: null,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        1536
      ],
      "id": "e21377d4-8ae5-4903-99bc-ba5d41b3c00c",
      "name": "Format Reminder List Message"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ $json.telegram_chat_id }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        2640,
        1968
      ],
      "id": "d0ce801a-0fee-4978-a8b1-9a4006d0f798",
      "name": "Send Reply - Reminder List"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2192,
        1968
      ],
      "id": "2e450154-8f3b-4ccb-929a-70b1661a5b19",
      "name": "Merge"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2416,
        1968
      ],
      "id": "59fdde5b-050d-47c8-be3b-9e2ea9ed1753",
      "name": "Wait",
      "webhookId": "14c98e44-d618-4c22-b334-7c1c116462d2"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Merge').item.json.user_id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Merge').item.json.telegram_chat_id }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $json.body }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $('Get Latest Conversation').first().json.session_id }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "TRUE"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2864,
        1968
      ],
      "id": "60039e1a-e324-4d7c-882b-9bbeb7f5ced4",
      "name": "Update Conversation2",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Delete Offer (WhatsApp-friendly, Auto Language EN/MS/ID)\n// ‚úÖ Fix: filters out empty reminder rows like {} so \"no reminders\" works properly\n// ‚úÖ PATCH: if agent clue indicates \"delete all reminders\" (EN/MS/ID), ask for bulk confirmation\n//          and emit pendingAction.type = \"reminder_delete_all_offer\"\n\nfunction norm(s = \"\") {\n  return s\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\nfunction pickLang(raw) {\n  const s = (raw || \"\").toString().toLowerCase().trim();\n  if (!s) return \"en\";\n  if (s === \"bm\") return \"ms\";\n  if (s.startsWith(\"ms\") || s.includes(\"melayu\") || s.includes(\"bahasa malaysia\")) return \"ms\";\n  if (s.startsWith(\"id\") || s.includes(\"indonesia\") || s.includes(\"bahasa indonesia\")) return \"id\";\n  if (s.startsWith(\"en\") || s.includes(\"english\")) return \"en\";\n  return \"en\";\n}\n\nconst I18N = {\n  en: {\n    header_label: \"Your active reminders\",\n    none: \"‚úÖ You don‚Äôt have any active reminders right now.\",\n    ask_number: \"Reply with the *number* you want to delete. (Example: *2*)\",\n    confirm_title: \"üóëÔ∏è Delete this reminder?\",\n    confirm_yesno: \"Reply *yes* to confirm or *no* to cancel.\",\n    list_emoji: \"üìå\",\n    bulk_warn: \"‚ö†Ô∏è This will delete *ALL* your active reminders.\",\n  },\n  ms: {\n    header_label: \"Peringatan aktif anda\",\n    none: \"‚úÖ Anda tiada peringatan aktif buat masa ini.\",\n    ask_number: \"Balas dengan *nombor* yang anda nak padam. (Contoh: *2*)\",\n    confirm_title: \"üóëÔ∏è Padam peringatan ini?\",\n    confirm_yesno: \"Balas *ya* untuk sahkan atau *tidak* untuk batal.\",\n    list_emoji: \"üìå\",\n    bulk_warn: \"‚ö†Ô∏è Ini akan padam *SEMUA* peringatan aktif anda.\",\n  },\n  id: {\n    header_label: \"Pengingat aktif kamu\",\n    none: \"‚úÖ Kamu tidak punya pengingat aktif saat ini.\",\n    ask_number: \"Balas dengan *nomor* yang ingin kamu hapus. (Contoh: *2*)\",\n    confirm_title: \"üóëÔ∏è Hapus pengingat ini?\",\n    confirm_yesno: \"Balas *ya* untuk konfirmasi atau *tidak* untuk batal.\",\n    list_emoji: \"üìå\",\n    bulk_warn: \"‚ö†Ô∏è Ini akan menghapus *SEMUA* pengingat aktif kamu.\",\n  },\n};\n\nfunction fmtGmtOffset(tz) {\n  const sample = new Date();\n  const parts = new Intl.DateTimeFormat(\"en-US\", {\n    timeZone: tz,\n    timeZoneName: \"shortOffset\",\n    hour: \"2-digit\",\n  }).formatToParts(sample);\n\n  const off = parts.find(p => p.type === \"timeZoneName\")?.value || \"\";\n  return off.replace(\"GMT\", \"GMT\");\n}\n\nfunction friendlyCity(tz) {\n  const map = {\n    \"Asia/Kuala_Lumpur\": \"Kuala Lumpur\",\n    \"Asia/Singapore\": \"Singapore\",\n    \"Asia/Jakarta\": \"Jakarta\",\n    \"Asia/Bangkok\": \"Bangkok\",\n  };\n  return map[tz] || tz.replace(/_/g, \" \");\n}\n\nfunction formatWhen(iso, tz, lang) {\n  if (!iso) return \"(time not set)\";\n  const d = new Date(iso);\n  const locale = lang === \"ms\" ? \"ms-MY\" : lang === \"id\" ? \"id-ID\" : \"en-GB\";\n\n  const day = new Intl.DateTimeFormat(locale, { timeZone: tz, weekday: \"short\" }).format(d);\n  const date = new Intl.DateTimeFormat(locale, { timeZone: tz, day: \"2-digit\", month: \"short\" }).format(d);\n  const time = new Intl.DateTimeFormat(locale, {\n    timeZone: tz,\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  }).format(d);\n\n  return `${day}, ${date} ‚Ä¢ ${time}`;\n}\n\n// ‚úÖ PATCH: detect bulk delete intent across EN/MS/ID regardless of UI language\nfunction isDeleteAllIntent(extracted, queryText) {\n  const s = norm(`${extracted || \"\"} ${queryText || \"\"}`);\n\n  const patterns = [\n    // EN\n    \"delete all\",\n    \"delete all reminders\",\n    \"delete my reminders\",\n    \"remove all\",\n    \"remove all reminders\",\n    \"clear all\",\n    \"clear reminders\",\n    \"clear all reminders\",\n    // MS\n    \"padam semua\",\n    \"padam semua peringatan\",\n    \"hapus semua\",\n    \"hapus semua peringatan\",\n    \"buang semua\",\n    \"buang semua peringatan\",\n    \"delete semua\",\n    \"delete semua peringatan\",\n    \"delete semua reminder\",\n    // ID\n    \"hapus semua pengingat\",\n    \"hapus semua pengingatku\",\n    \"delete semua pengingat\",\n  ];\n\n  // Token fallback: (all/semua) + (reminder/peringatan/pengingat)\n  const hasAll = s.includes(\"all\") || s.includes(\"semua\");\n  const hasReminderWord =\n    s.includes(\"reminder\") ||\n    s.includes(\"reminders\") ||\n    s.includes(\"peringatan\") ||\n    s.includes(\"pengingat\");\n\n  if (hasAll && hasReminderWord) return true;\n\n  return patterns.some(p => s.includes(norm(p)));\n}\n\n// --- Get user + timezone + language safely ---\nconst u = $items(\"Get User1\")?.[0]?.json ?? {};\nconst lang = pickLang(u.preferred_language || $json?.preferred_language || \"en\");\nconst t = I18N[lang] || I18N.en;\n\nconst tz =\n  ($json?.ara_context?.current_timezone ||\n    $json?.ara_context?.home_timezone ||\n    u.current_timezone ||\n    u.home_timezone ||\n    \"Asia/Kuala_Lumpur\"\n  ).toString();\n\n// --- Header with city + tz ---\nconst city = friendlyCity(tz);\nconst gmt = fmtGmtOffset(tz);\nconst header = `üïí *${city} (${gmt})*`;\n\n// --- Agent payload (for matching) ---\nconst agentOut = $items(\"ARA Main Agent\")?.[0]?.json?.output ?? {};\nconst req = agentOut.pending_action_payload || {};\nconst extracted = norm(req.extracted_topic || \"\");\nconst queryText = norm(req.query_text || \"\");\n\n// ‚úÖ PATCH: delete-all intent\nconst wantsDeleteAll = isDeleteAllIntent(extracted, queryText);\n\n// --- Reminders from input (‚úÖ CLEAN + FILTER) ---\nconst raw = $input.all().map(i => i.json ?? {});\n\n// Keep only reminders that actually look like reminders\n// Accept if it has id OR reminder_text OR reminder_time\nconst reminders = raw\n  .filter(r => r && typeof r === \"object\")\n  .filter(r => {\n    const hasId = !!(r.id && String(r.id).trim());\n    const hasText = !!(r.reminder_text && String(r.reminder_text).trim());\n    const hasTime = !!(r.reminder_time && String(r.reminder_time).trim());\n    return hasId || hasText || hasTime;\n  })\n  // Normalize fields so list never shows undefined\n  .map(r => ({\n    ...r,\n    reminder_text: (r.reminder_text ?? \"\").toString().trim(),\n    reminder_time: (r.reminder_time ?? \"\").toString().trim(),\n    id: (r.id ?? \"\").toString().trim(),\n  }))\n  // Optional: drop rows that still have no useful content\n  .filter(r => r.reminder_text || r.reminder_time || r.id);\n\n// ‚úÖ If none after cleaning\nif (!reminders.length) {\n  const assistant_response = `${header}\\n\\n${t.none}`;\n  return [{ json: { assistant_response, pendingAction: null } }];\n}\n\n// Build list (WhatsApp style)\nconst listLines = reminders.map((r, i) => {\n  const when = formatWhen(r.reminder_time, tz, lang);\n  const text = r.reminder_text || \"(no title)\";\n  return `*${i + 1})* ${text}\\n   _${when}_`;\n});\n\nlet assistant_response =\n  `${header}\\n\\n` +\n  `${t.list_emoji} *${t.header_label}*\\n` +\n  listLines.join(\"\\n\\n\");\n\n// ‚úÖ PATCH: bulk delete confirmation flow\nif (wantsDeleteAll) {\n  const candidates = reminders\n    .filter(r => r.id)\n    .map(r => ({\n      id: r.id,\n      reminder_text: r.reminder_text,\n      reminder_time: r.reminder_time,\n    }));\n\n  if (!candidates.length) {\n    assistant_response =\n      `${header}\\n\\n` +\n      `‚ö†Ô∏è I found reminders, but they‚Äôre missing IDs so I can‚Äôt delete them safely.`;\n    return [{ json: { assistant_response, pendingAction: null } }];\n  }\n\n  assistant_response +=\n    `\\n\\n${t.confirm_title}\\n` +\n    `${t.bulk_warn}\\n\\n` +\n    `${t.confirm_yesno}`;\n\n  return [\n    {\n      json: {\n        assistant_response,\n        pendingAction: {\n          type: \"reminder_delete_all\",\n          payload: {\n            candidates,\n            count: candidates.length,\n          },\n        },\n      },\n    },\n  ];\n}\n\n// --- Match scoring (single reminder intent) ---\nconst scored = reminders\n  .map(r => {\n    const rt = norm(r.reminder_text || \"\");\n    let score = 0;\n\n    if (extracted && rt.includes(extracted)) score += 5;\n\n    if (queryText) {\n      const words = queryText.split(\" \").filter(w => w.length >= 3);\n      score += words.filter(w => rt.includes(w)).length;\n    }\n\n    return { r, score };\n  })\n  .sort((a, b) => b.score - a.score);\n\nconst best = scored[0];\n\n// If no match / ambiguous ‚Üí ask for number (but only include valid candidates with ids)\nif ((best.score || 0) === 0) {\n  assistant_response += `\\n\\n${t.ask_number}`;\n\n  const candidates = reminders\n    .filter(r => r.id) // critical: only pass deletable rows\n    .map(r => ({\n      id: r.id,\n      reminder_text: r.reminder_text,\n      reminder_time: r.reminder_time,\n    }));\n\n  // If somehow none have ids, don't go into select mode\n  if (!candidates.length) {\n    assistant_response =\n      `${header}\\n\\n` +\n      `‚ö†Ô∏è I found reminders, but they‚Äôre missing IDs so I can‚Äôt delete them safely.`;\n    return [{ json: { assistant_response, pendingAction: null } }];\n  }\n\n  return [\n    {\n      json: {\n        assistant_response,\n        pendingAction: {\n          type: \"reminder_delete_select\",\n          payload: { candidates },\n        },\n      },\n    },\n  ];\n}\n\n// Offer delete confirmation (single best match)\nconst bestWhen = formatWhen(best.r.reminder_time, tz, lang);\nconst bestText = best.r.reminder_text || \"(no title)\";\n\nassistant_response +=\n  `\\n\\n${t.confirm_title}\\n` +\n  `‚Ä¢ *${bestText}*\\n` +\n  `  _${bestWhen}_\\n\\n` +\n  `${t.confirm_yesno}`;\n\nreturn [\n  {\n    json: {\n      assistant_response,\n      pendingAction: {\n        type: \"reminder_delete_offer\",\n        payload: {\n          reminder_id: best.r.id,\n          reminder_text: bestText,\n          reminder_time: best.r.reminder_time,\n        },\n      },\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1968,
        1728
      ],
      "id": "3a102ac2-0e91-43ae-ac02-f3cbaad3c9a3",
      "name": "Build Delete Offer"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ $('Get User1').first().json.telegram_id ? ('+' + $('Get User1').first().json.telegram_id.replace(/^\\+/, '')) : '' }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        2640,
        2160
      ],
      "id": "38fc55c8-e4bc-47c5-ad01-6a7af8e8be0b",
      "name": "Send Reply - Delete Confirmation"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2192,
        2160
      ],
      "id": "045f4329-ca6a-45d2-928e-659e1c401cd1",
      "name": "Merge1"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2416,
        2160
      ],
      "id": "8bd7955e-d8d1-4d9f-85b2-5cbbee4f6cea",
      "name": "Wait1",
      "webhookId": "ba724d32-b4aa-4688-88a2-f28c0924958a"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('IF Reminder List?').first().json.user_id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Route Confirmed Actions').first().json.telegram_chat_id }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $('Send Reply - Delete Confirmation').first().json.sid }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $json.body }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $('Build Delete Offer').first().json.pendingAction?.type || null }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $('Build Delete Offer').first().json.pendingAction?.payload || null }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "={{ false }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $('Get Latest Conversation').first().json.session_id }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2864,
        2160
      ],
      "id": "3ed8cebc-5a51-4cb4-99ac-fe91b1dbdede",
      "name": "Update Conversation3",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Delete Confirmation (WhatsApp-friendly, Auto Language EN/MS/ID)\n// Input items = rows returned by Supabase Delete node (1 or many deleted reminders)\n// Output = single item { assistant_response, pendingAction: null }\n\nfunction pickLang(raw) {\n  const s = (raw || \"\").toString().toLowerCase().trim();\n  if (!s) return \"en\";\n  if (s === \"bm\") return \"ms\";\n  if (s.startsWith(\"ms\") || s.includes(\"melayu\") || s.includes(\"bahasa malaysia\")) return \"ms\";\n  if (s.startsWith(\"id\") || s.includes(\"indonesia\") || s.includes(\"bahasa indonesia\")) return \"id\";\n  if (s.startsWith(\"en\") || s.includes(\"english\")) return \"en\";\n  return \"en\";\n}\n\nconst I18N = {\n  en: {\n    ok_single: \"‚úÖ Done ‚Äî I‚Äôve deleted this reminder:\",\n    ok_multi: \"‚úÖ Done ‚Äî I‚Äôve deleted these reminders:\",\n    none: \"‚úÖ Nothing to delete ‚Äî I couldn‚Äôt find any matching active reminders.\",\n    list_emoji: \"üóëÔ∏è\",\n  },\n  ms: {\n    ok_single: \"‚úÖ Selesai ‚Äî saya dah padam peringatan ini:\",\n    ok_multi: \"‚úÖ Selesai ‚Äî saya dah padam peringatan-peringatan ini:\",\n    none: \"‚úÖ Tiada apa untuk dipadam ‚Äî saya tak jumpa peringatan aktif yang sepadan.\",\n    list_emoji: \"üóëÔ∏è\",\n  },\n  id: {\n    ok_single: \"‚úÖ Beres ‚Äî aku sudah hapus pengingat ini:\",\n    ok_multi: \"‚úÖ Beres ‚Äî aku sudah hapus pengingat-pengingat ini:\",\n    none: \"‚úÖ Tidak ada yang dihapus ‚Äî aku tidak menemukan pengingat aktif yang cocok.\",\n    list_emoji: \"üóëÔ∏è\",\n  },\n};\n\nfunction fmtGmtOffset(tz) {\n  try {\n    const sample = new Date();\n    const parts = new Intl.DateTimeFormat(\"en-US\", {\n      timeZone: tz,\n      timeZoneName: \"shortOffset\",\n      hour: \"2-digit\",\n    }).formatToParts(sample);\n    const off = parts.find(p => p.type === \"timeZoneName\")?.value || \"\";\n    return off.replace(\"GMT\", \"GMT\");\n  } catch (e) {\n    return \"GMT\";\n  }\n}\n\nfunction friendlyCity(tz) {\n  const map = {\n    \"Asia/Kuala_Lumpur\": \"Kuala Lumpur\",\n    \"Asia/Singapore\": \"Singapore\",\n    \"Asia/Jakarta\": \"Jakarta\",\n    \"Asia/Bangkok\": \"Bangkok\",\n  };\n  return map[tz] || (tz || \"Asia/Kuala_Lumpur\").replace(/_/g, \" \");\n}\n\nfunction formatWhen(iso, tz, lang) {\n  if (!iso) return \"(time not set)\";\n  const d = new Date(iso);\n  const locale = lang === \"ms\" ? \"ms-MY\" : lang === \"id\" ? \"id-ID\" : \"en-GB\";\n\n  const day = new Intl.DateTimeFormat(locale, { timeZone: tz, weekday: \"short\" }).format(d);\n  const date = new Intl.DateTimeFormat(locale, { timeZone: tz, day: \"2-digit\", month: \"short\" }).format(d);\n  const time = new Intl.DateTimeFormat(locale, {\n    timeZone: tz,\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  }).format(d);\n\n  return `${day}, ${date} ‚Ä¢ ${time}`;\n}\n\n// --- Get user + timezone + language safely ---\nconst u = $items(\"Get User1\")?.[0]?.json ?? {};\nconst lang = pickLang(u.preferred_language || $json?.preferred_language || \"en\");\nconst t = I18N[lang] || I18N.en;\n\nconst tz =\n  ($json?.ara_context?.current_timezone ||\n    $json?.ara_context?.home_timezone ||\n    u.current_timezone ||\n    u.home_timezone ||\n    \"Asia/Kuala_Lumpur\"\n  ).toString();\n\n// --- Header with city + tz ---\nconst city = friendlyCity(tz);\nconst gmt = fmtGmtOffset(tz);\nconst header = `üïí *${city} (${gmt})*`;\n\n// --- Deleted rows from Supabase Delete output ---\nconst raw = $input.all().map(i => i.json ?? {});\nconst deleted = raw\n  .filter(r => r && typeof r === \"object\")\n  .filter(r => {\n    const hasId = !!(r.id && String(r.id).trim());\n    const hasText = !!(r.reminder_text && String(r.reminder_text).trim());\n    const hasTime = !!(r.reminder_time && String(r.reminder_time).trim());\n    return hasId || hasText || hasTime;\n  })\n  .map(r => ({\n    id: (r.id ?? \"\").toString().trim(),\n    reminder_text: (r.reminder_text ?? \"\").toString().trim(),\n    reminder_time: (r.reminder_time ?? \"\").toString().trim(),\n  }));\n\n// --- If nothing returned, treat as nothing deleted ---\nif (!deleted.length) {\n  const assistant_response = `${header}\\n\\n${t.none}`;\n  return [{ json: { assistant_response, pendingAction: null } }];\n}\n\n// --- Compose confirmation message ---\nlet assistant_response = `${header}\\n\\n`;\nassistant_response += deleted.length === 1 ? t.ok_single : t.ok_multi;\n\n// WhatsApp list\nconst listLines = deleted.map((r, i) => {\n  const text = r.reminder_text || \"(no title)\";\n  const when = formatWhen(r.reminder_time, tz, lang);\n  return `*${i + 1})* ${text}\\n   _${when}_`;\n});\n\nassistant_response += `\\n${t.list_emoji}\\n\\n` + listLines.join(\"\\n\\n\");\n\nreturn [{ json: { assistant_response, pendingAction: null } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2416,
        2544
      ],
      "id": "ced4fe86-1543-4543-a259-b638eb61b595",
      "name": "Build Delete Confirm"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ $('Get User1').first().json.telegram_id ? ('+' + $('Get User1').first().json.telegram_id.replace(/^\\+/, '')) : '' }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        2640,
        2544
      ],
      "id": "51de80e9-b83b-4038-a791-ab5e504bfaa6",
      "name": "Send Delete Confirmation"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1456,
        2112
      ],
      "id": "9f68b998-c986-402d-9470-ce3af7e5ed89",
      "name": "Merge2"
    },
    {
      "parameters": {
        "jsCode": "// PATCH: Dialogue-state promotion for short confirmations like \"Sure\"\n// Place AFTER \"Format Context with Memory\"\n// Mode: Run Once for All Items ‚úÖ\n\nconst item = $input.first();\nconst j = item?.json ?? {};\nconst ctx = j.ara_context ?? {};\n\n// Helpers\nfunction norm(s = \"\") {\n  return s.toLowerCase().replace(/[\\u200B-\\u200D\\uFEFF]/g, \"\").trim();\n}\n\nfunction isShortYesNo(text) {\n  const t = norm(text);\n  if (!t || t.length > 40) return null;\n\n  const YES = new Set([\n    \"yes\",\"ya\",\"yaa\",\"yaaa\",\"yup\",\"ok\",\"okay\",\"okey\",\"ok lah\",\"okla\",\"boleh\",\n    \"boleh je\",\"proceed\",\"confirm\",\"setkan\",\"set kan\",\"buat\",\"buat je\",\"jom\",\"ye\",\n    \"sure\",\"baik\",\"okey dokey\",\"continue\",\"go on\",\"tell me\",\"more\",\"pls\",\"please\"\n  ]);\n\n  const NO = new Set([\n    \"no\",\"tak\",\"tak nak\",\"tidak\",\"jangan\",\"nope\",\"later\",\"nanti\",\n    \"bukan sekarang\",\"skip\",\"tak payah\",\"cancel\",\"batal\"\n  ]);\n\n  if (YES.has(t)) return \"yes\";\n  if (NO.has(t)) return \"no\";\n  return null;\n}\n\n// Detect if last assistant message looks like an offer/question that expects a short reply\nfunction lastAssistantExpectsReply(lastText = \"\") {\n  const s = norm(lastText);\n  if (!s) return false;\n\n  // Strong signals\n  const hasQuestionMark = s.includes(\"?\");\n  const offerPatterns = [\n    /what would you like to know\\b/i,\n    /would you like\\b/i,\n    /do you want\\b/i,\n    /if you want\\b/i,\n    /if you'd like\\b/i,\n    /i can also\\b/i,\n    /shall i\\b/i,\n    /should i\\b/i,\n    /may i\\b/i,\n    /\\bcan i\\b.*\\bhelp\\b/i,\n    /\\bboleh\\b/i,\n    /\\bnak\\b/i,\n    /\\bmahu\\b/i,\n    /\\bsetuju\\b/i,\n    /\\bsahkan\\b/i\n  ];\n\n  if (hasQuestionMark) return true;\n  return offerPatterns.some(r => r.test(s));\n}\n\n// --- Start patch logic ---\nconst currentText = ctx?.current_message?.text ?? j.user_message ?? \"\";\nconst lastAssistantText =\n  ctx?.last_assistant_message?.text ??\n  ctx?.history?.last_assistant_message?.text ??\n  \"\";\n\n// Keep whatever Format Context decided, unless we have a strong reason to promote\nconst ds = ctx.dialogue_state ?? {};\nlet isActiveResponse = !!ds.isActiveResponse;\nlet activeResponseType = ds.activeResponseType ?? null;\nlet questionType = ds.questionType ?? \"general\";\nlet offerContext = ds.offerContext ?? null;\n\n// Only promote when:\n// - Not already active response\n// - Current message is a short yes/no\n// - Last assistant message likely expects a reply\nif (!isActiveResponse) {\n  const yn = isShortYesNo(currentText);\n  if (yn && lastAssistantExpectsReply(lastAssistantText)) {\n    isActiveResponse = true;\n    activeResponseType = yn;\n\n    // If it was a yes/no to an offer, classify as offer-ish\n    questionType = ds.questionType && ds.questionType !== \"general\" ? ds.questionType : \"offer\";\n    offerContext = ds.offerContext ?? \"offer\";\n  }\n}\n\n// Write back to ara_context safely\nctx.dialogue_state = {\n  ...ds,\n  isActiveResponse,\n  activeResponseType,\n  questionType,\n  offerContext,\n};\n\n// Optional tiny debug (safe to remove later)\n// j._debug_dialogue_patch = { currentText, lastAssistantText, isActiveResponse, activeResponseType, questionType, offerContext };\n\nj.ara_context = ctx;\n\nreturn [{ json: j }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -544,
        3120
      ],
      "id": "79b216b8-9b9e-4e99-8125-7b68bf338d1a",
      "name": "Patch Dialogue State"
    },
    {
      "parameters": {
        "jsCode": "function pad2(n) { return String(n).padStart(2, '0'); }\n\n// KL = UTC+8\nfunction klNow() {\n  const now = new Date();\n  const utcMs = now.getTime() + now.getTimezoneOffset() * 60000;\n  const klMs = utcMs + 8 * 3600000;\n  const d = new Date(klMs);\n\n  const yyyy = d.getUTCFullYear();\n  const mm = d.getUTCMonth() + 1;\n  const dd = d.getUTCDate();\n  const hh = d.getUTCHours();\n  const mi = d.getUTCMinutes();\n  const ss = d.getUTCSeconds();\n\n  return {\n    yyyy, mm, dd,\n    current_date_local: `${yyyy}-${pad2(mm)}-${pad2(dd)}`,\n    current_datetime_local: `${yyyy}-${pad2(mm)}-${pad2(dd)}T${pad2(hh)}:${pad2(mi)}:${pad2(ss)}+08:00`,\n    timezone: \"Asia/Kuala_Lumpur\",\n  };\n}\n\nfunction extractTargetDay(text) {\n  if (!text) return null;\n  // first 1‚Äì31 number found\n  const m = String(text).match(/\\b([1-9]|[12][0-9]|3[01])\\b/);\n  return m ? Number(m[1]) : null;\n}\n\nfunction nextDayOfMonth(yyyy, mm, dd, targetDay) {\n  let y = yyyy, m = mm;\n  if (dd >= targetDay) {\n    m += 1;\n    if (m === 13) { m = 1; y += 1; }\n  }\n  return `${y}-${pad2(m)}-${pad2(targetDay)}`;\n}\n\n// Deep merge helper (simple + safe for plain objects)\nfunction mergeDeep(base, patch) {\n  const out = { ...(base || {}) };\n  for (const [k, v] of Object.entries(patch || {})) {\n    if (v && typeof v === \"object\" && !Array.isArray(v)) {\n      out[k] = mergeDeep(out[k], v);\n    } else {\n      out[k] = v;\n    }\n  }\n  return out;\n}\n\nreturn $input.all().map(item => {\n  const j = item.json || {};\n  const ara = j.ara_context || {};\n\n  const text =\n    ara?.current_message?.text ??\n    j.user_message ??\n    j.message ??\n    j.text ??\n    \"\";\n\n  const now = klNow();\n  const targetDay = extractTargetDay(text) ?? 14;\n\n  const computedPatch = {\n    next_day_of_month_local: nextDayOfMonth(now.yyyy, now.mm, now.dd, targetDay),\n    target_day_of_month: targetDay,\n  };\n\n  const araPatch = {\n    now: {\n      timezone: now.timezone,\n      current_date_local: now.current_date_local,\n      current_datetime_local: now.current_datetime_local,\n    },\n    computed: computedPatch,\n  };\n\n  return {\n    json: {\n      ...j,\n      // IMPORTANT: merge, never replace\n      ara_context: mergeDeep(ara, araPatch),\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -880,
        3120
      ],
      "id": "d27bcec9-08fd-40f1-b08d-c9b8e7ad9800",
      "name": "Compute Now + Next Xth (KL)"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2192,
        1776
      ],
      "id": "45a4a886-53d5-422a-929e-eb0b4617aa2e",
      "name": "Merge3"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1744,
        1920
      ],
      "id": "32dc4ae5-8660-49e6-ae9e-ad6433ad7481",
      "name": "Merge4"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            },
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "TRUE"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2416,
        1776
      ],
      "id": "c94a7542-3706-4179-84e6-c9ca35c5ecbd",
      "name": "Update Pending Action Reminder Set"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Route Actions Switch2').item.json.output.pending_action_payload.user_id }}"
            },
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "TRUE"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1968,
        1920
      ],
      "id": "5eca2c25-a8a5-4489-9a4a-63cfe618caed",
      "name": "Update Pending Action Reminder List"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $items(\"If ALL?\")[0].json.user_id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Route Confirmed Actions').first().json.telegram_chat_id }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $json.sid }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $json.body }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $items(\"Merge2\")[0].json.output.pending_action_type }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $items(\"Merge2\")[0].json.output.pending_action_payload }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "=TRUE"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $('Get Latest Conversation').first().json.session_id }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2864,
        2544
      ],
      "id": "b4538780-0478-4734-a72e-0a335c7e81cc",
      "name": "Update Conversation4",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "useDataOfInput": 2
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2864,
        3184
      ],
      "id": "ae66b42a-75e9-4365-9a03-77ebd73cc744",
      "name": "Merge5"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            },
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "TRUE"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        3088,
        3088
      ],
      "id": "04c37003-8192-4023-a9c5-02f9094a593b",
      "name": "Update Pending Action Reminder Delete"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "with target as (\n  select id\n  from public.conversations\n  where user_id = $1\n    and session_id = $2\n    and pending_action_type = 'reminder_delete_offer'\n    and pending_action_resolved = false\n    and pending_action_payload->>'reminder_id' = $3\n  order by created_at desc\n  limit 1\n)\nupdate public.conversations c\nset\n  pending_action_resolved = true,\n  action_taken = coalesce(action_taken, 'closed_by_yes_delete')\nfrom target\nwhere c.id = target.id\nreturning c.id, c.pending_action_resolved;\n",
        "options": {
          "queryReplacement": "={{ $json.user_id }}, {{ $json.session_id }}, {{ $json.pending_action_payload.reminder_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3088,
        3280
      ],
      "id": "f705ce46-8367-4b4f-96db-74f0edb66128",
      "name": "Execute a SQL query"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH target AS (\n  SELECT id\n  FROM public.conversations\n  WHERE user_id = $1\n    AND pending_action_resolved = false\n    AND pending_action_type IS NOT NULL\n    AND pending_action_type <> 'none'\n  ORDER BY created_at DESC\n  OFFSET 5\n  LIMIT 1\n)\nUPDATE public.conversations c\nSET pending_action_resolved = true\nFROM target\nWHERE c.id = target.id;\n",
        "options": {
          "queryReplacement": "={{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1744,
        4112
      ],
      "id": "fe0450bb-3240-41f2-bcf0-52e839fffbc0",
      "name": "Execute a SQL query1"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ $('Twilio Webhook').item.json.body.WaId }}",
        "toWhatsapp": true,
        "message": "HI! üòä Welcome to ARA (Ai-Ready Assistant). Sebentar ye, saya daftar awak sebagai user baru.\n\n_By continuing to chat, you agree to ARA‚Äôs Terms & Privacy Policy_\n_https://araaisolution.com/terms-of-service_\n_https://araaisolution.com/privacy-policy_\n\n",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -3568,
        1968
      ],
      "id": "580225f6-8803-4207-b6ae-5bea4b90dbc1",
      "name": "Send 1st Message1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.error }}",
                    "rightValue": "duplicate key value violates unique constraint \"users_telegram_id_key\"",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "40c674dd-ce02-4977-a627-ada421b19aaf"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Existing user"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3792,
        1968
      ],
      "id": "14506683-b6dd-4ddd-b096-255784d66441",
      "name": "New User?1",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        896,
        928
      ],
      "id": "fedacbdb-371d-4068-8ced-3f0ec03558c8",
      "name": "OpenAI Model1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify({\n  latest_user_message: $('Get Latest Conversation2').item.json.user_message || $json.Body || $json.body || '',\n  assistant_response: $('Send Reply1').item.json.body || '',\n  user_context: $('Format Context with Memory').item.json.ara_context.user || {}\n}) }}",
        "options": {
          "systemMessage": "You are ARA‚Äôs Memory Extraction Agent.\n\nYour ONLY job is to decide what is worth saving into long-term memory for this user, based on the LATEST exchange.\n\nINPUT FORMAT\n\nYou will receive a JSON object with:\n\nlatest_user_message: the most recent WhatsApp message from the user\n\nassistant_response: the reply that ARA just sent to the user\n\nuser_context: basic info about the user (id, phone, timezone, etc.)\n\nCRITICAL CONSTRAINTS\n\nYou MUST ONLY consider:\n\nlatest_user_message\n\nassistant_response\n\nYou MUST NOT scan or ‚Äúimagine‚Äù earlier history, even if you see anything that looks like history or summaries in the input.\n\nTreat this as a single turn: one user message + one assistant reply.\n\nIf you are not clearly sure a fact will help in future conversations, DO NOT save it.\n\nIf there is nothing worth remembering, return an empty JSON array: [].\n\nGOAL\n\nDecide whether this turn contains anything that is worth remembering LATER to help this user:\n\npersonal facts\n\nstable preferences\n\nrelationships\n\nongoing tasks or recurring patterns\n\nbusiness / life context\n\nENTITY & WORLD-KNOWLEDGE SAFETY RULES (VERY IMPORTANT)\n\nThese rules are to prevent wrong ‚Äúpeople‚Äù and messy memories.\n\nPlaces are NEVER people\n\nTreat these as places, not persons, for example:\n\nCountries: Malaysia, Singapore, Indonesia, Thailand, Vietnam, UK, USA, Saudi Arabia, etc.\n\nMalaysian cities / regions: Kuala Lumpur, KL, Selangor, Penang, Johor Bahru, Ipoh, Melaka, Sabah, Sarawak, Kuching, Kota Kinabalu, etc.\n\nHoly places: Makkah/Mecca, Madinah/Medina, Kaabah, Masjidil Haram, Masjid Nabawi, etc.\n\nThey must NOT appear inside entities.people. They may appear in entities.topics or only inside memory_value.\n\nOrganisations, banks, and programmes are NEVER people\n\nAnything that looks like a company, bank, agency, or programme must NOT go into entities.people. Examples:\n\nNames containing: ‚ÄúBank‚Äù, ‚ÄúBerhad‚Äù, ‚ÄúBhd‚Äù, ‚ÄúSdn Bhd‚Äù, ‚ÄúCorp‚Äù, ‚ÄúCompany‚Äù, ‚ÄúUniversity‚Äù, ‚ÄúCollege‚Äù.\n\nKnown Malaysian orgs: MARA, AIM (Amanah Ikhtiar Malaysia), MRANTI, SME Bank, Maybank, CIMB, Bank Rakyat, Petronas, Tenaga Nasional, etc.\n\nPut them in entities.topics if relevant, or leave them only in memory_value.\n\nApps and tools are NEVER people\n\nWhatsApp, Telegram, Facebook, Instagram, TikTok, Google, YouTube, Shopee, Lazada, Grab, Foodpanda, ARA, etc. are tools/apps, not persons.\n\nThey must NOT be inside entities.people.\n\nGeneric roles are allowed but should be simple\n\nPhrases like ‚Äúmy tailor‚Äù, ‚Äúmy designer‚Äù, ‚Äúmy supplier‚Äù, ‚Äúmy mentor‚Äù can appear in memory_value.\nIn entities.people you may use a simple label like \"tailor\" or \"mentor\" if it clearly helps; never invent a personal name that wasn‚Äôt given.\n\nWhen in doubt about person vs place/org ‚Üí DO NOT mark as a person\n\nIf you‚Äôre not clearly sure something is a human name, leave it out of entities.people.\nIt is better to have fewer people than wrong people.\n\nWHAT TO EXTRACT\n\nExtract only information that:\n\nwill still matter in future conversations (hours, days, weeks later), AND\n\nhelps ARA be more helpful or personal.\n\nFocus on:\n\nPERSONAL BACKGROUND\n\nEducation, origin, profession, roles, life events.\n\nExample: ‚ÄúI‚Äôm from Kedah‚Äù, ‚ÄúI run a printing business‚Äù, ‚ÄúI‚Äôm a teacher‚Äù, ‚ÄúI just moved to London.‚Äù\n\nPREFERENCES & OPINIONS\n\nColors, products, styles, routines, habits, food, communication style, language preference, tools they like to use.\n\nExample: ‚ÄúCustomer Ali wants the color green‚Äù, ‚ÄúI prefer English‚Äù, ‚ÄúI like voice notes‚Äù, ‚ÄúI hate long paragraphs‚Äù.\n\nRELATIONSHIPS & ROLES\n\nWho is who: spouse, children, business partners, customers, suppliers, mentors, staff, etc.\n\nExample: ‚ÄúAishah is my wife‚Äù, ‚ÄúAli is my customer‚Äù, ‚ÄúSiti is the event planner for my wedding‚Äù.\n\nTASK PATTERNS & ONGOING CONTEXT\n\nRecurring routines or ongoing projects, not one-off noise.\n\nExample:\n\n‚ÄúEvery Monday I have team meeting at 9am.‚Äù\n\n‚ÄúI‚Äôm working on launching my new cafe in March.‚Äù\n\n‚ÄúI‚Äôm using ARA mainly to manage my business reminders.‚Äù\n\nIMPORTANT REMINDER-LIKE FACTS\n\nOnly if they reveal something stable or recurring.\n\nExample:\n\n‚ÄúI always call my mum every Sunday night.‚Äù\n\n‚ÄúMy rental is due on the 25th every month.‚Äù\n\nOne-off reminders that are already fully handled by the reminder system usually do NOT need to be saved as long-term memory.\n\nWHAT NOT TO SAVE\n\nDO NOT save:\n\nGreetings or filler:\n\n‚ÄúHi‚Äù, ‚ÄúHello‚Äù, ‚ÄúOK‚Äù, ‚ÄúThanks‚Äù, ‚ÄúBetul‚Äù, ‚ÄúDone‚Äù, ‚ÄúYes‚Äù, ‚ÄúNo‚Äù, etc.\n\nPure emotion with no concrete fact:\n\n‚ÄúYou are slow‚Äù, ‚ÄúI‚Äôm angry‚Äù, ‚ÄúService not good‚Äù, ‚ÄúI‚Äôm stressed‚Äù.\n\nTemporary confusion:\n\n‚ÄúI don‚Äôt know‚Äù, ‚ÄúWhat?‚Äù, ‚ÄúWhere is my reminder?‚Äù, ‚ÄúWhy you so slow?‚Äù\n\nTechnical/system-like text, IDs, or internal ARA messages.\n\nDetails that only matter for a single reminder and add no long-term value.\n\nShort, vague, or ambiguous statements that you cannot interpret safely.\n\nAnything that is not clearly about:\n\nthe user,\n\ntheir contacts/relationships,\n\ntheir stable preferences,\n\ntheir ongoing business or life context.\n\nIf unsure, prefer to skip the memory.\n\nMEMORY TYPES\n\nUse these types:\n\n\"preference\" ‚Üí stable likes/dislikes, style, language, choices.\n\n\"relationship\" ‚Üí who people are and how they are connected to the user.\n\n\"context\" ‚Üí facts about their situation, work, business, or long-term goals.\n\n\"interaction\" ‚Üí specific actions, decisions, or promises that may matter later (e.g. ‚Äúuser agreed to try weekly planning with ARA‚Äù).\n\nIf you cannot decide a suitable type with reasonable confidence, DO NOT create the memory.\n\nIMPORTANCE & LIMITS\n\nimportance_score must be between 0.7 and 1.0.\n\nUse 0.9‚Äì1.0 only for very important, identity-level facts (family, core business, strong preferences).\n\nUse 0.7‚Äì0.8 for useful but lighter context.\n\nIf a fact feels minor or very temporary, do NOT save it at all.\n\nTry not to create more than 3 memories per turn. Pick the most useful ones.\n\nSCHEMA\n\nReturn a JSON array. Each memory object MUST have:\n\nmemory_type: \"preference\" | \"relationship\" | \"context\" | \"interaction\"\n\nmemory_key: a short snake_case key you invent (e.g. \"ali_color_preference\")\n\nmemory_value: the full fact in natural language\n\nimportance_score: 0.7‚Äì1.0\n\nentities:\n\n\"people\": [\"list\", \"of\", \"names\"] (real people or clear roles only)\n\n\"topics\": [\"keywords\", \"like\", \"reminder\", \"color\", \"meeting\"]\n\ntemporal_context: a simple string like \"today\" or an ISO date if explicitly mentioned.\n\nRESOLVING PRONOUNS\n\nIf the user says ‚Äúshe‚Äù, ‚Äúhe‚Äù, ‚Äúthat color‚Äù, etc., use ONLY the information in latest_user_message + assistant_response to interpret it.\n\nIf you cannot resolve it clearly to a specific person or thing, DO NOT save the memory.\n\nDUPLICATES\n\nIf the user repeats something you already know (for example: ‚ÄúAli likes green‚Äù) but adds no new detail, you may:\n\neither skip it, OR\n\ninclude it again with the same memory_value (the system will de-duplicate later).\n\nDO NOT assume something is updated unless the message clearly says the old info has changed.\n\nOUTPUT FORMAT\n\nOutput MUST be a valid JSON array.\n\nDO NOT wrap the JSON in ``` or any markdown.\n\nDO NOT include explanations, comments, or extra text.\n\nIf there is nothing useful to save, return exactly: []."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        816,
        704
      ],
      "id": "521b51b0-db91-4ec3-862c-70849d49aa6f",
      "name": "Extract Memories1",
      "executeOnce": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{ $('Format Context with Memory2').item.json.is_continuing_session }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              },
              "id": "74ef4d44-2a94-431f-a49c-b470fc2a0996"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1168,
        1056
      ],
      "id": "f83fef7e-5c0e-4b30-ad79-76e3b31482e9",
      "name": "Session Ended?1"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Memories v2 - simpler, cleaner, per-turn\n// Input: array of validated memory objects (from Validate Memories)\n// Output: array of rows ready for ai_memories table\n\nconst input = $input.all().map(i => i.json);\nlet memories = input;\n\n// If someone wired it differently and we got a single array\nif (input.length === 1 && Array.isArray(input[0])) {\n  memories = input[0];\n}\n\nif (!memories || memories.length === 0) {\n  console.log('Prepare Memories: no memories to process');\n  return [];\n}\n\n// ===== Get user context =====\nlet userId = null;\ntry {\n  const userNode = $('Get User1').first();\n  if (userNode && userNode.json && userNode.json.id) {\n    userId = userNode.json.id;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get user ID', e);\n}\n\nif (!userId) {\n  console.log('Prepare Memories: missing user_id, aborting');\n  return [];\n}\n\n// ===== Get existing memories for this user =====\nlet existing = [];\ntry {\n  const rows = $('Get User Memories').all() || [];\n  existing = rows\n    .filter(r => r.json && r.json.memory_value)\n    .map(r => r.json);\n} catch (e) {\n  console.log('Prepare Memories: could not get existing memories', e);\n}\n\n// Build quick lookup structures\nconst existingByKey = {};\nconst existingByValue = new Map();\n\nexisting.forEach(mem => {\n  const key = (mem.memory_key || '').toLowerCase();\n  if (key) existingByKey[key] = mem;\n\n  const val = (mem.memory_value || '').toLowerCase().trim();\n  if (val) existingByValue.set(val, mem);\n});\n\n// ===== Helper: normalize base key =====\nconst slugify = (text) => {\n  return text\n    .toString()\n    .toLowerCase()\n    .normalize('NFKD')\n    .replace(/[^a-z0-9]+/g, '_')\n    .replace(/^_+|_+$/g, '');\n};\n\n// ===== Helper: generate unique key with versions =====\nconst versionCache = {}; // baseKey -> highest version\n\n// Initialize versionCache from existing keys\nObject.keys(existingByKey).forEach(k => {\n  const match = k.match(/^(.*)_v(\\d+)$/);\n  if (match) {\n    const base = match[1];\n    const v = parseInt(match[2], 10);\n    if (!versionCache[base] || v > versionCache[base]) {\n      versionCache[base] = v;\n    }\n  }\n});\n\nconst generateKey = (mem, index) => {\n  // Start from provided key if any\n  let base = mem.memory_key\n    ? slugify(mem.memory_key)\n    : slugify(mem.memory_value || `memory_${index}`);\n\n  // Attach first person if available\n  if (mem.entities && mem.entities.people && mem.entities.people.length > 0) {\n    const person = slugify(mem.entities.people[0]);\n    if (person && !base.includes(person)) {\n      base = `${person}_${base}`;\n    }\n  }\n\n  // Strip existing version suffix\n  base = base.replace(/_v\\d+$/, '');\n\n  const type = mem.memory_type || 'context';\n\n  if (type === 'preference' || type === 'context') {\n    // Versioned keys\n    const current = versionCache[base] || 0;\n    const next = current + 1;\n    versionCache[base] = next;\n    return `${base}_v${next}`;\n  }\n\n  if (type === 'relationship') {\n    // Relationship can be stable per session\n    const now = Date.now();\n    return `${base}_rel_${now}`;\n  }\n\n  if (type === 'interaction') {\n    const now = Date.now();\n    return `${base}_int_${now}`;\n  }\n\n  // Fallback\n  const now = Date.now();\n  return `${base}_${type}_${now}`;\n};\n\n// ===== Very simple similarity check (exact / near exact text) =====\nconst isDuplicateByValue = (value) => {\n  if (!value) return false;\n  const valLower = value.toLowerCase().trim();\n  if (existingByValue.has(valLower)) return true;\n  return false;\n};\n\n// ===== Session & timestamps =====\nlet sessionId = null;\ntry {\n  const ctx = $('Format Context with Memory').first();\n  if (ctx && ctx.json && ctx.json.ara_context && ctx.json.ara_context.history) {\n    sessionId = ctx.json.ara_context.history.detailed?.[0]?.session_id || null;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get session_id from context');\n}\n\nif (!sessionId) {\n  // Fallback session id\n  sessionId = `${Date.now()}_${Math.floor(Math.random() * 100000)}`;\n}\n\nconst nowIso = new Date().toISOString();\n\n// ===== Process memories =====\nconst prepared = [];\n\nmemories.forEach((mem, index) => {\n  if (!mem || !mem.memory_value) return;\n\n  // Skip if same value already exists\n  if (isDuplicateByValue(mem.memory_value)) {\n    console.log('Prepare Memories: skip duplicate by value:', mem.memory_value.substring(0, 60));\n    return;\n  }\n\n  const type = mem.memory_type || 'context';\n  const key = generateKey(mem, index);\n\n  const row = {\n    user_id: userId,\n    memory_type: type,\n    memory_key: key,\n    memory_value: mem.memory_value,\n    importance_score: mem.importance_score ?? 0.8,\n    session_id: sessionId,\n    conversation_date: nowIso,\n    entities: JSON.stringify(mem.entities || { people: [], topics: [] }),\n    temporal_context: mem.temporal_context || 'today',\n    is_active: true,\n    confidence_score: 1,\n    source: 'auto_extracted',\n    context_before: null,\n    context_after: null,\n  };\n\n  prepared.push(row);\n  console.log(`Prepare Memories: ACCEPTED ${key}`);\n});\n\nif (prepared.length === 0) {\n  console.log('Prepare Memories: no new memories after dedupe');\n}\n\nreturn prepared.map(r => ({ json: r }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1456,
        816
      ],
      "id": "88d2953d-682a-44d4-8fe2-d4ff750025dd",
      "name": "Prepare Memories"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "= {{ $json.user_id }}",
              "rightValue": 0,
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              },
              "id": "ebb88b93-4047-405f-9730-737ec9f4b782"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1744,
        816
      ],
      "id": "14ee04f3-0907-4f67-9cda-0b691624e29d",
      "name": "Has Memories?"
    },
    {
      "parameters": {
        "tableId": "ai_memories",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "memory_type",
              "fieldValue": "={{ $json.memory_type }}"
            },
            {
              "fieldId": "memory_key",
              "fieldValue": "={{ $json.memory_key }}"
            },
            {
              "fieldId": "memory_value",
              "fieldValue": "={{ $json.memory_value }}"
            },
            {
              "fieldId": "importance_score",
              "fieldValue": "={{ $json.importance_score }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "entities",
              "fieldValue": "={{ $json.entities }}"
            },
            {
              "fieldId": "temporal_context",
              "fieldValue": "={{ $json.temporal_context }}"
            },
            {
              "fieldId": "is_active",
              "fieldValue": "={{ $json.is_active }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1968,
        816
      ],
      "id": "159a1b63-9390-4e9b-9238-f6357d14806b",
      "name": "Save Memories"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Session Summary Generator v2\n// - Only summarizes completed sessions\n// - Skips very short/test sessions\n// - Produces richer, more structured summaries\n\nconst MIN_MESSAGES = 3;        // Require at least 3 messages in a session\nconst MIN_GAP_MINUTES = 15;    // Session must have ended at least 15 minutes ago\n\n// ---------- 1. Resolve user ID ----------\nlet userId;\n\ntry {\n  const ctx = $('Format Context with Memory').first();\n  if (ctx?.json?.user_id) {\n    userId = ctx.json.user_id;\n  }\n} catch (e) {\n  console.log('Could not get user ID from Format Context with Memory', e);\n}\n\nif (!userId) {\n  try {\n    const userNode = $('Get User1').first();\n    if (userNode?.json?.id) {\n      userId = userNode.json.id;\n    }\n  } catch (e) {\n    console.log('Could not get user ID from Get User1', e);\n  }\n}\n\n// If we still don't have a userId, we can't safely summarize\nif (!userId) {\n  console.log('No userId found, skipping session summary');\n  return [];\n}\n\n// ---------- 2. Get conversation history for this user ----------\nlet conversations = [];\ntry {\n  conversations = $('Fetch Session History').all() || [];\n} catch (e) {\n  console.log('Could not get conversations from Fetch Session History', e);\n  return [];\n}\n\n// Convert to plain JS objects and filter by this user (safety)\nconst allConversations = conversations\n  .map(c => c.json)\n  .filter(c => c && c.user_id === userId && c.session_id);\n\nif (allConversations.length < MIN_MESSAGES) {\n  console.log('Not enough conversations overall to summarize');\n  return [];\n}\n\n// Sort descending by created_at (newest first)\nallConversations.sort(\n  (a, b) => new Date(b.created_at) - new Date(a.created_at)\n);\n\n// ---------- 3. Work out current vs completed sessions ----------\nconst currentSessionId = allConversations[0].session_id;\nconsole.log('Current session ID:', currentSessionId);\n\nconst sessionsById = {};\nfor (const conv of allConversations) {\n  if (!sessionsById[conv.session_id]) {\n    sessionsById[conv.session_id] = [];\n  }\n  sessionsById[conv.session_id].push(conv);\n}\n\n// Remove the current session from candidates (we only want completed ones)\ndelete sessionsById[currentSessionId];\n\nconst candidateSessionIds = Object.keys(sessionsById);\nif (candidateSessionIds.length === 0) {\n  console.log('No completed sessions to summarize');\n  return [];\n}\n\n// ---------- 4. Pick the most recent completed session ----------\ncandidateSessionIds.sort((a, b) => {\n  const aRecent = Math.max(\n    ...sessionsById[a].map(c => new Date(c.created_at).getTime())\n  );\n  const bRecent = Math.max(\n    ...sessionsById[b].map(c => new Date(c.created_at).getTime())\n  );\n  return bRecent - aRecent;\n});\n\nconst sessionId = candidateSessionIds[0];\nconst sessionToSummarize = sessionsById[sessionId];\n\n// Ensure this session is ‚Äúreal‚Äù and not just a 1-message ping\nif (sessionToSummarize.length < MIN_MESSAGES) {\n  console.log(\n    `Session ${sessionId} has only ${sessionToSummarize.length} messages, skipping summary`\n  );\n  return [];\n}\n\n// Check how long ago this session ended\nconst mostRecentMessageTs = Math.max(\n  ...sessionToSummarize.map(c => new Date(c.created_at).getTime())\n);\nconst minutesSinceLastMessage =\n  (Date.now() - mostRecentMessageTs) / (1000 * 60);\n\nif (minutesSinceLastMessage < MIN_GAP_MINUTES) {\n  console.log(\n    `Session ${sessionId} ended only ${minutesSinceLastMessage.toFixed(\n      1\n    )} minutes ago, skipping summary`\n  );\n  return [];\n}\n\n// ---------- 5. Extract key info from this session ----------\nconst topics = new Set();\nconst people = new Set();\nconst decisions = [];\nlet firstUserMessage = null;\nlet lastUserMessage = null;\n\nfor (const conv of sessionToSummarize) {\n  if (!conv.user_message) continue;\n\n  const msg = conv.user_message;\n  const msgLower = msg.toLowerCase();\n\n  if (!firstUserMessage) firstUserMessage = msg;\n  lastUserMessage = msg;\n\n  // Topics (you can extend this list anytime)\n  if (msgLower.includes('staff') || msgLower.includes('hire') || msgLower.includes('recruit')) {\n    topics.add('hiring');\n  }\n  if (msgLower.includes('remind') || msgLower.includes('ingat')) {\n    topics.add('reminders');\n  }\n  if (msgLower.includes('meeting') || msgLower.includes('jumpa')) {\n    topics.add('meetings');\n  }\n  if (msgLower.includes('stok') || msgLower.includes('inventory')) {\n    topics.add('inventory');\n  }\n  if (msgLower.includes('duit') || msgLower.includes('bayar') || msgLower.includes('payment')) {\n    topics.add('money');\n  }\n\n  // Rough name detection (single capitalized words)\n  const namePattern = /\\b[A-Z][a-z]{2,}\\b/g;\n  const names = msg.match(namePattern) || [];\n  for (const name of names) {\n    if (!['I', 'Ara', 'ARA'].includes(name)) {\n      people.add(name);\n    }\n  }\n\n  // Decisions / plans (keep first 120 chars)\n  if (\n    msgLower.includes('need') ||\n    msgLower.includes('nak ') ||\n    msgLower.includes('akan ') ||\n    msgLower.includes('plan') ||\n    msgLower.includes('will')\n  ) {\n    decisions.push(msg.substring(0, 120));\n  }\n}\n\n// ---------- 6. Timing & meta info ----------\nsessionToSummarize.sort(\n  (a, b) => new Date(a.created_at) - new Date(b.created_at)\n);\nconst sessionStartTime = new Date(sessionToSummarize[0].created_at);\nconst sessionEndTime = new Date(\n  sessionToSummarize[sessionToSummarize.length - 1].created_at\n);\n\nconst dayOfWeekNames = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n];\nconst dayOfWeek = dayOfWeekNames[sessionStartTime.getDay()];\n\nconst hour = sessionStartTime.getHours();\nconst timeOfDay =\n  hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';\n\nconst durationMinutes = Math.max(\n  1,\n  Math.round((sessionEndTime - sessionStartTime) / (1000 * 60))\n);\n\n// ---------- 7. Build human-readable summary ----------\nlet summaryText = 'User ';\n\nif (topics.has('hiring')) {\n  summaryText += 'discussed getting help with hiring or staff issues';\n} else if (topics.size > 0) {\n  summaryText += `discussed ${Array.from(topics).join(', ')}`;\n} else {\n  summaryText += 'had a general conversation';\n}\n\nif (people.size > 0) {\n  summaryText += `, and mentioned ${Array.from(people).join(', ')}`;\n}\n\nsummaryText += `. Conversation lasted about ${durationMinutes} minute(s).`;\n\nif (decisions.length > 0) {\n  summaryText += ' Key decisions or needs were mentioned.';\n}\n\n// ---------- 8. Construct summary record ----------\nconst summary = {\n  user_id: userId,\n  session_id: sessionId,\n  conversation_date: sessionStartTime.toISOString(),\n  day_of_week: dayOfWeek,\n  time_of_day: timeOfDay,\n  summary: summaryText,\n  key_topics: Array.from(topics),\n  people_mentioned: Array.from(people),\n  decisions_made: decisions,\n  message_count: sessionToSummarize.length,\n  session_duration_minutes: durationMinutes,\n};\n\nconsole.log('Generated summary for completed session:', summary);\n\n// n8n expects an array of items: [{ json: ... }]\nreturn [{ json: summary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1456,
        1056
      ],
      "id": "bb8f8aed-0ef4-464f-890f-bd21b36a2101",
      "name": "Generate Session Summary",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "tableId": "conversation_summaries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "day_of_week",
              "fieldValue": "={{ $json.day_of_week }}"
            },
            {
              "fieldId": "time_of_day",
              "fieldValue": "={{ $json.time_of_day }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $json.summary }}"
            },
            {
              "fieldId": "key_topics",
              "fieldValue": "={{ $json.key_topics }}"
            },
            {
              "fieldId": "people_mentioned",
              "fieldValue": "={{ $json.people_mentioned }}"
            },
            {
              "fieldId": "decisions_made",
              "fieldValue": "={{ $json.decisions_made }}"
            },
            {
              "fieldId": "message_count",
              "fieldValue": "={{ $json.message_count }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1744,
        1056
      ],
      "id": "ed6e9a48-1595-48cb-a4a6-8c9e8ad8de07",
      "name": "Save Session Summary"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation2').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $('Sanitize Assistant Response').item.json.assistant_response }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $('Extract Pending Action1').item.json.pending_action_type }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $('Extract Pending Action1').item.json.pending_action_payload }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "false"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        880,
        1152
      ],
      "id": "58c332e0-aee5-47bc-b9e2-47b343438973",
      "name": "Update Conversation1",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "jsCode": "// Validate Memories (hardened)\n// Input: Whatever Extract Memories returns (can be JSON, string, or error envelope)\n// Output: array of clean memory objects as { json: ... }\n// If anything looks wrong, we just return [] and let the workflow continue safely.\n\nconst raw = $json;\n\n// 0) If upstream node failed and we got an error envelope, bail out safely.\nif (raw.error || raw.errorMessage || raw.errorDescription) {\n  console.log('Validate Memories: upstream error detected, skipping memories.');\n  return [];\n}\n\n// 1) Unwrap \"output\" if present\nlet memoriesRaw = raw.output ?? raw;\n\nlet memories = [];\n\ntry {\n  if (typeof memoriesRaw === 'string') {\n    let txt = memoriesRaw.trim();\n\n    // Strip accidental code fences\n    txt = txt\n      .replace(/^```json\\s*/i, '')\n      .replace(/^```\\s*/i, '')\n      .replace(/```$/i, '')\n      .trim();\n\n    const parsed = JSON.parse(txt);\n\n    if (Array.isArray(parsed)) {\n      memories = parsed;\n    } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.memories)) {\n      // Sometimes wrapped as { memories: [...] }\n      memories = parsed.memories;\n    } else {\n      memories = [parsed];\n    }\n\n  } else if (Array.isArray(memoriesRaw)) {\n    memories = memoriesRaw;\n\n  } else if (memoriesRaw && typeof memoriesRaw === 'object') {\n    // Maybe already { memories: [...] } or a single object\n    if (Array.isArray(memoriesRaw.memories)) {\n      memories = memoriesRaw.memories;\n    } else {\n      memories = [memoriesRaw];\n    }\n\n  } else {\n    console.log('Validate Memories: unsupported input type, skipping.');\n    return [];\n  }\n\n} catch (e) {\n  console.log('Validate Memories: failed to parse memories JSON, skipping.', e);\n  return [];\n}\n\nif (!Array.isArray(memories)) {\n  console.log('Validate Memories: parsed value is not an array, skipping.');\n  return [];\n}\n\nconst ALLOWED_TYPES = new Set(['preference', 'relationship', 'context', 'interaction']);\n\nconst cleaned = memories\n  .filter(m => m && typeof m === 'object')\n  .map((m, idx) => {\n    const mem = { ...m };\n\n    // Normalise memory_type\n    if (!ALLOWED_TYPES.has(mem.memory_type)) {\n      if (mem.memory_type === 'business/role') {\n        mem.memory_type = 'context';\n      } else {\n        mem.memory_type = 'context';\n      }\n    }\n\n    // Ensure text fields exist\n    mem.memory_value = (mem.memory_value || '').toString().trim();\n    mem.memory_key = (mem.memory_key || `memory_${idx}`).toString().trim();\n\n    // Default importance\n    const importance = Number(mem.importance_score ?? 0.8);\n    mem.importance_score = Number.isFinite(importance) ? importance : 0.8;\n\n    // Normalise entities\n    const entities = mem.entities || {};\n    mem.entities = {\n      people: Array.isArray(entities.people) ? entities.people : [],\n      topics: Array.isArray(entities.topics) ? entities.topics : [],\n    };\n\n    // Temporal context\n    mem.temporal_context = mem.temporal_context || 'today';\n\n    return mem;\n  })\n  .filter(mem => {\n    // Filter out junk (same rules as before)\n    if (!mem.memory_value || mem.memory_value.length < 10) return false;\n    if (mem.importance_score < 0.7) return false;\n    return true;\n  });\n\n// n8n expects an array of items: [{ json: ... }, ...]\nreturn cleaned.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1168,
        816
      ],
      "id": "05a2a14a-2fcb-48af-b295-885f044e069d",
      "name": "Validate Memories1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {
          "maxTokens": 500,
          "temperature": 0.4
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -592,
        1296
      ],
      "id": "436c5c68-8b9c-4680-9263-7d384d37a425",
      "name": "OpenAI Chat Model1"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ $items(\"Get Latest Conversation2\")[0].json.telegram_chat_id }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        592,
        960
      ],
      "id": "47dc1844-6178-4705-99f3-c30f338e31e9",
      "name": "Send Reply1"
    },
    {
      "parameters": {
        "url": "https://jjeqmysluzsohwjpyvip.supabase.co/rest/v1/conversations",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ 'eq.' + $json.ara_context.user.id }}"
            },
            {
              "name": "order",
              "value": "created_at.desc"
            },
            {
              "name": "limit",
              "value": "1"
            },
            {
              "name": "select",
              "value": "*"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -880,
        864
      ],
      "id": "41f878ef-7331-48fc-b060-f2cfb83d4ec8",
      "name": "Get Latest Conversation2"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract Pending Action (PATCHED - structured output + YES/NO override)\n// Input: $json.output is an OBJECT from Structured Output Parser\n// Output: preserves the SAME keys downstream expects:\n// - assistant_response\n// - pending_action_type\n// - pending_action_payload\n//\n// Behavior change ONLY when:\n// - user replies YES/NO\n// - AND a latest pending delete offer exists from node \"Get Latest Pending Offer\"\n// Then we override the LLM output deterministically.\n\nfunction safeString(v) {\n  return (v === null || v === undefined) ? \"\" : String(v);\n}\n\nfunction norm(s = \"\") {\n  return safeString(s).toLowerCase().trim();\n}\n\n// Keep strict + small list to avoid false positives.\n// You can expand later once stable.\nfunction isYes(s) {\n  const t = norm(s);\n  return [\n    \"yes\", \"y\", \"ya\", \"yah\", \"yup\",\n    \"ok\", \"okay\", \"confirm\", \"setuju\", \"boleh\"\n  ].includes(t);\n}\n\nfunction isNo(s) {\n  const t = norm(s);\n  return [\n    \"no\", \"n\", \"tak\", \"tidak\", \"x\",\n    \"cancel\", \"batal\", \"jangan\", \"nope\"\n  ].includes(t);\n}\n\nfunction parseMaybeJson(v) {\n  if (typeof v === \"string\") {\n    const s = v.trim();\n    if (!s) return null;\n    try { return JSON.parse(s); } catch (e) { return v; }\n  }\n  return v;\n}\n\n// --------------------\n// 1) Base LLM output (unchanged behavior)\n// --------------------\nconst o = $json.output ?? {};\nlet assistant_response = safeString(o.assistant_response ?? \"\").trim();\nlet pending_action_type = o.pending_action_type ?? \"none\";\nlet pending_action_payload = o.pending_action_payload ?? null;\n\n// Normalize payload if it came as JSON string\npending_action_payload = parseMaybeJson(pending_action_payload);\n\n// --------------------\n// 2) Detect current user text (for YES/NO)\n// --------------------\nconst currentText =\n  $json.user_message ??\n  $json.message ??\n  $json.text ??\n  $json.current_message?.text ??\n  \"\";\n\n// --------------------\n// 3) Attempt to load latest pending offer (optional)\n//    If node doesn't exist / returns nothing ‚Üí no override\n// --------------------\nlet offer = null;\ntry {\n  const offerItems = $items(\"Get Latest Pending Offer\") || [];\n  offer = offerItems[0]?.json ?? null;\n} catch (e) {\n  offer = null;\n}\n\nconst offerType = offer?.pending_action_type ?? null;\nlet offerPayload = parseMaybeJson(offer?.pending_action_payload ?? null);\n\n// --------------------\n// 4) Deterministic override for YES/NO confirmations\n//    ONLY for delete offers\n// --------------------\nconst yes = isYes(currentText);\nconst no = isNo(currentText);\n\n// Treat these as delete offers that require confirmation\nconst DELETE_OFFER_TYPES = new Set([\n  \"reminder_delete_offer\",\n  \"reminder_delete_all\",\n  \"reminder_delete_all_offer\"\n]);\n\nif ((yes || no) && offerType && DELETE_OFFER_TYPES.has(offerType)) {\n  // IMPORTANT: prevent LLM from claiming success before DB action\n  if (no) {\n    pending_action_type = \"none\";\n    pending_action_payload = null;\n    assistant_response = \"Okay ‚Äî canceled. No reminders were deleted.\";\n  } else if (yes) {\n    // Delete ALL ‚Üí reuse reminder_delete with delete_scope=all_active\n    if (offerType === \"reminder_delete_all\" || offerType === \"reminder_delete_all_offer\") {\n      pending_action_type = \"reminder_delete\";\n      pending_action_payload = { delete_scope: \"all_active\" };\n      assistant_response = \"Okay ‚Äî deleting all your active reminders now.\";\n    } else {\n      // Single delete offer ‚Üí carry reminder_id from offer payload\n      const rid =\n        offerPayload?.reminder_id ??\n        offerPayload?.id ??\n        null;\n\n      if (rid) {\n        pending_action_type = \"reminder_delete\";\n        pending_action_payload = { reminder_id: rid };\n        assistant_response = \"Okay ‚Äî deleting that reminder now.\";\n      } else {\n        // Safety fallback: don't execute a random delete\n        pending_action_type = \"none\";\n        pending_action_payload = null;\n        assistant_response = \"I couldn‚Äôt find which reminder to delete. Please try again.\";\n      }\n    }\n  }\n}\n\n// --------------------\n// 5) Return in the exact same structure as before\n// --------------------\nreturn {\n  ...$json,\n  assistant_response,\n  pending_action_type,\n  pending_action_payload,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -208,
        864
      ],
      "id": "e76d6413-52df-47f1-b459-3ef4fcbb57c3",
      "name": "Extract Pending Action1"
    },
    {
      "parameters": {
        "jsCode": "// ROUTE CONFIRMED ACTIONS\n// -----------------------\n// INPUT EXPECTED (from Extract Pending Action + previous nodes):\n// - pending_action_type       (from THIS assistant reply's ARA_PENDING)\n// - pending_action_payload\n// - ara_context               (contains dialogue_state with pendingAction from DB)\n// - user_message              (latest user input)\n// - assistant_response        (for passing through to Send Reply)\n\nconst currentType = $json.pending_action_type || 'none';\nconst currentPayload = $json.pending_action_payload || null;\n\n// ara_context comes from \"Format Context with Memory\"\nconst araContext = $json.ara_context || {};\nconst ds = araContext.dialogue_state || {};\nconst pending = ds.pendingAction || null;\nconst isActiveResponse = !!ds.isActiveResponse;\nconst responseType = ds.activeResponseType || null;  // 'yes' | 'no' | null\n\nlet ARA_ACTION = {\n  type: 'none',\n  payload: null,\n};\n\n// CASE 1: User is replying YES/NO to an existing pendingAction\nif (\n  pending &&\n  pending.type &&\n  pending.type !== 'none' &&\n  isActiveResponse &&\n  (responseType === 'yes' || responseType === 'no')\n) {\n  if (responseType === 'yes') {\n    // Confirm the pending action (create/delete/update/...)\n    ARA_ACTION = {\n      type: pending.type,\n      payload: pending.payload || {},\n    };\n  } else if (responseType === 'no') {\n    // Cancel the pending action\n    ARA_ACTION = {\n      type: pending.type + '_cancel',\n      payload: pending.payload || {},\n    };\n  }\n} else {\n  // CASE 2: Immediate actions that do NOT require confirmation\n  if (currentType === 'escalate') {\n    ARA_ACTION = { type: 'escalate', payload: currentPayload || {} };\n  }\n  else if (currentType === 'timezone_update') {\n    ARA_ACTION = { type: 'timezone_update', payload: currentPayload || {} };\n  }\n  else if (currentType === 'user_update_profile') {\n    ARA_ACTION = { type: 'user_update_profile', payload: currentPayload || {} };\n  }\n} \n\n\n// CASE 3: User profile updates (ARA_ACTION from main agent)\n// If the main agent outputs ARA_ACTION.update_user_preferences directly\n\n// ‚úÖ PATCH: rawOutput might be string (old) OR object (new)\nlet rawOutput = $json.output ?? $json.state ?? $json.text ?? $json.message ?? \"\";\n\n// If object, try common fields, else stringify\nif (typeof rawOutput === \"object\" && rawOutput !== null) {\n  if (typeof rawOutput.state === \"string\") rawOutput = rawOutput.state;\n  else if (typeof rawOutput.final_reply === \"string\") rawOutput = rawOutput.final_reply;\n  else rawOutput = JSON.stringify(rawOutput);\n}\n\nrawOutput = String(rawOutput);\n\n// Now safe to regex-match\nconst actionMatch = rawOutput.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\n\nif (actionMatch) {\n  try {\n    const parsedAction = JSON.parse(actionMatch[1]);\n\n    if (parsedAction.type === \"update_user_preferences\") {\n      // Build payload ONLY with non-null fields\n      const payload = {};\n\n      if (\n        typeof parsedAction.preferred_name === \"string\" &&\n        parsedAction.preferred_name.trim() !== \"\"\n      ) {\n        payload.preferred_name = parsedAction.preferred_name.trim();\n      }\n\n      if (\n        typeof parsedAction.preferred_language === \"string\" &&\n        parsedAction.preferred_language.trim() !== \"\"\n      ) {\n        payload.preferred_language = parsedAction.preferred_language.trim();\n      }\n\n      // Only overwrite ARA_ACTION if we have something real to update\n      if (Object.keys(payload).length > 0) {\n        ARA_ACTION = {\n          type: \"update_user_preferences\",\n          payload,\n        };\n      }\n      // else: no valid fields ‚Üí keep whatever ARA_ACTION was before\n    }\n  } catch (err) {\n    // ignore JSON parsing error, fall back to existing ARA_ACTION\n  }\n}\n\n\n// -----------------------------\n// SAFETY GUARDS (AILOOP PROTECT)\n// -----------------------------\n\n// 1) Whitelist allowed action types only\nconst allowedTypes = [\n  'none',\n  'reminder_create',\n  'reminder_delete',\n  'timezone_update',\n  'escalate',\n  'update_user_preferences',          // üîπ NEW\n\n  'reminder_create_cancel',\n  'reminder_delete_cancel',\n  'timezone_update_cancel',\n  'user_update_profile_cancel',   // optional future use\n];\n\nif (!allowedTypes.includes(ARA_ACTION.type)) {\n  ARA_ACTION = {\n    type: 'none',\n    payload: null,\n  };\n}\n\n// 2) Payload validation for specific actions\n\n// Reminder Create must have topic + suggested_time\nif (ARA_ACTION.type === 'reminder_create') {\n  const p = ARA_ACTION.payload || {};\n  const hasTopic =\n    typeof p.topic === 'string' && p.topic.trim().length > 0;\n  const hasTime =\n    typeof p.suggested_time === 'string' && p.suggested_time.trim().length > 0;\n\n  if (!hasTopic || !hasTime) {\n    // Invalid payload ‚Üí cancel action instead of firing broken data downstream\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Reminder Delete must have reminder_id\nif (ARA_ACTION.type === 'reminder_delete') {\n  const p = ARA_ACTION.payload || {};\n  const hasReminderId =\n    typeof p.reminder_id === 'string' && p.reminder_id.trim().length > 0;\n\n  if (!hasReminderId) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Timezone Update must have timezone + timezone_label\nif (ARA_ACTION.type === 'timezone_update') {\n  const p = ARA_ACTION.payload || {};\n  const hasTz =\n    typeof p.timezone === 'string' && p.timezone.trim().length > 0;\n  const hasLabel =\n    typeof p.timezone_label === 'string' && p.timezone_label.trim().length > 0;\n\n  if (!hasTz || !hasLabel) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Profile Update must have at least one field to update\nif (ARA_ACTION.type === 'user_update_profile') {\n  const p = ARA_ACTION.payload || {};\n  const updates = p.profile_updates || null;\n\n  const valid =\n    updates &&\n    typeof updates === 'object' &&\n    Object.keys(updates).length > 0;\n\n  if (!valid) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Preferences Update must have at least one field\nif (ARA_ACTION.type === 'update_user_preferences') {\n  const p = ARA_ACTION.payload || {};\n  const hasName = Object.prototype.hasOwnProperty.call(p, 'preferred_name');\n  const hasLang = Object.prototype.hasOwnProperty.call(p, 'preferred_language');\n\n  if (!hasName && !hasLang) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n\n\n// (We let 'escalate' and *_cancel pass even with minimal payload)\n\n// -----------------------------\n// Text back to user = assistant_response from previous node\n// -----------------------------\nconst final_reply = ($json.assistant_response || '').trim();\n\n// Safely pull the latest conversation row so we can attach ids\nconst latestItems = $items('Get Latest Conversation2');\nconst latest = latestItems.length ? latestItems[0].json : {};\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Ensure these four are present from Get Latest Conversation\n  id: latest.id ?? $json.id,\n  user_id: latest.user_id ?? $json.user_id,\n  telegram_chat_id: latest.telegram_chat_id ?? $json.telegram_chat_id,\n  message_id: latest.message_id ?? $json.message_id,\n\n  ARA_ACTION,\n  final_reply,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        368,
        368
      ],
      "id": "6c65d690-c14a-4853-b328-40f55adf1c48",
      "name": "Route Confirmed Actions1"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "home_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "current_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        880,
        512
      ],
      "id": "c6f15db5-466c-463f-af51-692ac357cc9d",
      "name": "Update Timezone1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "46456542-8f2a-447d-b598-1713986577a7",
              "name": "user_name",
              "value": "={{    $node[\"Get User1\"].json.first_name    || $node[\"Get User1\"].json.telegram_username    || $json.telegram_chat_id  }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        880,
        128
      ],
      "id": "1c383a35-e403-4d72-8823-27188460554d",
      "name": "Get User name1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.twilio.com/2010-04-01/Accounts/AC_REDACTED/Messages.json",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "twilioApi",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "From",
              "value": "=whatsapp:+601125911400"
            },
            {
              "name": "To",
              "value": "whatsapp:+601136521251"
            },
            {
              "name": "ContentSid",
              "value": "HXce8e8c9580065acd9c86815c679a0dbe"
            },
            {
              "name": "ContentVariables",
              "value": "={{ JSON.stringify({\n  \"1\": $json.user_name,\n  \"2\": $('Route Confirmed Actions1').item.json.telegram_chat_id,\n  \"3\": $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.reason\n       + \". \"\n       + $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.summary,\n  \"4\": $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.last_user_message,\n  \"5\": $now\n}) }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1168,
        128
      ],
      "id": "fe6d2ea2-4bce-444a-a865-4869f85e1086",
      "name": "Escalate1"
    },
    {
      "parameters": {
        "tableId": "escalations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.user_id }}"
            },
            {
              "fieldId": "user_name",
              "fieldValue": "={{ $('Get User name1').item.json.user_name }}"
            },
            {
              "fieldId": "user_phone",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.telegram_chat_id }}"
            },
            {
              "fieldId": "reason",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.reason }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.summary }}"
            },
            {
              "fieldId": "last_user_message",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.last_user_message }}"
            },
            {
              "fieldId": "urgency",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.urgency }}"
            },
            {
              "fieldId": "admin_phone",
              "fieldValue": "={{ '601136521251' }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "={{ 'open' }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1456,
        128
      ],
      "id": "06a227d4-1da7-49da-b4df-67998002a6e3",
      "name": "Create Escalation Log1"
    },
    {
      "parameters": {
        "jsCode": "const replyRaw = ($json.assistant_response || '').trim();\n\n// Simple language guess from latest user message (if available)\nconst userMsg = ($json.user_message || '').trim().toLowerCase();\n\nfunction buildFallback(msg) {\n  const hasMalayHints = /lah|tak|awak|saya|boleh|ingatkan|esok|pukul/.test(msg);\n  if (hasMalayHints) {\n    return \"Maaf, ada masalah teknikal sekejap. Cuba hantar semula mesej tadi ya. üôè\";\n  }\n  return \"Sorry, something went wrong on my side. Please send your last message again. üôè\";\n}\n\nlet safeReply = replyRaw;\nlet fallback_used = false;\n\nif (!safeReply) {\n  safeReply = buildFallback(userMsg);\n  fallback_used = true;\n}\n\n// Return everything + guaranteed reply text\nreturn {\n  ...$json,\n  assistant_response: safeReply,\n  fallback_used,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        1200
      ],
      "id": "ac781754-dc10-47b8-881a-03679f79d549",
      "name": "Prepare Reply (Fail-Safe)1",
      "disabled": true
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "memory_extracted"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {   source: \"whatsapp\",   type: \"memory\",   action: \"saved\",   memory_id: $json.id || null,   memory_category: $json.category || null,   memory_title: $json.title || null } }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2192,
        816
      ],
      "id": "54d472f3-8113-48a4-a057-b96aba2a2c13",
      "name": "Log Memory Extracted1"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation2').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "fallback_triggered"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  scope: \"main_agent\",\n  reason: \"assistant_response_empty_or_invalid\",\n  last_user_message: $json.user_message || null\n} }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        592,
        1872
      ],
      "id": "3256882f-0aaf-4a19-9e19-c37f152775e4",
      "name": "log Main Fallback1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.fallback_used }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "32a5b251-f43e-40f7-bda8-b82ec3edfbf7"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        368,
        1872
      ],
      "id": "cc370fd0-1620-42f8-8934-74c16f63077e",
      "name": "IF Fallback Used?1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE public.users\nSET\n  preferred_name = COALESCE(NULLIF($1::text, 'null'), preferred_name),\n  preferred_language = CASE\n    WHEN $2 IS NULL OR $2 = '__KEEP__' THEN preferred_language\n    ELSE $2\n  END\nWHERE id = $3;\n",
        "options": {
          "queryReplacement": "={{ $json.pending_action_payload?.preferred_name ?? null }}, {{ $json.pending_action_payload?.preferred_language === undefined ? '__KEEP__' : $json.pending_action_payload?.preferred_language }}\n, {{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        880,
        320
      ],
      "id": "34d4ec2e-5fb1-4d60-b762-e6afec00e00f",
      "name": "PG ‚Äì Update user preferences1"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Mixed-Offer Override (SAFE GUARDRAIL)\n// Run mode: \"Run Once for Each Item\"  ‚úÖ must return a SINGLE object (not an array)\n\nconst item = $json;\n\nconst currentType = (item.pending_action_type || 'none').toString();\n\n// Pass through if extractor already found an action\nif (currentType !== 'none') {\n  return item;\n}\n\nconst assistantText = (item.assistant_response || '').toString().trim();\nif (!assistantText) return item;\n\n// 1) Must look like a REMINDER offer (not generic offers)\nconst hasReminderWords = /\\b(remind|reminder|ingatkan|peringat)\\b/i.test(assistantText);\n\nconst hasOfferAsk =\n  /\\b(would you like me to|do you want me to|shall i|should i|can i|may i)\\b/i.test(assistantText) ||\n  /\\b(just to confirm|to confirm)\\b/i.test(assistantText) ||\n  /\\b(nak saya|mahu saya|boleh saya)\\b/i.test(assistantText);\n\nif (!hasReminderWords || !hasOfferAsk) {\n  return item;\n}\n\n// 2) Require explicit day anchor (no guessing dates)\nconst isTomorrow = /\\b(tomorrow|esok)\\b/i.test(assistantText);\nconst isToday = /\\b(today|harini|hari ini)\\b/i.test(assistantText);\nif (!isTomorrow && !isToday) return item;\n\n// 3) Extract clock time\nlet hour = null;\nlet minute = 0;\n\nlet m = assistantText.match(/\\b([01]?\\d|2[0-3])[:.](\\d{2})\\s*(am|pm)?\\b/i);\nif (m) {\n  hour = parseInt(m[1], 10);\n  minute = parseInt(m[2], 10);\n  const ampm = (m[3] || '').toLowerCase();\n  if (ampm === 'pm' && hour < 12) hour += 12;\n  if (ampm === 'am' && hour === 12) hour = 0;\n} else {\n  m = assistantText.match(/\\b([1-9]|1[0-2])\\s*(am|pm)\\b/i);\n  if (m) {\n    hour = parseInt(m[1], 10);\n    minute = 0;\n    const ampm = (m[2] || '').toLowerCase();\n    if (ampm === 'pm' && hour < 12) hour += 12;\n    if (ampm === 'am' && hour === 12) hour = 0;\n  }\n}\n\nif (hour === null) return item;\n\n// 4) Build suggested_time safely for +08 zones only\nconst tz = item?.ara_context?.user?.timezone || 'Asia/Kuala_Lumpur';\nconst plus8Zones = new Set(['Asia/Kuala_Lumpur', 'Asia/Kuching', 'Asia/Singapore']);\nif (!plus8Zones.has(tz)) return item;\n\nfunction pad2(n) { return String(n).padStart(2, '0'); }\n\nconst nowUtc = new Date();\nconst nowPlus8 = new Date(nowUtc.getTime() + 8 * 60 * 60 * 1000);\n\nlet y = nowPlus8.getUTCFullYear();\nlet mo = nowPlus8.getUTCMonth() + 1;\nlet d = nowPlus8.getUTCDate();\n\nif (isTomorrow) d += 1;\n\nconst suggested_time = `${y}-${pad2(mo)}-${pad2(d)}T${pad2(hour)}:${pad2(minute)}:00+08:00`;\n\n// 5) Topic extraction (SAFE): derive from THIS assistant offer sentence, not history\nlet topic = null;\n\n// Try English \"about <topic>\" pattern\nlet t = assistantText.match(/\\babout\\s+(.+?)(\\?|$)/i);\nif (t && t[1]) {\n  topic = t[1].trim();\n}\n\n// Try Malay \"pasal/mengenai/tentang <topic>\" pattern\nif (!topic) {\n  t = assistantText.match(/\\b(pasal|mengenai|tentang)\\s+(.+?)(\\?|$)/i);\n  if (t && t[2]) topic = t[2].trim();\n}\n\n// Clean trailing filler words\nif (topic) {\n  topic = topic.replace(/\\s+(right|ya|betul)\\s*$/i, '').trim();\n}\n\n// Fallback 1: use current user message text (still safer than scanning long history)\nif (!topic) {\n  topic = (item?.ara_context?.current_message?.text || item?.user_message || '').toString().trim();\n}\n\n// Fallback 2: safe snippet of assistant\nif (!topic) {\n  topic = assistantText.slice(0, 120);\n}\n\n\n// Apply override\nreturn {\n  ...item,\n  pending_action_type: 'reminder_offer',\n  pending_action_payload: {\n    topic,\n    suggested_time,\n  },\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        368
      ],
      "id": "5528e1bf-de81-4f50-9a3f-88a5101cb473",
      "name": "Mixed-Offer Override1"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"assistant_response\": { \"type\": \"string\" },\n    \"pending_action_type\": { \"type\": \"string\" },\n    \"pending_action_payload\": { \"type\": [\"object\", \"null\"] }\n  },\n  \"required\": [\"assistant_response\", \"pending_action_type\", \"pending_action_payload\"],\n  \"additionalProperties\": true\n}\n",
        "autoFix": true
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -576,
        1088
      ],
      "id": "f8d15bb5-c4e4-4a36-9f47-5834e41b812c",
      "name": "Structured Output Parser1",
      "notesInFlow": false
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_create",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0001"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Create"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_list",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0002"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "List"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete_request",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0003"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete Request"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7effae48-3c8b-445c-bdaf-8043843459f1",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f18fc6df-6c26-4714-ba28-fa4560fcec67",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "escalate",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Escalate"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "602c304b-fae9-4ee9-aea5-3622eea25845",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "timezone_update",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update timezone"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "959a4996-035d-4e07-951b-9fe19d261d98",
                    "leftValue": "={{ $json.pending_action_type || $json.output?.pending_action_type || \"\" }}",
                    "rightValue": "update_user_preferences",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update User Profile"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        592,
        288
      ],
      "id": "07fd21f1-2916-473c-993c-4caf1dd74c38",
      "name": "Route Actions Switch"
    },
    {
      "parameters": {
        "jsCode": "// PATCH: Dialogue-state promotion for short confirmations like \"Sure\"\n// Place AFTER \"Format Context with Memory\"\n// Mode: Run Once for All Items ‚úÖ\n\nconst item = $input.first();\nconst j = item?.json ?? {};\nconst ctx = j.ara_context ?? {};\n\n// Helpers\nfunction norm(s = \"\") {\n  return s.toLowerCase().replace(/[\\u200B-\\u200D\\uFEFF]/g, \"\").trim();\n}\n\nfunction isShortYesNo(text) {\n  const t = norm(text);\n  if (!t || t.length > 40) return null;\n\n  const YES = new Set([\n    \"yes\",\"ya\",\"yaa\",\"yaaa\",\"yup\",\"ok\",\"okay\",\"okey\",\"ok lah\",\"okla\",\"boleh\",\n    \"boleh je\",\"proceed\",\"confirm\",\"setkan\",\"set kan\",\"buat\",\"buat je\",\"jom\",\"ye\",\n    \"sure\",\"baik\",\"okey dokey\",\"continue\",\"go on\",\"tell me\",\"more\",\"pls\",\"please\"\n  ]);\n\n  const NO = new Set([\n    \"no\",\"tak\",\"tak nak\",\"tidak\",\"jangan\",\"nope\",\"later\",\"nanti\",\n    \"bukan sekarang\",\"skip\",\"tak payah\",\"cancel\",\"batal\"\n  ]);\n\n  if (YES.has(t)) return \"yes\";\n  if (NO.has(t)) return \"no\";\n  return null;\n}\n\n// Detect if last assistant message looks like an offer/question that expects a short reply\nfunction lastAssistantExpectsReply(lastText = \"\") {\n  const s = norm(lastText);\n  if (!s) return false;\n\n  // Strong signals\n  const hasQuestionMark = s.includes(\"?\");\n  const offerPatterns = [\n    /what would you like to know\\b/i,\n    /would you like\\b/i,\n    /do you want\\b/i,\n    /if you want\\b/i,\n    /if you'd like\\b/i,\n    /i can also\\b/i,\n    /shall i\\b/i,\n    /should i\\b/i,\n    /may i\\b/i,\n    /\\bcan i\\b.*\\bhelp\\b/i,\n    /\\bboleh\\b/i,\n    /\\bnak\\b/i,\n    /\\bmahu\\b/i,\n    /\\bsetuju\\b/i,\n    /\\bsahkan\\b/i\n  ];\n\n  if (hasQuestionMark) return true;\n  return offerPatterns.some(r => r.test(s));\n}\n\n// --- Start patch logic ---\nconst currentText = ctx?.current_message?.text ?? j.user_message ?? \"\";\nconst lastAssistantText =\n  ctx?.last_assistant_message?.text ??\n  ctx?.history?.last_assistant_message?.text ??\n  \"\";\n\n// Keep whatever Format Context decided, unless we have a strong reason to promote\nconst ds = ctx.dialogue_state ?? {};\nlet isActiveResponse = !!ds.isActiveResponse;\nlet activeResponseType = ds.activeResponseType ?? null;\nlet questionType = ds.questionType ?? \"general\";\nlet offerContext = ds.offerContext ?? null;\n\n// Only promote when:\n// - Not already active response\n// - Current message is a short yes/no\n// - Last assistant message likely expects a reply\nif (!isActiveResponse) {\n  const yn = isShortYesNo(currentText);\n  if (yn && lastAssistantExpectsReply(lastAssistantText)) {\n    isActiveResponse = true;\n    activeResponseType = yn;\n\n    // If it was a yes/no to an offer, classify as offer-ish\n    questionType = ds.questionType && ds.questionType !== \"general\" ? ds.questionType : \"offer\";\n    offerContext = ds.offerContext ?? \"offer\";\n  }\n}\n\n// Write back to ara_context safely\nctx.dialogue_state = {\n  ...ds,\n  isActiveResponse,\n  activeResponseType,\n  questionType,\n  offerContext,\n};\n\n// Optional tiny debug (safe to remove later)\n// j._debug_dialogue_patch = { currentText, lastAssistantText, isActiveResponse, activeResponseType, questionType, offerContext };\n\nj.ara_context = ctx;\n\nreturn [{ json: j }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1104,
        864
      ],
      "id": "347188cd-53fb-4f81-96bc-6440c4a9ee2b",
      "name": "Patch Dialogue State1"
    },
    {
      "parameters": {
        "jsCode": "function pad2(n) { return String(n).padStart(2, '0'); }\n\n// KL = UTC+8\nfunction klNow() {\n  const now = new Date();\n  const utcMs = now.getTime() + now.getTimezoneOffset() * 60000;\n  const klMs = utcMs + 8 * 3600000;\n  const d = new Date(klMs);\n\n  const yyyy = d.getUTCFullYear();\n  const mm = d.getUTCMonth() + 1;\n  const dd = d.getUTCDate();\n  const hh = d.getUTCHours();\n  const mi = d.getUTCMinutes();\n  const ss = d.getUTCSeconds();\n\n  return {\n    yyyy, mm, dd,\n    current_date_local: `${yyyy}-${pad2(mm)}-${pad2(dd)}`,\n    current_datetime_local: `${yyyy}-${pad2(mm)}-${pad2(dd)}T${pad2(hh)}:${pad2(mi)}:${pad2(ss)}+08:00`,\n    timezone: \"Asia/Kuala_Lumpur\",\n  };\n}\n\nfunction extractTargetDay(text) {\n  if (!text) return null;\n  // first 1‚Äì31 number found\n  const m = String(text).match(/\\b([1-9]|[12][0-9]|3[01])\\b/);\n  return m ? Number(m[1]) : null;\n}\n\nfunction nextDayOfMonth(yyyy, mm, dd, targetDay) {\n  let y = yyyy, m = mm;\n  if (dd >= targetDay) {\n    m += 1;\n    if (m === 13) { m = 1; y += 1; }\n  }\n  return `${y}-${pad2(m)}-${pad2(targetDay)}`;\n}\n\n// Deep merge helper (simple + safe for plain objects)\nfunction mergeDeep(base, patch) {\n  const out = { ...(base || {}) };\n  for (const [k, v] of Object.entries(patch || {})) {\n    if (v && typeof v === \"object\" && !Array.isArray(v)) {\n      out[k] = mergeDeep(out[k], v);\n    } else {\n      out[k] = v;\n    }\n  }\n  return out;\n}\n\nreturn $input.all().map(item => {\n  const j = item.json || {};\n  const ara = j.ara_context || {};\n\n  const text =\n    ara?.current_message?.text ??\n    j.user_message ??\n    j.message ??\n    j.text ??\n    \"\";\n\n  const now = klNow();\n  const targetDay = extractTargetDay(text) ?? 14;\n\n  const computedPatch = {\n    next_day_of_month_local: nextDayOfMonth(now.yyyy, now.mm, now.dd, targetDay),\n    target_day_of_month: targetDay,\n  };\n\n  const araPatch = {\n    now: {\n      timezone: now.timezone,\n      current_date_local: now.current_date_local,\n      current_datetime_local: now.current_datetime_local,\n    },\n    computed: computedPatch,\n  };\n\n  return {\n    json: {\n      ...j,\n      // IMPORTANT: merge, never replace\n      ara_context: mergeDeep(ara, araPatch),\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1328,
        864
      ],
      "id": "08040f0f-76c6-4f5a-9315-ed498a267283",
      "name": "Compute Now + Next Xth (KL)1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH target AS (\n  SELECT id\n  FROM public.conversations\n  WHERE user_id = $1\n    AND pending_action_resolved = false\n    AND pending_action_type IS NOT NULL\n    AND pending_action_type <> 'none'\n  ORDER BY created_at DESC\n  OFFSET 5\n  LIMIT 1\n)\nUPDATE public.conversations c\nSET pending_action_resolved = true\nFROM target\nWHERE c.id = target.id;\n",
        "options": {
          "queryReplacement": "={{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1168,
        1344
      ],
      "id": "c5075245-a197-475d-ac83-3232efb7c624",
      "name": "Execute a SQL query3"
    },
    {
      "parameters": {
        "jsCode": "// FORMAT CONTEXT WITH MEMORY (SAFE VERSION)\n// This node prepares \"ara_context\" for ARA Main Agent.\n// Mode: Run Once for All Items ‚úÖ\n\n// ============= BOOTSTRAP: CURRENT ITEM (IMPORTANT) =============\nconst current = $input.first()?.json ?? $json ?? {};\n\n// ============= SAFE HELPERS (IMPORTANT) =============\nfunction safeFirst(nodeName) {\n  try {\n    const arr = $items(nodeName);\n    return arr?.[0]?.json ?? null;\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction safeAll(nodeName) {\n  try {\n    const arr = $items(nodeName);\n    return (arr || []).map(i => i?.json ?? i).filter(Boolean);\n  } catch (e) {\n    return [];\n  }\n}\n\n// ============= STEP 1: ARA BRAIN =============\nlet araBrain = '';\ntry {\n  const brainNode = safeFirst('Format Brain2');\n  if (brainNode?.brain_text) araBrain = brainNode.brain_text;\n} catch (e) {\n  // ignore\n}\n\n// ============= STEP 1.5: LOAD CONVERSATIONS =============\nconst convItems = safeAll('Wait for Memory & Session1');\n\n// Flatten and sort oldest ‚Üí newest\nlet conversations = convItems\n  .filter(c => c && c.created_at)\n  .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));\n\nconst MAX_DETAILED = 12;\nconst detailedConversations = conversations.slice(-MAX_DETAILED);\nconst olderConversations = conversations.slice(0, Math.max(0, conversations.length - MAX_DETAILED));\n\nconst olderSummaries = olderConversations.map(c => {\n  const userMsg = c.user_message || '';\n  const assistantMsg = c.assistant_response || '';\n  const summaryField = c.session_summary || c.context_summary || null;\n\n  return {\n    id: c.id,\n    session_id: c.session_id || null,\n    created_at: c.created_at,\n    user_message_preview: userMsg.slice(0, 120),\n    assistant_response_summary: summaryField || assistantMsg.slice(0, 160),\n  };\n});\n\nconst lastConversation = conversations.length ? conversations[conversations.length - 1] : null;\n\nconst lastAssistant =\n  [...conversations].reverse().find(c => (c.assistant_response || '').trim() !== '') || null;\n\n// ============= STEP 2: LOAD USER + MEMORIES =============\nlet userData = {};\ntry {\n  userData = safeFirst('Get User1') || {};\n} catch (e) {\n  userData = {};\n}\n\nlet userMemories = [];\ntry {\n  const memNode = safeFirst('Get User Memories1') || {};\n  userMemories = memNode.data || memNode.memories || [];\n} catch (e) {\n  userMemories = [];\n}\n\nconst importantMemories = userMemories.filter(m => {\n  const score = typeof m.importance_score === 'number' ? m.importance_score : 1;\n  return score >= 0.7;\n});\n\n// ============= STEP 3: CURRENT MESSAGE TEXT (DETERMINISTIC) =============\nfunction pickFirstText() {\n  // IMPORTANT: Continue Session might NOT run. Create New Session might run instead.\n  const cont = safeFirst('Continue Session');\n  const create = safeFirst('Create New Session');\n\n  const a = cont?.user_message;\n  if (typeof a === 'string' && a.trim()) return a.trim();\n\n  const a2 = create?.user_message;\n  if (typeof a2 === 'string' && a2.trim()) return a2.trim();\n\n  const b = safeFirst('Prepare Incoming Message')?.chatInput;\n  if (typeof b === 'string' && b.trim()) return b.trim();\n\n  const c = safeFirst('Twilio Webhook')?.body?.Body;\n  if (typeof c === 'string' && c.trim()) return c.trim();\n\n  const d = current?.user_message || current?.message || current?.text;\n  if (typeof d === 'string' && d.trim()) return d.trim();\n\n  return '';\n}\n\nconst currentText = pickFirstText();\nconst currentLower = (currentText || '').toLowerCase();\n\n// ============= STEP 3A: LANGUAGE DETECTION HELPERS =============\nfunction detectLangFromText(t = '') {\n  const s = (t || '').toLowerCase();\n  const msHits = /\\b(saya|awak|anda|boleh|tak|tidak|jangan|macam|kenapa|tq|terima kasih|semula|kejap|sekejap|nak|ingatkan|padam|perlu|tolong)\\b/i.test(s);\n  const enHits = /\\b(i|you|can|please|pls|thanks|thank you|again|later|now|what|why|sure|ok)\\b/i.test(s);\n\n  if (msHits && !enHits) return 'ms';\n  if (enHits && !msHits) return 'en';\n  if (msHits && enHits) return 'mixed';\n  return null;\n}\n\nfunction lastNonEmptyUserMsgFromHistory(convos) {\n  const c = [...(convos || [])].reverse().find(x => (x.user_message || '').trim() !== '');\n  return c?.user_message || '';\n}\n\nfunction langFromPreference(u) {\n  const pref = (u?.preferred_language || u?.language_preference || '').toString().toLowerCase();\n  if (pref.startsWith('ms') || pref.includes('bm') || pref.includes('malay')) return 'ms';\n  if (pref.startsWith('en')) return 'en';\n  if (pref.startsWith('id')) return 'id';\n  return null;\n}\n\nfunction emptyNudge(lang) {\n  if (lang === 'ms') return \"Hmm, saya tak dapat mesej tadi üòÖ\\nBoleh taip semula sikit?\";\n  if (lang === 'id') return \"Hmm, aku nggak nangkep pesan tadi üòÖ\\nBisa ketik ulang sebentar?\";\n  return \"Hmm, I didn‚Äôt catch that üòÖ\\nCould you type it again?\";\n}\n\n// ============= STEP 3B: REPLY LANGUAGE (DETERMINISTIC) =============\nlet replyLanguage = detectLangFromText(currentText);\n\nif (!replyLanguage) {\n  const lastUserMsg = lastNonEmptyUserMsgFromHistory(conversations);\n  replyLanguage = detectLangFromText(lastUserMsg);\n}\n\nif (!replyLanguage) replyLanguage = langFromPreference(userData);\nif (!replyLanguage) replyLanguage = 'en';\n\n// ============= STEP 3C: EMPTY MESSAGE GUARD =============\nif (!currentText) {\n  const lastUserMsg = lastNonEmptyUserMsgFromHistory(conversations);\n  const lang = detectLangFromText(lastUserMsg) || langFromPreference(userData) || 'en';\n\n  const minimalAraContext = {\n    reply_language: lang,\n    user: {\n      id: userData.id || null,\n      preferred_name: userData.preferred_name || null,\n      language_preference: userData.preferred_language || 'auto',\n      timezone: userData.current_timezone || userData.home_timezone || userData.timezone || 'Asia/Kuala_Lumpur',\n      home_timezone: userData.home_timezone || null,\n      current_timezone: userData.current_timezone || null,\n      style_profile: { ...(userData.style_profile || {}), language_mix_cap: 0.3 },\n    },\n    current_message: { text: '' },\n    history: {\n      detailed: detailedConversations.map(c => ({\n        created_at: c.created_at,\n        role: c.role || null,\n        user_message: c.user_message || '',\n        assistant_response: c.assistant_response || '',\n        session_id: c.session_id || null,\n      })),\n      older_summaries: olderSummaries,\n    },\n    memories: { important: importantMemories, all: userMemories },\n    last_assistant_message: lastAssistant ? { created_at: lastAssistant.created_at, text: lastAssistant.assistant_response || '' } : null,\n    dialogue_state: { isActiveResponse: false, activeResponseType: null, questionType: 'general', offerContext: null, pendingAction: null },\n  };\n\n  return [\n    {\n      json: {\n        ara_context: minimalAraContext,\n        assistant_response: emptyNudge(lang),\n        pending_action_type: 'none',\n        pending_action_payload: null,\n        ...current,\n      },\n    },\n  ];\n}\n\n// ============= STEP 4: PENDING ACTION & YES/NO DETECTION =============\nfunction isShortYesNo(text) {\n  if (!text) return null;\n  const t = text.trim().toLowerCase();\n  if (t.length === 0 || t.length > 40) return null;\n\n  const YES = ['yes','ya','yaaa','yup','ok','okay','okey','ok lah','okla','boleh','boleh je','proceed','confirm','set kan','buat','buat je','jom','ye','sure','baik','okey dokey'];\n  const NO  = ['no','tak','tak nak','tidak','jangan','nope','later','nanti','bukan sekarang','skip','tak payah','cancel','batal'];\n\n  if (YES.includes(t)) return 'yes';\n  if (NO.includes(t)) return 'no';\n  return null;\n}\n\nfunction isWithinHours(dateStr, hours) {\n  if (!dateStr) return false;\n  const then = new Date(dateStr).getTime();\n  const now = Date.now();\n  const diffH = (now - then) / (1000 * 60 * 60);\n  return diffH <= hours;\n}\n\nlet isActiveResponse = false;\nlet activeResponseType = null;\nlet questionType = 'general';\nlet offerContext = null;\nlet pendingAction = null;\n\nconst lastAssistantText = lastAssistant ? (lastAssistant.assistant_response || '') : '';\n\nif (lastAssistant) {\n  if (lastAssistant.pending_action_type && lastAssistant.pending_action_type !== 'none') {\n    pendingAction = {\n      type: lastAssistant.pending_action_type,\n      payload: lastAssistant.pending_action_payload || null,\n      resolved: !!lastAssistant.pending_action_resolved,\n      created_at: lastAssistant.created_at,\n    };\n  } else if (lastAssistantText) {\n    const match = lastAssistantText.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})\\s*$/);\n    if (match) {\n      try {\n        const pa = JSON.parse(match[1]);\n        if (pa.type && pa.type !== 'none') {\n          pendingAction = { type: pa.type, payload: pa.payload || null, resolved: false, created_at: lastAssistant.created_at };\n        }\n      } catch (e) {}\n    }\n  }\n}\n\nconst shortYesNo = isShortYesNo(currentText);\n\nif (pendingAction?.type && pendingAction.type !== 'none' && isWithinHours(pendingAction.created_at, 48) && shortYesNo) {\n  isActiveResponse = true;\n  activeResponseType = shortYesNo;\n  questionType = 'offer';\n  offerContext = pendingAction.type;\n}\n\nif (!isActiveResponse && lastAssistantText) {\n  const lastText = lastAssistantText.toLowerCase();\n\n  const hasQuestionMark = lastText.includes('?');\n  const hasOfferPattern = /would you like|nak tak|mahu tak|do you want|shall i|should i|may i|can i help|if you‚Äôd like|kalau nak/i.test(lastText);\n  const hasClarificationPattern = /could you clarify|apa yang dimaksud|what do you mean|which one do you mean|yang mana satu/i.test(lastText);\n  const hasConfirmationPattern = /is this correct|is that right|betul tak|setuju tak|confirm/i.test(lastText);\n  const hasChoicePattern = /\\bor\\b|atau\\b/i.test(lastText);\n\n  if (hasOfferPattern) questionType = 'offer';\n  else if (hasClarificationPattern) questionType = 'clarification';\n  else if (hasConfirmationPattern) questionType = 'confirmation';\n  else if (hasChoicePattern) questionType = 'choice';\n  else if (hasQuestionMark) questionType = 'general';\n\n  if (shortYesNo && (hasOfferPattern || hasConfirmationPattern || hasChoicePattern)) {\n    isActiveResponse = true;\n    activeResponseType = shortYesNo;\n    offerContext = hasOfferPattern ? 'offer' : hasConfirmationPattern ? 'confirmation' : 'choice';\n  }\n}\n\n// ============= STEP 5: BUILD ARA CONTEXT =============\nconst araContext = {\n  reply_language: replyLanguage,\n  user: {\n    id: userData.id || null,\n    name: userData.name || userData.full_name || null,\n    phone: userData.phone || userData.telegram_id || null,\n    preferred_name: userData.preferred_name || null,\n    language_preference: userData.preferred_language || 'auto',\n    features_enabled: userData.features_enabled || null,\n    timezone: userData.current_timezone || userData.home_timezone || userData.timezone || 'Asia/Kuala_Lumpur',\n    home_timezone: userData.home_timezone || null,\n    current_timezone: userData.current_timezone || null,\n    style_profile: { ...(userData.style_profile || {}), language_mix_cap: 0.3 },\n  },\n  current_message: { text: currentText, language_hint: null },\n  history: {\n    detailed: detailedConversations.map(c => ({\n      created_at: c.created_at,\n      role: c.role || null,\n      user_message: c.user_message || '',\n      assistant_response: c.assistant_response || '',\n      session_id: c.session_id || null,\n    })),\n    older_summaries: olderSummaries,\n  },\n  memories: { important: importantMemories, all: userMemories },\n  last_assistant_message: lastAssistant ? { created_at: lastAssistant.created_at, text: lastAssistant.assistant_response || '' } : null,\n  dialogue_state: { isActiveResponse, activeResponseType, questionType, offerContext, pendingAction },\n};\n\nreturn [\n  {\n    json: {\n      ara_context: araContext,\n      ...current,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1552,
        864
      ],
      "id": "f1afd8fe-db41-4535-8990-ff362f19afeb",
      "name": "Format Context with Memory2"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ara_brain_rules",
        "limit": 100,
        "filters": {
          "conditions": [
            {
              "keyName": "is_active",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2000,
        864
      ],
      "id": "9025fdc4-e758-40ce-8341-0826087579c4",
      "name": "Get ARA Brain2",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// FORMAT ARA brain rows into a single text block\n// STRICT WHITELIST: escalate, timezone_update, update_user_preferences\n\nconst ALLOWED_PENDING_ACTIONS = [\n  'escalate',\n  'timezone_update',\n  'update_user_preferences',\n];\n\n// Get all rows\nconst items = $input.all();\nlet rows = items.map(i => i.json).filter(Boolean);\n\n// Keep only active rules\nrows = rows.filter(r => r.is_active !== false);\n\n// Keep ONLY rules related to allowed pending actions\nrows = rows.filter(r => {\n  const content = (r.content || '').toLowerCase();\n  return ALLOWED_PENDING_ACTIONS.some(action =>\n    content.includes(action)\n  );\n});\n\n// Sort for determinism (simple + safe)\nrows.sort((a, b) => {\n  const pa = Number.isFinite(+a.priority) ? +a.priority : 1000;\n  const pb = Number.isFinite(+b.priority) ? +b.priority : 1000;\n  if (pa !== pb) return pa - pb;\n\n  const ta = (a.title || '').toString().toLowerCase();\n  const tb = (b.title || '').toString().toLowerCase();\n  return ta.localeCompare(tb);\n});\n\n// Build brain text\nlet brainText = '[PENDING ACTION WHITELIST]\\n';\n\nfor (const row of rows) {\n  const title = (row.title || '').toString().trim();\n  const content = (row.content || '').toString().trim();\n  if (!content) continue;\n\n  const label = title ? `(${title}) ` : '';\n  brainText += `- ${label}${content}\\n`;\n}\n\nbrainText = brainText.trim();\n\n// Return single item\nreturn [\n  {\n    json: {\n      brain_text: brainText,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1776,
        864
      ],
      "id": "a8539253-4b0d-4587-b54a-27a61308622f",
      "name": "Format Brain2"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Current message:\n{{$node[\"Get Latest Conversation2\"].json[\"user_message\"]\n  || $node[\"Patch Dialogue State1\"].json[\"ara_context\"].current_message.text\n  || $json[\"user_message\"]\n  || $json[\"message\"]\n  || \"\"}}\n\nLast assistant message (most recent):\n{{$node[\"Patch Dialogue State1\"].json[\"ara_context\"].last_assistant_message?.text\n  || \"\"}}\n\nARA context (JSON):\n{{JSON.stringify($node[\"Patch Dialogue State1\"].json[\"ara_context\"])}}\n",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "=ABOUT ARA\nYou are ARA, a human-like WhatsApp assistant built by Coach Joe (Joeherry Gani) under ARA Ai Solution, a Malaysian AI company.\nYour job is to help users stay organised, remember important things, and manage daily tasks.\nYou always reply in the language specified by ara_context.reply_language (deterministic). Match the user‚Äôs energy/tone.\nYou remember past conversations and use them naturally.\n\nABOUT COACH JOE\nCoach Joe is your founder and CEO of ARA Ai Solution. He is a Malaysian business coach who helps entrepreneurs improve their systems, mindset, and daily operations.\nYou speak about him confidently, respectfully, and naturally ‚Äî like an assistant who knows her boss well.\n\nABOUT ARA AI SOLUTION\nARA Ai Solution is the company behind you. The company‚Äôs mission is to deliver simpoutputle, human-first AI assistance through WhatsApp without any apps or technical setup.\nThe vision: to help people run their life and business more smoothly using a caring, smart assistant. the company website is www.araaisolution.com. this whatsapp number +60 11-259 11400 is the number users use to communicate with you, not a number to contact the company or Coach Joe. to contact a human in the company, user can email at admin@araaisolution.com\n\nHOW YOU TALK ABOUT YOURSELF\nWhen the user asks what ARA is (any language/tone), introduce yourself as the WhatsApp assistant built by ARA Ai Solution that helps users organise life, remember important things, and manage daily tasks.\nWhen the user asks about Coach Joe (any language/tone), explain he is the founder of ARA Ai Solution and a business coach who helps entrepreneurs manage and improve their businesses clearly and calmly.\nAlways reply in the language specified by ara_context.reply_language (deterministic), while matching the user‚Äôs energy/tone.\n\nOUTPUT FORMAT (STRICT)\nYou MUST output ONLY a valid JSON object that matches this schema:\n\n{\n\"assistant_response\": \"string\",\n\"pending_action_type\": \"string\",\n\"pending_action_payload\": \"object|null\"\n}\n\nDo not include any extra text before or after the JSON.\nDo not use markdown code blocks.\n\nIf no action is needed:\n\npending_action_type = \"none\"\n\npending_action_payload = null\n\nIf user refers to ‚Äúnext {day}‚Äù, use ara_context.computed.next_day_of_month_local and do not ask for the date.\n\nWHATSAPP READABILITY RULES (STRICT)\n\n- Avoid long paragraphs.\n- Maximum 2 sentences per paragraph.\n- Insert a line break before each new idea or numbered point.\n- Explanatory replies must be easy to scan on a mobile screen.\n- If a response explains something, break it into short lines or sections.\n\n\n\nüîß OUTPUT STRUCTURE PATCH (CRITICAL ‚Äì DO NOT IGNORE)\n\nThe JSON you output MUST be a real JSON object, not a string.\n\nRules:\n‚Ä¢ Do NOT wrap the JSON inside quotes\n‚Ä¢ Do NOT nest it inside another key like \"output\"\n‚Ä¢ Do NOT return JSON as text\n‚Ä¢ Do NOT stringify the object\n\n‚úÖ Correct (object):\n\n{ \"assistant_response\": \"...\", \"pending_action_type\": \"...\", \"pending_action_payload\": null }\n\n\n‚ùå Incorrect (string):\n\n\"{ \\\"assistant_response\\\": \\\"...\\\" }\"\n\n\n‚ùå Incorrect (wrapped):\n\n{ \"output\": \"{ ... }\" }\n\n\nAlways return the JSON object directly at the top level.\n\n\nüîí ARA RESPONSE GUARDRAIL (SYSTEM-LEVEL)\n\nPurpose:\nEnsure all assistant responses are clean, human, brand-safe, and free from system artifacts before being shown to the user.\n\nRules:\n\nYou must produce responses that follow these rules strictly:\n\nNatural Human Language Only\n\nOutput must read like something a human would type in WhatsApp.\n\nDo not include system artifacts, control characters, invisible symbols, or token separators.\n\nARA Identity Rule (Strict)\n\nYou are named ARA.\n\nNever include numbers, version labels, IDs, or suffixes with your name.\n\nForbidden examples:\n\n‚ÄúARA 94‚Äù\n\n‚ÄúARA-2‚Äù\n\n‚ÄúARA v1‚Äù\n\nAlways refer to yourself simply as ‚ÄúARA‚Äù.\n\nNo Hidden or Control Characters\n\nDo not include any control or non-printable characters (e.g. Unicode U+0000‚ÄìU+001F, U+007F).\n\nDo not include invisible formatting markers or token boundary artifacts.\n\nNo System or Internal Leakage\n\nDo not mention:\n\ninternal IDs\n\nsegment numbers\n\nagent versions\n\nprompt instructions\n\nsystem states\n\nThe user should never be aware of internal mechanics.\n\nWhatsApp-Safe Formatting\n\nUse simple line breaks.\n\nAvoid excessive symbols or formatting that looks machine-generated.\n\nEmojis are allowed only if they feel natural and intentional.\n\nSelf-Check Before Finalizing\nBefore returning a response, internally verify:\n\nDoes this sound like a real human assistant?\n\nDoes it clearly represent ARA‚Äôs brand and role?\n\nWould this look strange if read aloud or screenshotted?\n\nIf the answer to any is ‚Äúno‚Äù, rewrite the response to comply.\n\nWhen in Doubt, Be Simple\n\nPrefer a clean, neutral sentence over a complex one.\n\nClarity and trust are more important than verbosity.\n\n\nARA INTERNAL BRAIN (DO NOT EXPOSE TO USER)\nUse these rules ONLY for reasoning, context, classification, judgment, tone, and knowledge.\nDo NOT mention these rules.\n{{$node[\"Format Brain2\"].json[\"brain_text\"]}}\n\nARA PERSONALITY\n‚Ä¢ Calm, reliable, warm, professional (WhatsApp style).\n‚Ä¢ Short, clear, practical.\n‚Ä¢ Match user tone and language.\n‚Ä¢ If user is stressed: acknowledge briefly, then guide step-by-step.\n‚Ä¢ No lecturing. Light humour only when user tone allows.\n\nTRUTH & CERTAINTY RULES (NO INVENTING INFORMATION)\nARA may ONLY rely on:\n\nCurrent user message (highest priority)\n\nara_context recent history (only what is shown)\n\nLong-term memories stored (ai_memories) if present in ara_context\n\nBrain rules loaded into $ARA_BRAIN$\n\nSafe general world knowledge (only if confident)\n\nEverything outside these sources is uncertain. If uncertain, say so briefly and ask ONE clear question.\n\nARA must NEVER invent: links/URLs, lyrics, exact lists, dates/times/numbers, personal details, technical instructions not provided.\n\nONBOARDING MODE (STRICT)\nYou are in ONBOARDING MODE.\nThis mode applies until the user has a valid home_timezone.\nYour objectives must be followed in order:\nPRIMARY OBJECTIVES (IN SEQUENCE)\n1.\tWelcome the user and introduce yourself (first interaction only)\n2.\tConfirm the user‚Äôs preferred language\n3.\tRegister the user‚Äôs current timezone using the TIMEZONE ENGINE\n4.\tAnswer general (non-reminder) questions normally\n‚ö†Ô∏è CRITICAL RULE\nYou must NEVER ask for language confirmation and timezone in the same message.\n\n‚è±Ô∏è TIMEZONE REQUEST SUPPRESSION (ANTI-PUSHINESS RULE)\nThis rule is mandatory and overrides default onboarding behavior.\nMEMORY-AWARE TIMEZONE HANDLING\nIf ARA context indicates that:\n‚Ä¢\tA timezone request has already been asked in a previous conversation turn\n(e.g. ARA already asked for city/country/timezone),\n‚Ä¢\tAND the user has not responded with timezone information yet,\nThen ARA MUST:\n‚úÖ NOT ask for timezone again\n‚úÖ NOT ask for the user‚Äôs location again\n‚úÖ Continue the conversation normally\nThis suppression remains active until one of the following happens:\nüîì ONLY ALLOWED TO ASK FOR TIMEZONE AGAIN IF:\n1.\tThe user explicitly asks to:\no\tcreate / set / schedule a reminder, OR\no\tmanage / delete / modify a reminder, OR\no\tasks about reminders in a way that requires timing accuracy\nOnly in these cases may ARA politely re-request timezone, explaining why it is required.\n‚ö†Ô∏è ARA must NEVER repeatedly ask for timezone or location on her own initiative.\n\nREMINDER RESTRICTION (HARD RULE)\nDuring onboarding:\n‚Ä¢\tYou MAY explain reminders conceptually\n‚Ä¢\tYou MUST NOT:\no\tCreate, list, delete, modify, confirm, or summarise reminders\no\tAsk reminder-specific clarification questions\no\tEmit any reminder-related ARA_PENDING actions\nThis restriction applies even if the user asks clearly for a reminder.\n\nHANDLING REMINDER REQUESTS BEFORE TIMEZONE IS SET\nIf the user asks to:\n‚Ä¢\tset / create / schedule\n‚Ä¢\tdelete / cancel\n‚Ä¢\tmanage / change\n‚Ä¢\tconfirm / check a reminder\nAND home_timezone is NOT yet confirmed, you MUST:\n1.\tPolitely explain (in the user‚Äôs newest message language) that reminders require timezone accuracy\n2.\tClearly state that timezone is needed to ensure correct timing\n3.\tRedirect the conversation to timezone registration\n4.\tDo NOT:\no\tAsk reminder follow-up questions\no\tSummarise reminder details\no\tStore or repeat reminder information\nFor this turn ONLY:\nARA_PENDING: {\"type\":\"none\"}\nExample (Malay)\n‚ÄúSaya boleh bantu set reminder, tapi sebelum itu saya perlu tahu zone waktu awak supaya masa tepat. Awak berada di bandar atau negara mana sekarang?‚Äù\nExample (English)\n‚ÄúI can help with reminders, but I need your timezone first so the timing is accurate. Which city or country are you currently in?‚Äù\n\nWHAT ‚ÄúANSWER GENERAL QUESTIONS NORMALLY‚Äù MEANS\nAllowed:\n‚Ä¢\tExplaining what ARA can do\n‚Ä¢\tExplaining how reminders work conceptually\n‚Ä¢\tBusiness questions\n‚Ä¢\tScheduling advice (without creating reminders)\n‚Ä¢\tGeneral explanations\nNot allowed:\n‚Ä¢\tAny reminder execution\n‚Ä¢\tAny reminder confirmation\n‚Ä¢\tAny reminder clarification questions\n\nWELCOME LOGIC (FIRST CONTACT DETECTION)\nYou will receive a field called assistant_response.\nIf assistant_response is null or empty:\n‚Ä¢\tThis is the first-ever interaction\n‚Ä¢\tYou MUST perform the WELCOME USER flow\nIf assistant_response is not null and not empty:\n‚Ä¢\tThe user has interacted before\n‚Ä¢\tSkip the full welcome\n‚Ä¢\tProceed directly to:\no\tTimezone registration (if not yet set and not suppressed), OR\no\tNormal conversation\n\nWELCOME USER FLOW (FIRST INTERACTION ONLY)\nGenerate ONE WhatsApp message with:\n‚Ä¢\tShort paragraphs\n‚Ä¢\tBlank lines between paragraphs\n‚Ä¢\tFriendly, human tone\nMessage structure:\n1Ô∏è‚É£ Greeting\n‚Ä¢\tIf it likely came from Coach Joe‚Äôs business card:\n‚ÄúHi! üòä Terima kasih contact ARA melalui kad bisnes CEO kami, Coach Joe.‚Äù\n‚Ä¢\tOtherwise:\n‚ÄúHi! üòä Terima kasih contact ARA.‚Äù\n2Ô∏è‚É£ Brief introduction\n‚ÄúSaya ARA ‚Äî pembantu AI yang ingat perbualan, faham awak dan bisnes awak, dan bantu ingatkan perkara penting supaya awak tak terlepas peluang.‚Äù\n3Ô∏è‚É£ Language confirmation\n‚ÄúBy the way, bahasa yang saya guna ni okay tak? Atau awak lebih selesa dalam English atau bahasa lain?‚Äù\nSend the message.\nDo NOT ask for timezone in this same message.\n\nTIMEZONE REGISTRATION (ONBOARDING FOCUS)\nOnly if:\n‚Ä¢\tLanguage is confirmed (explicitly or implicitly), AND\n‚Ä¢\tNo prior timezone request is currently suppressed\nPolitely explain (in the user‚Äôs newest message language) that timezone is needed so future reminders and follow-ups are accurate.\nAsk for ONE of the following:\n‚Ä¢\tTheir current city or country, OR\n‚Ä¢\tTheir timezone (e.g. GMT+8)\nExample (Malay)\n‚ÄúUntuk saya bantu urus reminder dengan tepat nanti, saya perlu tahu zone waktu awak sekarang. Awak berada di bandar mana ya? (contoh: KL, London, Hong Kong)‚Äù\nAfter this, follow the TIMEZONE ENGINE rules exactly.\n\n\nCRITICAL LANGUAGE RULE (DETERMINISTIC)\nAlways follow ara_context.reply_language for response language.\n\nIf \"en\": reply fully in English.\n\nIf \"ms\": reply fully in Malay.\n\nIf \"mixed\": mirror the user‚Äôs mix style and respect style_profile.language_mix_cap.\n\n\nCONTEXT HANDLING (ara_context)\nYou receive ara_context containing:\n‚Ä¢ user profile & preferences\n‚Ä¢ recent conversation history\n‚Ä¢ dialogue_state:\n\nisActiveResponse (bool)\n\nactiveResponseType (\"yes\" | \"no\" | null)\n\npendingAction (object or null)\n\nIf dialogue_state.isActiveResponse is true and pendingAction exists, treat short replies (‚Äúyes‚Äù, ‚Äúok‚Äù, ‚Äúboleh‚Äù, etc.) as answers to that pending action.\n\nIf user explicitly selects English in that language choice step, ARA must reply in English in the same turn, even if ara_context.reply_language was previously \"ms\".\n\n\nUSER PROFILE & LANGUAGE PREFERENCE UPDATES\nIf the user asks to change name and/or language, output:\n\npending_action_type = \"update_user_preferences\"\n\npending_action_payload = {\n\"preferred_name\": \"<string or null>\",\n\"preferred_language\": \"ms\" | \"en\" | \"id\" | null\n}\n\nRules:\n\nOnly include fields explicitly changed.\n\nIf ambiguous: ask ONE clarifying question and output pending_action_type=\"none\".\nLanguage code mapping:\n\nMalay/BM/Bahasa/Bahasa Melayu ‚Üí \"ms\"\n\nEnglish/Inggeris ‚Üí \"en\"\n\nIndonesian/Bahasa Indonesia/Indo ‚Üí \"id\"\n\nLanguage keyword detection (case-insensitive)\n\nTreat language keywords as case-insensitive.\n\nAccept common short forms:\n\nEnglish: \"en\", \"eng\", \"english\", \"inggeris\"\n\nMalay: \"ms\", \"bm\", \"bahasa\", \"bahasa melayu\", \"malay\"\n\nIndonesian: \"id\", \"indo\", \"indonesian\", \"bahasa indonesia\"\n\nIf the last assistant message asked language preference (choice), and user replies with a language word (English/BM/etc), treat it as a preference update and emit update_user_preferences.\n\nLanguage selection MUST write to profile\n\nIf the last assistant message asked about language, and the user replies with a language keyword (‚Äúenglish‚Äù, ‚Äúbm‚Äù, etc.), then:\n\nALWAYS emit pending_action_type=\"update_user_preferences\"\n\nEVEN IF ara_context.reply_language already matches that language\n\nBecause the goal is to update user.language_preference, not just reply language.\n\nIf user requests English and ara_context.user.language_preference !== \"en\", emit update.\n\n\nPENDING ACTION CONFIRMATION LOGIC (IMPORTANT)\nWhen ara_context.dialogue_state.pendingAction exists AND isActiveResponse is true:\n\nTimezone offer confirmation\nIf pendingAction.type === \"timezone_offer\":\n\nIf activeResponseType === \"yes\":\nOutput pending_action_type=\"timezone_update\"\nOutput pending_action_payload = pendingAction.payload\n\nIf activeResponseType === \"no\":\nOutput pending_action_type=\"none\"\nOutput pending_action_payload=null\n\n\nTIMEZONE ENGINE (HOME_TIMEZONE = SOURCE OF TRUTH)\n\nTimezone is confirmed ONLY when ara_context.user.home_timezone is not null/empty.\n\nIgnore ara_context.user.timezone if it is \"UTC\" (default placeholder).\n\nIf ara_context.user.home_timezone exists (not null/empty):\n\nDo NOT ask for timezone again unless the user clearly indicates they changed location/timezone.\n\nIf ara_context.user.home_timezone is null/empty (timezone NOT confirmed):\n\nIf the user provides a clear city/timezone (e.g., ‚ÄúKL‚Äù, ‚ÄúKuala Lumpur‚Äù, ‚ÄúGMT+8‚Äù):\n\nOutput:\n\npending_action_type = \"timezone_update\"\n\npending_action_payload = { \"timezone\": \"<IANA>\", \"timezone_label\": \"<human label>\" }\n\nDo NOT output timezone_offer for clear cases.\n\nIf the user provides an unclear location (e.g., ‚ÄúMalaysia‚Äù, ‚Äúsomewhere‚Äù, ‚Äúhere‚Äù):\n\nAsk ONE short clarification question (city or timezone).\n\nOutput pending_action_type=\"none\" and pending_action_payload=null.\n\nCity ‚Üí Timezone mapping (minimum required)\n\n‚ÄúKL‚Äù / ‚ÄúKuala Lumpur‚Äù / ‚ÄúSelangor‚Äù ‚Üí Asia/Kuala_Lumpur with label Kuala Lumpur (GMT+8)\n\n\n[CONVERSATION CONTINUATION ‚Äî CRITICAL]\n\nRULE:\nIf the user sends a short or incomplete follow-up message such as:\n- ‚ÄúTell me‚Äù\n- ‚ÄúGo on‚Äù\n- ‚ÄúContinue‚Äù\n- ‚ÄúMore‚Äù\n- ‚ÄúYes‚Äù\n- ‚ÄúThat one‚Äù\n- ‚ÄúOkay‚Äù\n- ‚ÄúPls do‚Äù\n\nAND there is a clear, recent assistant message within the same session,\n\nTHEN:\n- ARA MUST treat the message as a continuation of the previous assistant message,\n- NOT as a new topic or fresh question,\n- AND continue elaborating on the last subject mentioned by ARA.\n\nEXPLICITLY NOT ALLOWED:\n- Restarting self-introduction\n- Repeating ‚ÄúI‚Äôm ARA‚Ä¶‚Äù unless the user explicitly asks again\n- Ignoring the immediate conversational context\n\n\nENHANCED ESCALATION TRIGGERS (NO CONFIRMATION NEEDED)\n1) Negative escalation trigger rules\n\nEscalate with intent:\"negative\" when ANY of these are true:\n\nA. Clear dissatisfaction / complaint (direct)\n\nUser expresses anger, disappointment, mistrust, or ‚Äúyou‚Äôre not helping‚Äù\n\nMentions scam, cheating, useless, waste of time, ‚Äúbad service‚Äù\n\nB. Repeated failure\n\nThe same issue persists after 2 assistant attempts (or user says ‚Äústill not working‚Äù, ‚Äúsame problem‚Äù)\n\nC. Human request due to problem\n\n‚ÄúLet me talk to human/admin/support‚Äù in the context of an issue\n\nD. High-risk topics\n\nBilling/charges/refunds\n\nPrivacy/data/security\n\nLegal threats or public complaint (‚ÄúI will report you / post on social media‚Äù)\n\nE. Strong negative language (auto high urgency)\nIf message includes insults/threats or ‚ÄúI‚Äôm very angry‚Äù, set:\n\nurgency: \"high\"\n\n‚úÖ Don‚Äôt escalate just because user is brief (‚Äú??‚Äù, ‚Äúbro‚Äù) or confused once.\nWait for either clear negative sentiment OR second failure.\n\n2) Positive escalation trigger rules\n\nEscalate with intent:\"positive\" when ANY of these are true:\n\nA. Contact request\n\nUser asks to contact Coach Joe / ARA team / sales / partnership\n\nB. Buying intent\n\nPricing, packages, subscription, enterprise, ‚Äúhow to join‚Äù, ‚Äúhow to sign up‚Äù\n\nWants demo, onboarding for company/team\n\nC. Program interest\n\nCoaching, courses, training, speaking, collaboration\n\n‚úÖ If it‚Äôs just ‚Äútell me about ARA‚Äù, you can answer normally first.\nEscalate only when they want direct contact or show purchase intent.\n\nSMOOTHER RESPONSE STYLE (so it feels human)\nNegative escalation response pattern (3 beats)\n\nAcknowledge + apologize\n\nConfirm escalation done\n\nReassure next step (no email needed)\n\nExample:\n\n‚ÄúSorry about that üôè I understand. I‚Äôve escalated this to the ARA Ai Solution team so a human can review it. You don‚Äôt need to do anything else‚Äîsomeone will follow up.‚Äù\n\nPositive escalation response pattern (3 beats)\n\nEnthusiastic acknowledgement\n\nConfirm escalation done\n\nReassure next step (no email needed)\n\nExample:\n\n‚ÄúYes, can üòä I‚Äôve escalated your request to the ARA Ai Solution team so Coach Joe (or the team) can follow up. You don‚Äôt need to do anything else‚Äîsomeone will reach out.‚Äù\n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        -656,
        864
      ],
      "id": "51b66515-c7ca-469c-8f12-da0fc302c5a8",
      "name": "ARA Onboarding Agent"
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first().json;\n\nfunction sanitizeText(s) {\n  if (typeof s !== 'string') return s;\n  // Remove NUL + other control chars except newline/tab/CR\n  // Removes U+0000..U+001F except \\n (0x0A), \\r (0x0D), \\t (0x09), plus DEL (0x7F)\n  return s\n    .replace(/\\u0000/g, '')\n    .replace(/[\\u0001-\\u0008\\u000B\\u000C\\u000E-\\u001F\\u007F]/g, '');\n}\n\nitem.assistant_response = sanitizeText(item.assistant_response);\nitem.pending_action_type = sanitizeText(item.pending_action_type);\n\nreturn [{ json: item }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        368,
        960
      ],
      "id": "f67c8d02-cb22-4c72-ab2e-99d0c00b812a",
      "name": "Sanitize Assistant Response"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ String((($json.body?.Body ?? '').trim() !== '' && Number($json.body?.NumMedia ?? 0) === 0)) }}",
                    "rightValue": "true",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "70e3f09c-c359-4e09-b7d6-7ec5a9407956"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        -4992,
        2176
      ],
      "id": "97b460bd-ac16-49f4-be25-8dfa27502188",
      "name": "SW - text only?"
    },
    {
      "parameters": {
        "jsCode": "// JS - nontext reply text\n// Mode: Run Once for Each Item ‚úÖ\n\n// -----------------------------\n// 1) Twilio inbound payload\n// -----------------------------\nconst tw = $json.body ?? {};\n\n// Always reply to the sender (fallback to telegram_id digits)\nconst wa_to = tw.From || ($json.telegram_id ? `whatsapp:+${$json.telegram_id}` : null);\n\nif (!wa_to) {\n  throw new Error('Missing wa_to: neither body.From nor telegram_id is available');\n}\n\n// -----------------------------\n// 2) User fields (from PG result)\n// -----------------------------\nconst preferred_language_raw = $json.preferred_language ?? null;\nconst preferred_name_raw = $json.preferred_name ?? null;\nconst telegram_username_raw = $json.telegram_username ?? null;\nconst first_name_raw = $json.first_name ?? null;\n\n// Normalize language (default ms)\nconst lang = String(preferred_language_raw || 'ms').toLowerCase().trim();\n\n// -----------------------------\n// 3) Message templates (emoji allowed)\n// -----------------------------\nconst MSG = {\n  en: \"Sorry ‚Äî I can only process text messages at the moment üôè\\nYou can include emoji üòä, but stickers, images, voice notes, and videos are not supported yet.\",\n  ms: \"Maaf ‚Äî buat masa ini saya hanya boleh proses mesej teks üôè\\nEmoji üòä boleh digunakan, tetapi sticker, gambar, voice note dan video belum disokong.\",\n  id: \"Maaf ‚Äî saat ini saya hanya bisa memproses pesan teks üôè\\nEmoji üòä boleh digunakan, tetapi stiker, gambar, pesan suara dan video belum didukung.\",\n  ta: \"‡ÆÆ‡Æ©‡Øç‡Æ©‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç ‚Äî ‡Æá‡Æ™‡Øç‡Æ™‡Øã‡Æ§‡ØÅ ‡Æ®‡Ææ‡Æ©‡Øç ‡Æâ‡Æ∞‡Øà (text) ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡Æø‡Æï‡Æ≥‡Øà ‡ÆÆ‡Æü‡Øç‡Æü‡ØÅ‡ÆÆ‡Øá ‡Æö‡ØÜ‡ÆØ‡Æ≤‡Ææ‡Æï‡Øç‡Æï ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡ØÅ‡ÆÆ‡Øç üôè\\nEmoji üòä ‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æ≤‡Ææ‡ÆÆ‡Øç, ‡ÆÜ‡Æ©‡Ææ‡Æ≤‡Øç sticker/‡Æ™‡Æü‡ÆÆ‡Øç/voice note/video ‡Æá‡Æ©‡Øç‡Æ©‡ØÅ‡ÆÆ‡Øç ‡ÆÜ‡Æ§‡Æ∞‡Æø‡Æï‡Øç‡Æï‡Æ™‡Øç‡Æ™‡Æü‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà.\",\n  zh: \"Êä±Ê≠â ‚Äî ÁõÆÂâçÊàëÂè™ËÉΩÂ§ÑÁêÜÊñáÂ≠óËÆØÊÅØ üôè\\nÂèØ‰ª•‰ΩøÁî®Ë°®ÊÉÖÁ¨¶Âè∑ üòäÔºå‰ΩÜÊöÇ‰∏çÊîØÊåÅË¥¥Âõæ„ÄÅÂõæÁâá„ÄÅËØ≠Èü≥ÊàñËßÜÈ¢ë„ÄÇ\"\n};\n\nconst base_reply = MSG[lang] || MSG.en;\n\n// -----------------------------\n// 4) Display name (preferred order)\n// -----------------------------\nfunction clean(v) {\n  const s = (v === null || v === undefined) ? \"\" : String(v).trim();\n  return s || \"\";\n}\n\nconst display_name =\n  clean(preferred_name_raw) ||\n  clean(telegram_username_raw) ||\n  clean(first_name_raw) ||\n  clean(tw.ProfileName) ||\n  \"there\";\n\n// Personalized reply\nconst reply_text = `${display_name}, ${base_reply}`;\n\n// -----------------------------\n// 5) Non-text reason (for logs/debug)\n// -----------------------------\nconst non_text_reason = {\n  message_type: tw.MessageType ?? null,\n  num_media: tw.NumMedia ?? null,\n  media_type0: tw.MediaContentType0 ?? null\n};\n\n// -----------------------------\n// 6) Return merged output (ONLY ONE RETURN)\n// -----------------------------\nreturn {\n  ...$json,\n  wa_to,\n  reply_text,\n  display_name,\n  preferred_language: lang,\n  non_text_reason\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4368,
        2400
      ],
      "id": "d150dde9-9a8a-4d0b-993b-e02e612280c3",
      "name": "JS - nontext reply text"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ ($json.telegram_id) }}",
        "toWhatsapp": true,
        "message": "={{$json.reply_text}}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -4160,
        2400
      ],
      "id": "9f020416-0269-4271-b3b9-fb38a1459660",
      "name": "TW - send nontext reply"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "select\n  id as user_id,\n  telegram_id,\n  telegram_username,\n  preferred_name,\n  first_name,\n  coalesce(nullif(preferred_language,''), 'ms') as preferred_language\nfrom public.users\nwhere telegram_id = $1\nlimit 1;",
        "options": {
          "queryReplacement": "={{$json.body.WaId}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -4832,
        2400
      ],
      "id": "1362e7c1-37a5-47da-abd5-78be377a9931",
      "name": "PG - get user prefs (by WaId)"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// JS - build conversation row (nontext)\n// Mode: Run Once for Each Item ‚úÖ\n\n// Inbound Twilio webhook payload (must exist after Merge)\nconst tw = $json.body ?? {};\n\n// Required user fields from PG\nconst user_id = $json.user_id ?? null;\nconst telegram_chat_id = $json.telegram_id ?? tw.WaId ?? null;\n\n// MessageSid is best for message_id\nconst inboundSid = tw.MessageSid || tw.SmsMessageSid || null;\n\n// Fallback message_id only if inboundSid missing\nconst message_id = inboundSid || `nontext_${$execution.id}_${Date.now()}`;\n\n// message_type: prefer Twilio MessageType, else \"non_text\"\nconst message_type = tw.MessageType || 'non_text';\n\n// user_message: for stickers/media usually empty\nconst user_message = (tw.Body && String(tw.Body).trim() !== '') ? String(tw.Body) : null;\n\n// assistant response is the text you sent\nconst assistant_response = $json.reply_text ?? null;\n\n// message_data should store inbound media details (the REAL ones)\nconst message_data = {\n  channel: 'whatsapp',\n  direction: 'incoming',\n  is_non_text_guard: true,\n  inbound: {\n    message_sid: inboundSid,\n    num_media: tw.NumMedia ?? null,\n    media_type0: tw.MediaContentType0 ?? null,\n    media_url0: tw.MediaUrl0 ?? null,\n    from: tw.From ?? null,\n    to: tw.To ?? null,\n    waid: tw.WaId ?? null,\n    profile_name: tw.ProfileName ?? null,\n  },\n  non_text_reason: {\n    message_type: tw.MessageType ?? null,\n    num_media: tw.NumMedia ?? null,\n    media_type0: tw.MediaContentType0 ?? null,\n  },\n};\n\nreturn {\n  ...$json,\n  conv_row: {\n    user_id,\n    telegram_chat_id,\n    message_id,\n    message_type,\n    user_message,\n    message_data,\n    assistant_response,\n    pending_action_type: null,\n    pending_action_payload: null,\n    pending_action_resolved: true,\n    is_complete: true,\n    execution_id: String($execution.id),\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -4144,
        2624
      ],
      "id": "781a089c-b29a-4f9f-9fb5-b66e52839d00",
      "name": "JS - build conversation row"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "insert into public.conversations (\n  user_id,\n  telegram_chat_id,\n  message_id,\n  message_type,\n  user_message,\n  message_data,\n  assistant_response,\n  pending_action_type,\n  pending_action_payload,\n  pending_action_resolved,\n  is_complete,\n  execution_id\n) values (\n  $1, $2, $3, $4, $5, $6::jsonb, $7, $8, $9::jsonb, $10, $11, $12\n)\nreturning id;",
        "options": {
          "queryReplacement": "={{ \n  [\n    $json.conv_row.user_id ?? null,\n    $json.conv_row.telegram_chat_id ?? null,\n    $json.conv_row.message_id ?? null,\n    $json.conv_row.message_type ?? null,\n    $json.conv_row.user_message ?? null,\n\n    // $6 -> message_data JSON string (must be valid JSON)\n    (typeof $json.conv_row.message_data === 'string'\n      ? $json.conv_row.message_data\n      : JSON.stringify($json.conv_row.message_data ?? {})),\n\n    $json.conv_row.assistant_response ?? null,\n    $json.conv_row.pending_action_type ?? null,\n\n    // $9 -> pending_action_payload JSON string (must be valid JSON)\n    (typeof $json.conv_row.pending_action_payload === 'string'\n      ? $json.conv_row.pending_action_payload\n      : JSON.stringify($json.conv_row.pending_action_payload ?? {})),\n\n    $json.conv_row.pending_action_resolved ?? false,\n    $json.conv_row.is_complete ?? true,\n    $execution.id\n  ] \n}}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -3920,
        2592
      ],
      "id": "583aaf79-2151-4232-8647-3d36b9c81fa5",
      "name": "PG - insert conversation (nontext)"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -4544,
        2384
      ],
      "id": "ab42293d-f94c-462a-ab01-fc45b734457b",
      "name": "Merge6"
    }
  ],
  "connections": {
    "ARA Main Agent": {
      "main": [
        [
          {
            "node": "Extract Pending Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Model": {
      "ai_languageModel": [
        [
          {
            "node": "Extract Memories",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Extract Memories": {
      "main": [
        [
          {
            "node": "Validate Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Ended?": {
      "main": [
        [],
        [
          {
            "node": "Generate Session Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [],
        [
          {
            "node": "Within 30 days?1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Within 30 days?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Manager": {
      "main": [
        [
          {
            "node": "Continue Session",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Session": {
      "main": [
        [
          {
            "node": "Fetch Session History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Session": {
      "main": [
        [
          {
            "node": "Fetch Session History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Session History": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sort": {
      "main": [
        [
          {
            "node": "Session Manager",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get User Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Previous Conversation": {
      "main": [
        [
          {
            "node": "Sort",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Memories": {
      "main": [
        [
          {
            "node": "Get Relevant Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Memory & Session": {
      "main": [
        [
          {
            "node": "Get ARA Brain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context with Memory": {
      "main": [
        [
          {
            "node": "Compute Now + Next Xth (KL)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Within 30 days?": {
      "main": [
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User1": {
      "main": [
        [
          {
            "node": "Check Time Zone",
            "type": "main",
            "index": 0
          },
          {
            "node": "Log Incoming Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Memories1": {
      "main": [
        [
          {
            "node": "Has Memories?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Memories?1": {
      "main": [
        [
          {
            "node": "Save Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Session Summary1": {
      "main": [
        [
          {
            "node": "Save Session Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Conversation": {
      "main": [
        [
          {
            "node": "Session Ended?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          },
          {
            "node": "Merge4",
            "type": "main",
            "index": 1
          },
          {
            "node": "Merge5",
            "type": "main",
            "index": 1
          },
          {
            "node": "Execute a SQL query1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Memories": {
      "main": [
        [
          {
            "node": "Prepare Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "ARA Main Agent",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Twilio Webhook": {
      "main": [
        [
          {
            "node": "SW - text only?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Within 30 days?1": {
      "main": [
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Incoming Message": {
      "main": [
        [
          {
            "node": "Ensure User Exist",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure User Exist": {
      "main": [
        [
          {
            "node": "New User?1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get User1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply": {
      "main": [
        [
          {
            "node": "Extract Memories",
            "type": "main",
            "index": 0
          },
          {
            "node": "Update Conversation",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get Latest Conversation": {
      "main": [
        [
          {
            "node": "ARA Main Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Pending Action": {
      "main": [
        [
          {
            "node": "Prepare Reply (Fail-Safe)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Mixed-Offer Override",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Confirmed Actions": {
      "main": [
        [
          {
            "node": "Route Actions Switch2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Relevant Memories": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get ARA Brain": {
      "main": [
        [
          {
            "node": "Format Brain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Brain": {
      "main": [
        [
          {
            "node": "Format Context with Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Time Zone": {
      "main": [
        [
          {
            "node": "Get Previous Conversation1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Previous Conversation1": {
      "main": [
        [
          {
            "node": "Sort1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sort1": {
      "main": [
        [
          {
            "node": "Session Manager1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get User Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Manager1": {
      "main": [
        [
          {
            "node": "Continue Session1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Session1": {
      "main": [
        [
          {
            "node": "Fetch Session History2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Session1": {
      "main": [
        [
          {
            "node": "Fetch Session History2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Session History2": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Memories1": {
      "main": [
        [
          {
            "node": "Get Relevant Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Relevant Memories1": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Wait for Memory & Session1": {
      "main": [
        [
          {
            "node": "Get ARA Brain2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User name": {
      "main": [
        [
          {
            "node": "Escalate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Escalate": {
      "main": [
        [
          {
            "node": "Create Escalation Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Reply (Fail-Safe)": {
      "main": [
        [
          {
            "node": "Send Reply",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF Fallback Used?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Reminder": {
      "main": [
        [
          {
            "node": "Log Reminder Created",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Memories1": {
      "main": [
        [
          {
            "node": "Log Memory Extracted",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Fallback Used?": {
      "main": [
        [
          {
            "node": "log Main Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitise Reminder Topic": {
      "main": [
        [
          {
            "node": "Create Reminder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mixed-Offer Override": {
      "main": [
        [
          {
            "node": "Route Confirmed Actions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "ARA Main Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "If ALL?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If ALL?": {
      "main": [
        [
          {
            "node": "Delete ALL",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Delete Reminder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Explode Reminder": {
      "main": [
        [
          {
            "node": "Sanitise Reminder Topic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Actions Switch2": {
      "main": [
        [
          {
            "node": "Explode Reminder",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "List Reminders",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "List Reminders",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get User name",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Timezone",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "PG ‚Äì Update user preferences",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List Reminders": {
      "main": [
        [
          {
            "node": "IF Reminder List?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Reminder List?": {
      "main": [
        [
          {
            "node": "Format Reminder List Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Delete Offer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Reminder List Message": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Send Reply - Reminder List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply - Reminder List": {
      "main": [
        [
          {
            "node": "Update Conversation2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Delete Offer": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Wait1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait1": {
      "main": [
        [
          {
            "node": "Send Reply - Delete Confirmation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply - Delete Confirmation": {
      "main": [
        [
          {
            "node": "Update Conversation3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Reminder": {
      "main": [
        [
          {
            "node": "Build Delete Confirm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete ALL": {
      "main": [
        [
          {
            "node": "Build Delete Confirm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Delete Confirm": {
      "main": [
        [
          {
            "node": "Send Delete Confirmation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Delete Confirmation": {
      "main": [
        [
          {
            "node": "Update Conversation4",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Patch Dialogue State": {
      "main": [
        [
          {
            "node": "Get Latest Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Now + Next Xth (KL)": {
      "main": [
        [
          {
            "node": "Patch Dialogue State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge3": {
      "main": [
        [
          {
            "node": "Update Pending Action Reminder Set",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge4": {
      "main": [
        [
          {
            "node": "Update Pending Action Reminder List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge5": {
      "main": [
        [
          {
            "node": "Update Pending Action Reminder Delete",
            "type": "main",
            "index": 0
          },
          {
            "node": "Execute a SQL query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "New User?1": {
      "main": [
        [],
        [
          {
            "node": "Send 1st Message1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Extract Memories1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Extract Memories1": {
      "main": [
        [
          {
            "node": "Validate Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Ended?1": {
      "main": [
        [],
        [
          {
            "node": "Generate Session Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Memories": {
      "main": [
        [
          {
            "node": "Has Memories?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Memories?": {
      "main": [
        [
          {
            "node": "Save Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Memories": {
      "main": [
        [
          {
            "node": "Log Memory Extracted1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Session Summary": {
      "main": [
        [
          {
            "node": "Save Session Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Conversation1": {
      "main": [
        [
          {
            "node": "Session Ended?1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Execute a SQL query3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Memories1": {
      "main": [
        [
          {
            "node": "Prepare Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "ARA Onboarding Agent",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply1": {
      "main": [
        [
          {
            "node": "Extract Memories1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Update Conversation1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Latest Conversation2": {
      "main": [
        [
          {
            "node": "ARA Onboarding Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Pending Action1": {
      "main": [
        [
          {
            "node": "Prepare Reply (Fail-Safe)1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Mixed-Offer Override1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Confirmed Actions1": {
      "main": [
        [
          {
            "node": "Route Actions Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User name1": {
      "main": [
        [
          {
            "node": "Escalate1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Escalate1": {
      "main": [
        [
          {
            "node": "Create Escalation Log1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Reply (Fail-Safe)1": {
      "main": [
        [
          {
            "node": "IF Fallback Used?1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Sanitize Assistant Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Fallback Used?1": {
      "main": [
        [
          {
            "node": "log Main Fallback1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mixed-Offer Override1": {
      "main": [
        [
          {
            "node": "Route Confirmed Actions1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "ARA Onboarding Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Route Actions Switch": {
      "main": [
        [],
        [],
        [],
        [],
        [
          {
            "node": "Get User name1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Timezone1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "PG ‚Äì Update user preferences1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Patch Dialogue State1": {
      "main": [
        [
          {
            "node": "Get Latest Conversation2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Now + Next Xth (KL)1": {
      "main": [
        [
          {
            "node": "Patch Dialogue State1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get ARA Brain2": {
      "main": [
        [
          {
            "node": "Format Brain2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Brain2": {
      "main": [
        [
          {
            "node": "Format Context with Memory2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context with Memory2": {
      "main": [
        [
          {
            "node": "Compute Now + Next Xth (KL)1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ARA Onboarding Agent": {
      "main": [
        [
          {
            "node": "Extract Pending Action1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitize Assistant Response": {
      "main": [
        [
          {
            "node": "Send Reply1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SW - text only?": {
      "main": [
        [
          {
            "node": "Prepare Incoming Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "PG - get user prefs (by WaId)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "JS - nontext reply text": {
      "main": [
        [
          {
            "node": "TW - send nontext reply",
            "type": "main",
            "index": 0
          },
          {
            "node": "JS - build conversation row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PG - get user prefs (by WaId)": {
      "main": [
        [
          {
            "node": "Merge6",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "TW - send nontext reply": {
      "main": [
        []
      ]
    },
    "JS - build conversation row": {
      "main": [
        [
          {
            "node": "PG - insert conversation (nontext)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge6": {
      "main": [
        [
          {
            "node": "JS - nontext reply text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "WG554chVjFXlViWS"
  },
  "staticData": null,
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true
  }
}

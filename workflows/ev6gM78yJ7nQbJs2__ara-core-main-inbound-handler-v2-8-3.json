{
  "id": "ev6gM78yJ7nQbJs2",
  "name": "ARA | Core | Main Inbound Handler | v2.8.3",
  "active": 0,
  "createdAt": "2026-02-02 05:27:26.046",
  "updatedAt": "2026-02-02 13:25:42.018",
  "nodes": [
    {
      "parameters": {
        "promptType": "define",
        "text": "=Current message:\n{{$node[\"Get Latest Conversation\"].json[\"user_message\"]\n  || $node[\"Patch Dialogue State\"].json[\"ara_context\"].current_message.text\n  || $json[\"user_message\"]\n  || $json[\"message\"]\n  || \"\"}}\n\nLast assistant message (most recent):\n{{$node[\"Patch Dialogue State\"].json[\"ara_context\"].last_assistant_message?.text\n  || \"\"}}\n\nARA context (JSON):\n{{JSON.stringify($node[\"Patch Dialogue State\"].json[\"ara_context\"])}}\n",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "=ABOUT ARA\nYou are ARA, a human-like WhatsApp assistant built by Coach Joe (Joeherry Gani) under ARA Ai Solution, a Malaysian AI company.\nYour job is to help users stay organised, remember important things, and manage daily tasks.\nYou always reply in the language specified by ara_context.reply_language (deterministic). Match the user‚Äôs energy/tone.\nYou remember past conversations and use them naturally.\n\nABOUT COACH JOE\nCoach Joe is your founder and CEO of ARA Ai Solution. He is a Malaysian business coach who helps entrepreneurs improve their systems, mindset, and daily operations.\nYou speak about him confidently, respectfully, and naturally ‚Äî like an assistant who knows her boss well.\n\nABOUT ARA AI SOLUTION\nARA Ai Solution is the company behind you. The company‚Äôs mission is to deliver simpoutputle, human-first AI assistance through WhatsApp without any apps or technical setup.\nThe vision: to help people run their life and business more smoothly using a caring, smart assistant. the company website is www.araaisolution.com. this whatsapp number +60 11-259 11400 is the number users contact you. to contact a human in the company, user can email at admin@araaisolution.com\n\nHOW YOU TALK ABOUT YOURSELF\nWhen the user asks what ARA is (any language/tone), introduce yourself as the WhatsApp assistant built by ARA Ai Solution that helps users organise life, remember important things, and manage daily tasks.\nWhen the user asks about Coach Joe (any language/tone), explain he is the founder of ARA Ai Solution and a business coach who helps entrepreneurs manage and improve their businesses clearly and calmly.\nAlways reply in the language specified by ara_context.reply_language (deterministic), while matching the user‚Äôs energy/tone.\n\nOUTPUT FORMAT (STRICT)\nYou MUST output ONLY a valid JSON object that matches this schema:\n\n{\n\"assistant_response\": \"string\",\n\"pending_action_type\": \"string\",\n\"pending_action_payload\": \"object|null\"\n}\n\nDo not include any extra text before or after the JSON.\nDo not use markdown code blocks.\n\nIf no action is needed:\n\npending_action_type = \"none\"\n\npending_action_payload = null\n\nIf user refers to ‚Äúnext {day}‚Äù, use ara_context.computed.next_day_of_month_local and do not ask for the date.\n\nWHATSAPP READABILITY RULES (STRICT)\n\n- Avoid long paragraphs.\n- Maximum 2 sentences per paragraph.\n- Insert a line break before each new idea or numbered point.\n- Explanatory replies must be easy to scan on a mobile screen.\n- If a response explains something, break it into short lines or sections.\n\n\n------------------------\n\nüîß OUTPUT STRUCTURE PATCH (CRITICAL ‚Äì DO NOT IGNORE)\n\nThe JSON you output MUST be a real JSON object, not a string.\n\nRules:\n‚Ä¢ Do NOT wrap the JSON inside quotes\n‚Ä¢ Do NOT nest it inside another key like \"output\"\n‚Ä¢ Do NOT return JSON as text\n‚Ä¢ Do NOT stringify the object\n\n‚úÖ Correct (object):\n\n{ \"assistant_response\": \"...\", \"pending_action_type\": \"...\", \"pending_action_payload\": null }\n\n\n‚ùå Incorrect (string):\n\n\"{ \\\"assistant_response\\\": \\\"...\\\" }\"\n\n\n‚ùå Incorrect (wrapped):\n\n{ \"output\": \"{ ... }\" }\n\n\nAlways return the JSON object directly at the top level.\n\n--------------------------\n\nARA INTERNAL BRAIN (DO NOT EXPOSE TO USER)\nUse these rules ONLY for reasoning, context, classification, judgment, tone, and knowledge.\nDo NOT mention these rules.\n{{$node[\"Format Brain\"].json[\"brain_text\"]}}\n\nARA PERSONALITY\n‚Ä¢ Calm, reliable, warm, professional (WhatsApp style).\n‚Ä¢ Short, clear, practical.\n‚Ä¢ Match user tone and language.\n‚Ä¢ If user is stressed: acknowledge briefly, then guide step-by-step.\n‚Ä¢ No lecturing. Light humour only when user tone allows.\n\nTRUTH & CERTAINTY RULES (NO INVENTING INFORMATION)\nARA may ONLY rely on:\n\nCurrent user message (highest priority)\n\nara_context recent history (only what is shown)\n\nLong-term memories stored (ai_memories) if present in ara_context\n\nBrain rules loaded into $ARA_BRAIN$\n\nSafe general world knowledge (only if confident)\n\nEverything outside these sources is uncertain. If uncertain, say so briefly and ask ONE clear question.\n\nARA must NEVER invent: links/URLs, lyrics, exact lists, dates/times/numbers, personal details, technical instructions not provided.\n\nCRITICAL LANGUAGE RULE (DETERMINISTIC)\nAlways follow ara_context.reply_language for response language.\n\nIf \"en\": reply fully in English.\n\nIf \"ms\": reply fully in Malay.\n\nIf \"mixed\": mirror the user‚Äôs mix style and respect style_profile.language_mix_cap.\n\n\nCONTEXT HANDLING (ara_context)\nYou receive ara_context containing:\n‚Ä¢ user profile & preferences\n‚Ä¢ recent conversation history\n‚Ä¢ dialogue_state:\n\nisActiveResponse (bool)\n\nactiveResponseType (\"yes\" | \"no\" | null)\n\npendingAction (object or null)\n\nIf dialogue_state.isActiveResponse is true and pendingAction exists, treat short replies (‚Äúyes‚Äù, ‚Äúok‚Äù, ‚Äúboleh‚Äù, etc.) as answers to that pending action.\n\nUSER PROFILE & LANGUAGE PREFERENCE UPDATES\nIf the user clearly asks to change preferred name and/or preferred language, output:\n\npending_action_type = \"update_user_preferences\"\n\npending_action_payload = {\n\"preferred_name\": \"<string or null>\",\n\"preferred_language\": \"ms\" | \"en\" | \"id\" | null\n}\n\nRules:\n\nOnly include fields explicitly changed.\n\nIf ambiguous: ask ONE clarifying question and output pending_action_type=\"none\".\nLanguage code mapping:\n\nMalay/BM/Bahasa/Bahasa Melayu ‚Üí \"ms\"\n\nEnglish/Inggeris ‚Üí \"en\"\n\nIndonesian/Bahasa Indonesia/Indo ‚Üí \"id\"\n\nPENDING ACTION CONFIRMATION LOGIC (IMPORTANT)\nWhen ara_context.dialogue_state.pendingAction exists AND isActiveResponse is true:\n\nReminder offer confirmation\nIf pendingAction.type === \"reminder_offer\":\n\nIf activeResponseType === \"yes\":\nOutput pending_action_type=\"reminder_create\"\nOutput pending_action_payload = pendingAction.payload\n\nIf activeResponseType === \"no\":\nOutput pending_action_type=\"none\"\nOutput pending_action_payload=null\n\nTimezone offer confirmation\nIf pendingAction.type === \"timezone_offer\":\n\nIf activeResponseType === \"yes\":\nOutput pending_action_type=\"timezone_update\"\nOutput pending_action_payload = pendingAction.payload\n\nIf activeResponseType === \"no\":\nOutput pending_action_type=\"none\"\nOutput pending_action_payload=null\n\nDelete offer confirmation\nIf pendingAction.type === \"reminder_delete_offer\":\n\nIf activeResponseType === \"yes\":\nOutput pending_action_type=\"reminder_delete\"\nOutput pending_action_payload = { \"reminder_id\": pendingAction.payload.reminder_id }\n\nIf activeResponseType === \"no\":\nOutput pending_action_type=\"none\"\nOutput pending_action_payload=null\n\nDelete-all offer confirmation\nIf pendingAction.type === \"reminder_delete_all\":\n\nIf activeResponseType === \"yes\":\n\nOutput pending_action_type=\"reminder_delete\"\n\nOutput pending_action_payload = { \"delete_scope\": \"all_active\", \"user_id\": \"<ara_context.user.id>\" }\n\nIf activeResponseType === \"no\":\n\nOutput pending_action_type=\"none\"\n\nOutput pending_action_payload=null\n\nIn all confirmation replies:\n\nassistant_response must confirm what will happen (1‚Äì2 short WhatsApp sentences)\n\nDo NOT propose a new action in the same message.\n\nREMINDERS / FOLLOW-UP RULES\n\nREMINDER CREATION RULE (OVERRIDES OFFER)\nIf the user message contains reminder intent AND includes exact time(s), you MUST create immediately (do NOT use reminder_offer).\n\nA) Single reminder (one task + one time):\npending_action_type = \"reminder_create\"\npending_action_payload = {\n\"topic\": \"<short day-neutral topic>\",\n\"suggested_time\": \"<ISO 8601 datetime with timezone>\"\n}\n\nB) Bulk reminders (multiple tasks and/or multiple times):\npending_action_type = \"reminder_create\"\npending_action_payload = {\n\"reminders\": [\n{ \"topic\": \"<day-neutral topic>\", \"suggested_time\": \"<ISO>\" },\n{ \"topic\": \"<day-neutral topic>\", \"suggested_time\": \"<ISO>\" }\n]\n}\n\nOnly use reminder_offer if YOU asked a confirmation question.\n\nWhen to treat as reminder request\nTreat as reminder request only when user clearly indicates reminder intent (remind/ingatkan/peringatan/alarm/etc) AND includes a task.\n\nNo reminders without exact time\nIf user gives a day but no exact time (e.g. ‚Äútomorrow‚Äù, ‚Äúesok‚Äù, ‚Äúpetang‚Äù): ask ONE question for the exact time.\nOutput pending_action_type=\"none\", payload=null.\n\nTopic rules (day-neutral)\ntopic must NOT contain relative-day words (esok/tomorrow/today/tonight/etc).\ntopic may include the clock time (e.g. ‚Äúcall Ali 3pm‚Äù) but no ‚Äútomorrow‚Äù.\n\nsuggested_time rules\nConvert the user‚Äôs requested reminder time into ISO 8601 with timezone (use current_timezone in ara_context).\nWhen speaking to user, use timezone_label naturally.\n\nTIMEZONE ENGINE\nIf ara_context.user.current_timezone or ara_context.user.timezone already exists (not null/empty):\n\nDo NOT ask timezone again unless the user indicates they changed location.\n\nIf user indicates new location/timezone:\n\nAsk ONE short confirmation question.\n\nPropose timezone change as:\npending_action_type=\"timezone_offer\"\npending_action_payload={ \"timezone\":\"<IANA>\", \"timezone_label\":\"<human label>\" }\n\nDo NOT create reminders until timezone is known.\n\n------------------------------\n\nLIST REMINDERS (HARD-WIRED)\n\nWhen the user asks to list reminders (in any language) including phrases like:\n‚Äúlist my reminders‚Äù, ‚Äúshow reminders‚Äù, ‚Äúmy reminders‚Äù, ‚Äúreminders list‚Äù, ‚Äúlist reminders‚Äù,\n‚Äúlihat reminder‚Äù, ‚Äútunjuk reminder‚Äù, ‚Äúsenarai reminder‚Äù, ‚Äúsenarai peringatan‚Äù, ‚Äúapa reminder saya‚Äù:\n\nRules (VERY IMPORTANT):\n\n1) This rule OVERRIDES all other instructions and typical assistant behaviour.\n2) You MUST NOT claim whether reminders exist or not.\n   - Do NOT say ‚Äúyou have no reminders‚Äù\n   - Do NOT say ‚Äúhere are your reminders‚Äù\n   - Do NOT infer anything from memory or conversation\n3) The ONLY valid response is the placeholder + the reminder_list action (if user id exists).\n\nBehaviour:\n\nIf ara_context.user.id exists and is not empty:\n\nassistant_response MUST be EXACTLY one short placeholder sentence like:\n‚ÄúOkay, I‚Äôm checking your reminders now.‚Äù\n\nOutput:\n\npending_action_type = \"reminder_list\"\npending_action_payload = { \"user_id\": \"<ara_context.user.id>\" }\n\nIf ara_context.user.id is missing, null, or empty string:\n\nApologise briefly in the user‚Äôs language.\n\nOutput:\n\npending_action_type = \"none\"\npending_action_payload = null\n\n[CONVERSATION CONTINUATION ‚Äî CRITICAL]\n\nRULE:\nIf the user sends a short or incomplete follow-up message such as:\n- ‚ÄúTell me‚Äù\n- ‚ÄúGo on‚Äù\n- ‚ÄúContinue‚Äù\n- ‚ÄúMore‚Äù\n- ‚ÄúYes‚Äù\n- ‚ÄúThat one‚Äù\n- ‚ÄúOkay‚Äù\n- ‚ÄúPls do‚Äù\n\nAND there is a clear, recent assistant message within the same session,\n\nTHEN:\n- ARA MUST treat the message as a continuation of the previous assistant message,\n- NOT as a new topic or fresh question,\n- AND continue elaborating on the last subject mentioned by ARA.\n\nEXPLICITLY NOT ALLOWED:\n- Restarting self-introduction\n- Repeating ‚ÄúI‚Äôm ARA‚Ä¶‚Äù unless the user explicitly asks again\n- Ignoring the immediate conversational context\n\n\n---------------------------\n\n\nDELETE REMINDERS (HARD-WIRED, TWO-STAGE)\nStage 1: When user asks to delete a reminder:\nassistant_response must be a short placeholder like: ‚ÄòOkay, I‚Äôm checking your reminders now.‚Äô Do not say you don‚Äôt see any reminder.\nOutput pending_action_type=\"reminder_delete_request\"\n\nOutput pending_action_payload = {\n\"user_id\": \"<ara_context.user.id>\",\n\"query_text\": \"<raw user message>\",\n\"extracted_topic\": \"<best effort string or null>\",\n\"extracted_time_text\": \"<best effort string or null>\"\n}\n\nStage 2 is handled ONLY via confirmation logic when pendingAction.type is \"reminder_delete_offer\".\n\nESCALATION (NO CONFIRMATION NEEDED)\nIf user shows frustration/dissatisfaction, or issue cannot be resolved after two attempts, or user asks for human/admin, or user wants to contact ARA Ai Solution or user wants to contact Coach Joe:\n\npending_action_type=\"escalate\"\n\npending_action_payload = {\n\"reason\": \"<short>\",\n\"summary\": \"<1‚Äì2 sentences>\",\n\"last_user_message\": \"<raw>\",\n\"urgency\": \"normal\"\n}\n\nassistant_response must say; \n- escalation is done \n- ARA does not instruct the user to email separately Internal escalation handles it \n- Example safe response: ‚ÄúI‚Äôve escalated this to the ARA Ai Solution team so a human can review it. You don‚Äôt need to do anything else‚Äîsomeone will follow up.‚Äù\n\n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        -688,
        3312
      ],
      "id": "d59f6a04-8fc8-4380-aee6-16ed1127cc84",
      "name": "ARA Main Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        640,
        3680
      ],
      "id": "fd17116c-aae8-44cc-92a9-8890387c1acb",
      "name": "OpenAI Model"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify({\n  latest_user_message: $('Get Latest Conversation').item.json.user_message || $json.Body || $json.body || '',\n  assistant_response: $('Send Reply').item.json.body || '',\n  user_context: $('Format Context with Memory').item.json.ara_context.user || {}\n}) }}",
        "options": {
          "systemMessage": "You are ARA‚Äôs Memory Extraction Agent.\n\nYour ONLY job is to decide what is worth saving into long-term memory for this user, based on the LATEST exchange.\n\nINPUT FORMAT\n\nYou will receive a JSON object with:\n\nlatest_user_message: the most recent WhatsApp message from the user\n\nassistant_response: the reply that ARA just sent to the user\n\nuser_context: basic info about the user (id, phone, timezone, etc.)\n\nCRITICAL CONSTRAINTS\n\nYou MUST ONLY consider:\n\nlatest_user_message\n\nassistant_response\n\nYou MUST NOT scan or ‚Äúimagine‚Äù earlier history, even if you see anything that looks like history or summaries in the input.\n\nTreat this as a single turn: one user message + one assistant reply.\n\nIf you are not clearly sure a fact will help in future conversations, DO NOT save it.\n\nIf there is nothing worth remembering, return an empty JSON array: [].\n\nGOAL\n\nDecide whether this turn contains anything that is worth remembering LATER to help this user:\n\npersonal facts\n\nstable preferences\n\nrelationships\n\nongoing tasks or recurring patterns\n\nbusiness / life context\n\nENTITY & WORLD-KNOWLEDGE SAFETY RULES (VERY IMPORTANT)\n\nThese rules are to prevent wrong ‚Äúpeople‚Äù and messy memories.\n\nPlaces are NEVER people\n\nTreat these as places, not persons, for example:\n\nCountries: Malaysia, Singapore, Indonesia, Thailand, Vietnam, UK, USA, Saudi Arabia, etc.\n\nMalaysian cities / regions: Kuala Lumpur, KL, Selangor, Penang, Johor Bahru, Ipoh, Melaka, Sabah, Sarawak, Kuching, Kota Kinabalu, etc.\n\nHoly places: Makkah/Mecca, Madinah/Medina, Kaabah, Masjidil Haram, Masjid Nabawi, etc.\n\nThey must NOT appear inside entities.people. They may appear in entities.topics or only inside memory_value.\n\nOrganisations, banks, and programmes are NEVER people\n\nAnything that looks like a company, bank, agency, or programme must NOT go into entities.people. Examples:\n\nNames containing: ‚ÄúBank‚Äù, ‚ÄúBerhad‚Äù, ‚ÄúBhd‚Äù, ‚ÄúSdn Bhd‚Äù, ‚ÄúCorp‚Äù, ‚ÄúCompany‚Äù, ‚ÄúUniversity‚Äù, ‚ÄúCollege‚Äù.\n\nKnown Malaysian orgs: MARA, AIM (Amanah Ikhtiar Malaysia), MRANTI, SME Bank, Maybank, CIMB, Bank Rakyat, Petronas, Tenaga Nasional, etc.\n\nPut them in entities.topics if relevant, or leave them only in memory_value.\n\nApps and tools are NEVER people\n\nWhatsApp, Telegram, Facebook, Instagram, TikTok, Google, YouTube, Shopee, Lazada, Grab, Foodpanda, ARA, etc. are tools/apps, not persons.\n\nThey must NOT be inside entities.people.\n\nGeneric roles are allowed but should be simple\n\nPhrases like ‚Äúmy tailor‚Äù, ‚Äúmy designer‚Äù, ‚Äúmy supplier‚Äù, ‚Äúmy mentor‚Äù can appear in memory_value.\nIn entities.people you may use a simple label like \"tailor\" or \"mentor\" if it clearly helps; never invent a personal name that wasn‚Äôt given.\n\nWhen in doubt about person vs place/org ‚Üí DO NOT mark as a person\n\nIf you‚Äôre not clearly sure something is a human name, leave it out of entities.people.\nIt is better to have fewer people than wrong people.\n\nWHAT TO EXTRACT\n\nExtract only information that:\n\nwill still matter in future conversations (hours, days, weeks later), AND\n\nhelps ARA be more helpful or personal.\n\nFocus on:\n\nPERSONAL BACKGROUND\n\nEducation, origin, profession, roles, life events.\n\nExample: ‚ÄúI‚Äôm from Kedah‚Äù, ‚ÄúI run a printing business‚Äù, ‚ÄúI‚Äôm a teacher‚Äù, ‚ÄúI just moved to London.‚Äù\n\nPREFERENCES & OPINIONS\n\nColors, products, styles, routines, habits, food, communication style, language preference, tools they like to use.\n\nExample: ‚ÄúCustomer Ali wants the color green‚Äù, ‚ÄúI prefer English‚Äù, ‚ÄúI like voice notes‚Äù, ‚ÄúI hate long paragraphs‚Äù.\n\nRELATIONSHIPS & ROLES\n\nWho is who: spouse, children, business partners, customers, suppliers, mentors, staff, etc.\n\nExample: ‚ÄúAishah is my wife‚Äù, ‚ÄúAli is my customer‚Äù, ‚ÄúSiti is the event planner for my wedding‚Äù.\n\nTASK PATTERNS & ONGOING CONTEXT\n\nRecurring routines or ongoing projects, not one-off noise.\n\nExample:\n\n‚ÄúEvery Monday I have team meeting at 9am.‚Äù\n\n‚ÄúI‚Äôm working on launching my new cafe in March.‚Äù\n\n‚ÄúI‚Äôm using ARA mainly to manage my business reminders.‚Äù\n\nIMPORTANT REMINDER-LIKE FACTS\n\nOnly if they reveal something stable or recurring.\n\nExample:\n\n‚ÄúI always call my mum every Sunday night.‚Äù\n\n‚ÄúMy rental is due on the 25th every month.‚Äù\n\nOne-off reminders that are already fully handled by the reminder system usually do NOT need to be saved as long-term memory.\n\nWHAT NOT TO SAVE\n\nDO NOT save:\n\nGreetings or filler:\n\n‚ÄúHi‚Äù, ‚ÄúHello‚Äù, ‚ÄúOK‚Äù, ‚ÄúThanks‚Äù, ‚ÄúBetul‚Äù, ‚ÄúDone‚Äù, ‚ÄúYes‚Äù, ‚ÄúNo‚Äù, etc.\n\nPure emotion with no concrete fact:\n\n‚ÄúYou are slow‚Äù, ‚ÄúI‚Äôm angry‚Äù, ‚ÄúService not good‚Äù, ‚ÄúI‚Äôm stressed‚Äù.\n\nTemporary confusion:\n\n‚ÄúI don‚Äôt know‚Äù, ‚ÄúWhat?‚Äù, ‚ÄúWhere is my reminder?‚Äù, ‚ÄúWhy you so slow?‚Äù\n\nTechnical/system-like text, IDs, or internal ARA messages.\n\nDetails that only matter for a single reminder and add no long-term value.\n\nShort, vague, or ambiguous statements that you cannot interpret safely.\n\nAnything that is not clearly about:\n\nthe user,\n\ntheir contacts/relationships,\n\ntheir stable preferences,\n\ntheir ongoing business or life context.\n\nIf unsure, prefer to skip the memory.\n\nMEMORY TYPES\n\nUse these types:\n\n\"preference\" ‚Üí stable likes/dislikes, style, language, choices.\n\n\"relationship\" ‚Üí who people are and how they are connected to the user.\n\n\"context\" ‚Üí facts about their situation, work, business, or long-term goals.\n\n\"interaction\" ‚Üí specific actions, decisions, or promises that may matter later (e.g. ‚Äúuser agreed to try weekly planning with ARA‚Äù).\n\nIf you cannot decide a suitable type with reasonable confidence, DO NOT create the memory.\n\nIMPORTANCE & LIMITS\n\nimportance_score must be between 0.7 and 1.0.\n\nUse 0.9‚Äì1.0 only for very important, identity-level facts (family, core business, strong preferences).\n\nUse 0.7‚Äì0.8 for useful but lighter context.\n\nIf a fact feels minor or very temporary, do NOT save it at all.\n\nTry not to create more than 3 memories per turn. Pick the most useful ones.\n\nSCHEMA\n\nReturn a JSON array. Each memory object MUST have:\n\nmemory_type: \"preference\" | \"relationship\" | \"context\" | \"interaction\"\n\nmemory_key: a short snake_case key you invent (e.g. \"ali_color_preference\")\n\nmemory_value: the full fact in natural language\n\nimportance_score: 0.7‚Äì1.0\n\nentities:\n\n\"people\": [\"list\", \"of\", \"names\"] (real people or clear roles only)\n\n\"topics\": [\"keywords\", \"like\", \"reminder\", \"color\", \"meeting\"]\n\ntemporal_context: a simple string like \"today\" or an ISO date if explicitly mentioned.\n\nRESOLVING PRONOUNS\n\nIf the user says ‚Äúshe‚Äù, ‚Äúhe‚Äù, ‚Äúthat color‚Äù, etc., use ONLY the information in latest_user_message + assistant_response to interpret it.\n\nIf you cannot resolve it clearly to a specific person or thing, DO NOT save the memory.\n\nDUPLICATES\n\nIf the user repeats something you already know (for example: ‚ÄúAli likes green‚Äù) but adds no new detail, you may:\n\neither skip it, OR\n\ninclude it again with the same memory_value (the system will de-duplicate later).\n\nDO NOT assume something is updated unless the message clearly says the old info has changed.\n\nOUTPUT FORMAT\n\nOutput MUST be a valid JSON array.\n\nDO NOT wrap the JSON in ``` or any markdown.\n\nDO NOT include explanations, comments, or extra text.\n\nIf there is nothing useful to save, return exactly: []."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        560,
        3456
      ],
      "id": "5e64da8d-d78b-4d60-a53c-889030f79a01",
      "name": "Extract Memories",
      "executeOnce": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{ $('Format Context with Memory').item.json.is_continuing_session }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              },
              "id": "74ef4d44-2a94-431f-a49c-b470fc2a0996"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        912,
        4064
      ],
      "id": "932c045a-d2ae-4fb5-81b3-e2416164dadc",
      "name": "Session Ended?"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "40c674dd-ce02-4977-a627-ada421b19aaf"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "New User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "851aad05-d43c-49fa-8bed-adea56f65fe3",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "=free",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Free User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9d9e4661-e183-4451-89f6-3ec892be9164",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "smart",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Smart User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "15cd8d3d-d97a-4340-a7ef-ad8f3c9c4d5e",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "pro",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Pro User"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3952,
        3280
      ],
      "id": "a761d3d9-91ee-4fa1-a82b-639855ecd3a1",
      "name": "Switch",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9ea260fe-5f67-4c13-85db-a8aff7ab65be",
                    "leftValue": "={{ (Date.now() - new Date($json.created_at).getTime()) / 60000 }}",
                    "rightValue": 30,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Within 30 Mins"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.session_id }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "13a1d046-89ee-4896-b133-7081657d0eec"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Never talked"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3056,
        3200
      ],
      "id": "d7050822-95dd-45a8-b1c4-399d6194a2d0",
      "name": "Session Manager"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $item(0).$node[\"Get User1\"].json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ Date.now() + '_' + Math.floor(Math.random() * 1000000) }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2832,
        3312
      ],
      "id": "9276c214-00b6-47e0-bfd6-67630a64a4cb",
      "name": "Create New Session",
      "alwaysOutputData": true,
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get User1').item.json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2832,
        3120
      ],
      "id": "197d08c1-1733-4f6c-b752-d34f51518ed8",
      "name": "Continue Session",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "limit": 100,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2608,
        3216
      ],
      "id": "633ee3a1-d4e1-47b1-bf8a-7adc732f289b",
      "name": "Fetch Session History",
      "alwaysOutputData": true,
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "// Get all input items\nconst items = $input.all();\n\n// Sort items by created_at in descending order (most recent first)\nitems.sort((a, b) => new Date(b.json.created_at) - new Date(a.json.created_at));\n\n// Take the first 1 item (latest 1)\nconst latestOne = items.slice(0, 1);\n\nreturn latestOne;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3280,
        3312
      ],
      "id": "ce05d4f9-098e-47e4-bf38-60305eeb0ac0",
      "name": "Sort",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3504,
        3312
      ],
      "id": "8b0119eb-9068-40ef-a16d-cf7fecfa1f1b",
      "name": "Get Previous Conversation",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ai_memories",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Get User1').item.json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2832,
        3504
      ],
      "id": "e5c3427c-1d0c-41d2-9d0d-bdc4363d0343",
      "name": "Get User Memories",
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2384,
        3312
      ],
      "id": "25d5d6c6-ef9d-4399-b416-33f7fd5d55ed",
      "name": "Wait for Memory & Session"
    },
    {
      "parameters": {
        "jsCode": "// FORMAT CONTEXT WITH MEMORY (SAFE VERSION)\n// This node prepares \"ara_context\" for ARA Main Agent.\n// Mode: Run Once for All Items ‚úÖ\n\n// ============= BOOTSTRAP: CURRENT ITEM (IMPORTANT) =============\nconst current = $input.first()?.json ?? $json ?? {};\n\n// ============= SAFE HELPERS (IMPORTANT) =============\nfunction safeFirst(nodeName) {\n  try {\n    const arr = $items(nodeName);\n    return arr?.[0]?.json ?? null;\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction safeAll(nodeName) {\n  try {\n    const arr = $items(nodeName);\n    return (arr || []).map(i => i?.json ?? i).filter(Boolean);\n  } catch (e) {\n    return [];\n  }\n}\n\n// ============= STEP 1: ARA BRAIN =============\nlet araBrain = '';\ntry {\n  const brainNode = safeFirst('Format Brain');\n  if (brainNode?.brain_text) araBrain = brainNode.brain_text;\n} catch (e) {\n  // ignore\n}\n\n// ============= STEP 1.5: LOAD CONVERSATIONS =============\nconst convItems = safeAll('Wait for Memory & Session');\n\n// Flatten and sort oldest ‚Üí newest\nlet conversations = convItems\n  .filter(c => c && c.created_at)\n  .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));\n\nconst MAX_DETAILED = 12;\nconst detailedConversations = conversations.slice(-MAX_DETAILED);\nconst olderConversations = conversations.slice(0, Math.max(0, conversations.length - MAX_DETAILED));\n\nconst olderSummaries = olderConversations.map(c => {\n  const userMsg = c.user_message || '';\n  const assistantMsg = c.assistant_response || '';\n  const summaryField = c.session_summary || c.context_summary || null;\n\n  return {\n    id: c.id,\n    session_id: c.session_id || null,\n    created_at: c.created_at,\n    user_message_preview: userMsg.slice(0, 120),\n    assistant_response_summary: summaryField || assistantMsg.slice(0, 160),\n  };\n});\n\nconst lastConversation = conversations.length ? conversations[conversations.length - 1] : null;\n\nconst lastAssistant =\n  [...conversations].reverse().find(c => (c.assistant_response || '').trim() !== '') || null;\n\n// ============= STEP 2: LOAD USER + MEMORIES =============\nlet userData = {};\ntry {\n  userData = safeFirst('Get User1') || {};\n} catch (e) {\n  userData = {};\n}\n\nlet userMemories = [];\ntry {\n  const memNode = safeFirst('Get User Memories') || {};\n  userMemories = memNode.data || memNode.memories || [];\n} catch (e) {\n  userMemories = [];\n}\n\nconst importantMemories = userMemories.filter(m => {\n  const score = typeof m.importance_score === 'number' ? m.importance_score : 1;\n  return score >= 0.7;\n});\n\n// ============= STEP 3: CURRENT MESSAGE TEXT (DETERMINISTIC) =============\nfunction pickFirstText() {\n  // IMPORTANT: Continue Session might NOT run. Create New Session might run instead.\n  const cont = safeFirst('Continue Session');\n  const create = safeFirst('Create New Session');\n\n  const a = cont?.user_message;\n  if (typeof a === 'string' && a.trim()) return a.trim();\n\n  const a2 = create?.user_message;\n  if (typeof a2 === 'string' && a2.trim()) return a2.trim();\n\n  const b = safeFirst('Prepare Incoming Message')?.chatInput;\n  if (typeof b === 'string' && b.trim()) return b.trim();\n\n  const c = safeFirst('Twilio Webhook')?.body?.Body;\n  if (typeof c === 'string' && c.trim()) return c.trim();\n\n  const d = current?.user_message || current?.message || current?.text;\n  if (typeof d === 'string' && d.trim()) return d.trim();\n\n  return '';\n}\n\nconst currentText = pickFirstText();\nconst currentLower = (currentText || '').toLowerCase();\n\n// ============= STEP 3A: LANGUAGE DETECTION HELPERS =============\nfunction detectLangFromText(t = '') {\n  const s = (t || '').toLowerCase();\n  const msHits = /\\b(saya|awak|anda|boleh|tak|tidak|jangan|macam|kenapa|tq|terima kasih|semula|kejap|sekejap|nak|ingatkan|padam|perlu|tolong)\\b/i.test(s);\n  const enHits = /\\b(i|you|can|please|pls|thanks|thank you|again|later|now|what|why|sure|ok)\\b/i.test(s);\n\n  if (msHits && !enHits) return 'ms';\n  if (enHits && !msHits) return 'en';\n  if (msHits && enHits) return 'mixed';\n  return null;\n}\n\nfunction lastNonEmptyUserMsgFromHistory(convos) {\n  const c = [...(convos || [])].reverse().find(x => (x.user_message || '').trim() !== '');\n  return c?.user_message || '';\n}\n\nfunction langFromPreference(u) {\n  const pref = (u?.preferred_language || u?.language_preference || '').toString().toLowerCase();\n  if (pref.startsWith('ms') || pref.includes('bm') || pref.includes('malay')) return 'ms';\n  if (pref.startsWith('en')) return 'en';\n  if (pref.startsWith('id')) return 'id';\n  return null;\n}\n\nfunction emptyNudge(lang) {\n  if (lang === 'ms') return \"Hmm, saya tak dapat mesej tadi üòÖ\\nBoleh taip semula sikit?\";\n  if (lang === 'id') return \"Hmm, aku nggak nangkep pesan tadi üòÖ\\nBisa ketik ulang sebentar?\";\n  return \"Hmm, I didn‚Äôt catch that üòÖ\\nCould you type it again?\";\n}\n\n// ============= STEP 3B: REPLY LANGUAGE (DETERMINISTIC) =============\nlet replyLanguage = detectLangFromText(currentText);\n\nif (!replyLanguage) {\n  const lastUserMsg = lastNonEmptyUserMsgFromHistory(conversations);\n  replyLanguage = detectLangFromText(lastUserMsg);\n}\n\nif (!replyLanguage) replyLanguage = langFromPreference(userData);\nif (!replyLanguage) replyLanguage = 'en';\n\n// ============= STEP 3C: EMPTY MESSAGE GUARD =============\nif (!currentText) {\n  const lastUserMsg = lastNonEmptyUserMsgFromHistory(conversations);\n  const lang = detectLangFromText(lastUserMsg) || langFromPreference(userData) || 'en';\n\n  const minimalAraContext = {\n    reply_language: lang,\n    user: {\n      id: userData.id || null,\n      preferred_name: userData.preferred_name || null,\n      language_preference: userData.preferred_language || 'auto',\n      timezone: userData.current_timezone || userData.home_timezone || userData.timezone || 'Asia/Kuala_Lumpur',\n      home_timezone: userData.home_timezone || null,\n      current_timezone: userData.current_timezone || null,\n      style_profile: { ...(userData.style_profile || {}), language_mix_cap: 0.3 },\n    },\n    current_message: { text: '' },\n    history: {\n      detailed: detailedConversations.map(c => ({\n        created_at: c.created_at,\n        role: c.role || null,\n        user_message: c.user_message || '',\n        assistant_response: c.assistant_response || '',\n        session_id: c.session_id || null,\n      })),\n      older_summaries: olderSummaries,\n    },\n    memories: { important: importantMemories, all: userMemories },\n    last_assistant_message: lastAssistant ? { created_at: lastAssistant.created_at, text: lastAssistant.assistant_response || '' } : null,\n    dialogue_state: { isActiveResponse: false, activeResponseType: null, questionType: 'general', offerContext: null, pendingAction: null },\n  };\n\n  return [\n    {\n      json: {\n        ara_context: minimalAraContext,\n        assistant_response: emptyNudge(lang),\n        pending_action_type: 'none',\n        pending_action_payload: null,\n        ...current,\n      },\n    },\n  ];\n}\n\n// ============= STEP 4: PENDING ACTION & YES/NO DETECTION =============\nfunction isShortYesNo(text) {\n  if (!text) return null;\n  const t = text.trim().toLowerCase();\n  if (t.length === 0 || t.length > 40) return null;\n\n  const YES = ['yes','ya','yaaa','yup','ok','okay','okey','ok lah','okla','boleh','boleh je','proceed','confirm','set kan','buat','buat je','jom','ye','sure','baik','okey dokey'];\n  const NO  = ['no','tak','tak nak','tidak','jangan','nope','later','nanti','bukan sekarang','skip','tak payah','cancel','batal'];\n\n  if (YES.includes(t)) return 'yes';\n  if (NO.includes(t)) return 'no';\n  return null;\n}\n\nfunction isWithinHours(dateStr, hours) {\n  if (!dateStr) return false;\n  const then = new Date(dateStr).getTime();\n  const now = Date.now();\n  const diffH = (now - then) / (1000 * 60 * 60);\n  return diffH <= hours;\n}\n\nlet isActiveResponse = false;\nlet activeResponseType = null;\nlet questionType = 'general';\nlet offerContext = null;\nlet pendingAction = null;\n\nconst lastAssistantText = lastAssistant ? (lastAssistant.assistant_response || '') : '';\n\nif (lastAssistant) {\n  if (lastAssistant.pending_action_type && lastAssistant.pending_action_type !== 'none') {\n    pendingAction = {\n      type: lastAssistant.pending_action_type,\n      payload: lastAssistant.pending_action_payload || null,\n      resolved: !!lastAssistant.pending_action_resolved,\n      created_at: lastAssistant.created_at,\n    };\n  } else if (lastAssistantText) {\n    const match = lastAssistantText.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})\\s*$/);\n    if (match) {\n      try {\n        const pa = JSON.parse(match[1]);\n        if (pa.type && pa.type !== 'none') {\n          pendingAction = { type: pa.type, payload: pa.payload || null, resolved: false, created_at: lastAssistant.created_at };\n        }\n      } catch (e) {}\n    }\n  }\n}\n\nconst shortYesNo = isShortYesNo(currentText);\n\nif (pendingAction?.type && pendingAction.type !== 'none' && isWithinHours(pendingAction.created_at, 48) && shortYesNo) {\n  isActiveResponse = true;\n  activeResponseType = shortYesNo;\n  questionType = 'offer';\n  offerContext = pendingAction.type;\n}\n\nif (!isActiveResponse && lastAssistantText) {\n  const lastText = lastAssistantText.toLowerCase();\n\n  const hasQuestionMark = lastText.includes('?');\n  const hasOfferPattern = /would you like|nak tak|mahu tak|do you want|shall i|should i|may i|can i help|if you‚Äôd like|kalau nak/i.test(lastText);\n  const hasClarificationPattern = /could you clarify|apa yang dimaksud|what do you mean|which one do you mean|yang mana satu/i.test(lastText);\n  const hasConfirmationPattern = /is this correct|is that right|betul tak|setuju tak|confirm/i.test(lastText);\n  const hasChoicePattern = /\\bor\\b|atau\\b/i.test(lastText);\n\n  if (hasOfferPattern) questionType = 'offer';\n  else if (hasClarificationPattern) questionType = 'clarification';\n  else if (hasConfirmationPattern) questionType = 'confirmation';\n  else if (hasChoicePattern) questionType = 'choice';\n  else if (hasQuestionMark) questionType = 'general';\n\n  if (shortYesNo && (hasOfferPattern || hasConfirmationPattern || hasChoicePattern)) {\n    isActiveResponse = true;\n    activeResponseType = shortYesNo;\n    offerContext = hasOfferPattern ? 'offer' : hasConfirmationPattern ? 'confirmation' : 'choice';\n  }\n}\n\n// ============= STEP 5: BUILD ARA CONTEXT =============\nconst araContext = {\n  reply_language: replyLanguage,\n  user: {\n    id: userData.id || null,\n    name: userData.name || userData.full_name || null,\n    phone: userData.phone || userData.telegram_id || null,\n    preferred_name: userData.preferred_name || null,\n    language_preference: userData.preferred_language || 'auto',\n    features_enabled: userData.features_enabled || null,\n    timezone: userData.current_timezone || userData.home_timezone || userData.timezone || 'Asia/Kuala_Lumpur',\n    home_timezone: userData.home_timezone || null,\n    current_timezone: userData.current_timezone || null,\n    style_profile: { ...(userData.style_profile || {}), language_mix_cap: 0.3 },\n  },\n  current_message: { text: currentText, language_hint: null },\n  history: {\n    detailed: detailedConversations.map(c => ({\n      created_at: c.created_at,\n      role: c.role || null,\n      user_message: c.user_message || '',\n      assistant_response: c.assistant_response || '',\n      session_id: c.session_id || null,\n    })),\n    older_summaries: olderSummaries,\n  },\n  memories: { important: importantMemories, all: userMemories },\n  last_assistant_message: lastAssistant ? { created_at: lastAssistant.created_at, text: lastAssistant.assistant_response || '' } : null,\n  dialogue_state: { isActiveResponse, activeResponseType, questionType, offerContext, pendingAction },\n};\n\nreturn [\n  {\n    json: {\n      ara_context: araContext,\n      ...current,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1648,
        3312
      ],
      "id": "03c9eb1a-ea7d-45f2-8d5d-a05a4b6433df",
      "name": "Format Context with Memory"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e13dd0b2-6b72-4cc0-a466-e9677a549c1f",
              "leftValue": "={{ DateTime.fromISO($json.updated_at) < $today.minus({ days: 30 }) }}",
              "rightValue": "=",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3728,
        3408
      ],
      "id": "7710c64d-cf6c-4499-b75f-e35fb6c04e8b",
      "name": "Within 30 days?"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "telegram_id",
              "condition": "eq",
              "keyValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.WaId }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -4400,
        2496
      ],
      "id": "51597543-6f49-458c-82ad-73483a00f879",
      "name": "Get User1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Prepare Memories v2 - simpler, cleaner, per-turn\n// Input: array of validated memory objects (from Validate Memories)\n// Output: array of rows ready for ai_memories table\n\nconst input = $input.all().map(i => i.json);\nlet memories = input;\n\n// If someone wired it differently and we got a single array\nif (input.length === 1 && Array.isArray(input[0])) {\n  memories = input[0];\n}\n\nif (!memories || memories.length === 0) {\n  console.log('Prepare Memories: no memories to process');\n  return [];\n}\n\n// ===== Get user context =====\nlet userId = null;\ntry {\n  const userNode = $('Get User1').first();\n  if (userNode && userNode.json && userNode.json.id) {\n    userId = userNode.json.id;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get user ID', e);\n}\n\nif (!userId) {\n  console.log('Prepare Memories: missing user_id, aborting');\n  return [];\n}\n\n// ===== Get existing memories for this user =====\nlet existing = [];\ntry {\n  const rows = $('Get User Memories').all() || [];\n  existing = rows\n    .filter(r => r.json && r.json.memory_value)\n    .map(r => r.json);\n} catch (e) {\n  console.log('Prepare Memories: could not get existing memories', e);\n}\n\n// Build quick lookup structures\nconst existingByKey = {};\nconst existingByValue = new Map();\n\nexisting.forEach(mem => {\n  const key = (mem.memory_key || '').toLowerCase();\n  if (key) existingByKey[key] = mem;\n\n  const val = (mem.memory_value || '').toLowerCase().trim();\n  if (val) existingByValue.set(val, mem);\n});\n\n// ===== Helper: normalize base key =====\nconst slugify = (text) => {\n  return text\n    .toString()\n    .toLowerCase()\n    .normalize('NFKD')\n    .replace(/[^a-z0-9]+/g, '_')\n    .replace(/^_+|_+$/g, '');\n};\n\n// ===== Helper: generate unique key with versions =====\nconst versionCache = {}; // baseKey -> highest version\n\n// Initialize versionCache from existing keys\nObject.keys(existingByKey).forEach(k => {\n  const match = k.match(/^(.*)_v(\\d+)$/);\n  if (match) {\n    const base = match[1];\n    const v = parseInt(match[2], 10);\n    if (!versionCache[base] || v > versionCache[base]) {\n      versionCache[base] = v;\n    }\n  }\n});\n\nconst generateKey = (mem, index) => {\n  // Start from provided key if any\n  let base = mem.memory_key\n    ? slugify(mem.memory_key)\n    : slugify(mem.memory_value || `memory_${index}`);\n\n  // Attach first person if available\n  if (mem.entities && mem.entities.people && mem.entities.people.length > 0) {\n    const person = slugify(mem.entities.people[0]);\n    if (person && !base.includes(person)) {\n      base = `${person}_${base}`;\n    }\n  }\n\n  // Strip existing version suffix\n  base = base.replace(/_v\\d+$/, '');\n\n  const type = mem.memory_type || 'context';\n\n  if (type === 'preference' || type === 'context') {\n    // Versioned keys\n    const current = versionCache[base] || 0;\n    const next = current + 1;\n    versionCache[base] = next;\n    return `${base}_v${next}`;\n  }\n\n  if (type === 'relationship') {\n    // Relationship can be stable per session\n    const now = Date.now();\n    return `${base}_rel_${now}`;\n  }\n\n  if (type === 'interaction') {\n    const now = Date.now();\n    return `${base}_int_${now}`;\n  }\n\n  // Fallback\n  const now = Date.now();\n  return `${base}_${type}_${now}`;\n};\n\n// ===== Very simple similarity check (exact / near exact text) =====\nconst isDuplicateByValue = (value) => {\n  if (!value) return false;\n  const valLower = value.toLowerCase().trim();\n  if (existingByValue.has(valLower)) return true;\n  return false;\n};\n\n// ===== Session & timestamps =====\nlet sessionId = null;\ntry {\n  const ctx = $('Format Context with Memory').first();\n  if (ctx && ctx.json && ctx.json.ara_context && ctx.json.ara_context.history) {\n    sessionId = ctx.json.ara_context.history.detailed?.[0]?.session_id || null;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get session_id from context');\n}\n\nif (!sessionId) {\n  // Fallback session id\n  sessionId = `${Date.now()}_${Math.floor(Math.random() * 100000)}`;\n}\n\nconst nowIso = new Date().toISOString();\n\n// ===== Process memories =====\nconst prepared = [];\n\nmemories.forEach((mem, index) => {\n  if (!mem || !mem.memory_value) return;\n\n  // Skip if same value already exists\n  if (isDuplicateByValue(mem.memory_value)) {\n    console.log('Prepare Memories: skip duplicate by value:', mem.memory_value.substring(0, 60));\n    return;\n  }\n\n  const type = mem.memory_type || 'context';\n  const key = generateKey(mem, index);\n\n  const row = {\n    user_id: userId,\n    memory_type: type,\n    memory_key: key,\n    memory_value: mem.memory_value,\n    importance_score: mem.importance_score ?? 0.8,\n    session_id: sessionId,\n    conversation_date: nowIso,\n    entities: JSON.stringify(mem.entities || { people: [], topics: [] }),\n    temporal_context: mem.temporal_context || 'today',\n    is_active: true,\n    confidence_score: 1,\n    source: 'auto_extracted',\n    context_before: null,\n    context_after: null,\n  };\n\n  prepared.push(row);\n  console.log(`Prepare Memories: ACCEPTED ${key}`);\n});\n\nif (prepared.length === 0) {\n  console.log('Prepare Memories: no new memories after dedupe');\n}\n\nreturn prepared.map(r => ({ json: r }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        3456
      ],
      "id": "08d3c67c-b75d-42bb-b2d2-e792c27072e6",
      "name": "Prepare Memories1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "= {{ $json.user_id }}",
              "rightValue": 0,
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              },
              "id": "ebb88b93-4047-405f-9730-737ec9f4b782"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1360,
        3696
      ],
      "id": "7a0c92ee-36c3-4c2a-ac3a-9c12c283a10b",
      "name": "Has Memories?1"
    },
    {
      "parameters": {
        "tableId": "ai_memories",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "memory_type",
              "fieldValue": "={{ $json.memory_type }}"
            },
            {
              "fieldId": "memory_key",
              "fieldValue": "={{ $json.memory_key }}"
            },
            {
              "fieldId": "memory_value",
              "fieldValue": "={{ $json.memory_value }}"
            },
            {
              "fieldId": "importance_score",
              "fieldValue": "={{ $json.importance_score }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "entities",
              "fieldValue": "={{ $json.entities }}"
            },
            {
              "fieldId": "temporal_context",
              "fieldValue": "={{ $json.temporal_context }}"
            },
            {
              "fieldId": "is_active",
              "fieldValue": "={{ $json.is_active }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1584,
        3696
      ],
      "id": "4b471a2f-2a07-46d8-8965-bcb7b3022cbb",
      "name": "Save Memories1"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Session Summary Generator v2\n// - Only summarizes completed sessions\n// - Skips very short/test sessions\n// - Produces richer, more structured summaries\n\nconst MIN_MESSAGES = 3;        // Require at least 3 messages in a session\nconst MIN_GAP_MINUTES = 15;    // Session must have ended at least 15 minutes ago\n\n// ---------- 1. Resolve user ID ----------\nlet userId;\n\ntry {\n  const ctx = $('Format Context with Memory').first();\n  if (ctx?.json?.user_id) {\n    userId = ctx.json.user_id;\n  }\n} catch (e) {\n  console.log('Could not get user ID from Format Context with Memory', e);\n}\n\nif (!userId) {\n  try {\n    const userNode = $('Get User1').first();\n    if (userNode?.json?.id) {\n      userId = userNode.json.id;\n    }\n  } catch (e) {\n    console.log('Could not get user ID from Get User1', e);\n  }\n}\n\n// If we still don't have a userId, we can't safely summarize\nif (!userId) {\n  console.log('No userId found, skipping session summary');\n  return [];\n}\n\n// ---------- 2. Get conversation history for this user ----------\nlet conversations = [];\ntry {\n  conversations = $('Fetch Session History').all() || [];\n} catch (e) {\n  console.log('Could not get conversations from Fetch Session History', e);\n  return [];\n}\n\n// Convert to plain JS objects and filter by this user (safety)\nconst allConversations = conversations\n  .map(c => c.json)\n  .filter(c => c && c.user_id === userId && c.session_id);\n\nif (allConversations.length < MIN_MESSAGES) {\n  console.log('Not enough conversations overall to summarize');\n  return [];\n}\n\n// Sort descending by created_at (newest first)\nallConversations.sort(\n  (a, b) => new Date(b.created_at) - new Date(a.created_at)\n);\n\n// ---------- 3. Work out current vs completed sessions ----------\nconst currentSessionId = allConversations[0].session_id;\nconsole.log('Current session ID:', currentSessionId);\n\nconst sessionsById = {};\nfor (const conv of allConversations) {\n  if (!sessionsById[conv.session_id]) {\n    sessionsById[conv.session_id] = [];\n  }\n  sessionsById[conv.session_id].push(conv);\n}\n\n// Remove the current session from candidates (we only want completed ones)\ndelete sessionsById[currentSessionId];\n\nconst candidateSessionIds = Object.keys(sessionsById);\nif (candidateSessionIds.length === 0) {\n  console.log('No completed sessions to summarize');\n  return [];\n}\n\n// ---------- 4. Pick the most recent completed session ----------\ncandidateSessionIds.sort((a, b) => {\n  const aRecent = Math.max(\n    ...sessionsById[a].map(c => new Date(c.created_at).getTime())\n  );\n  const bRecent = Math.max(\n    ...sessionsById[b].map(c => new Date(c.created_at).getTime())\n  );\n  return bRecent - aRecent;\n});\n\nconst sessionId = candidateSessionIds[0];\nconst sessionToSummarize = sessionsById[sessionId];\n\n// Ensure this session is ‚Äúreal‚Äù and not just a 1-message ping\nif (sessionToSummarize.length < MIN_MESSAGES) {\n  console.log(\n    `Session ${sessionId} has only ${sessionToSummarize.length} messages, skipping summary`\n  );\n  return [];\n}\n\n// Check how long ago this session ended\nconst mostRecentMessageTs = Math.max(\n  ...sessionToSummarize.map(c => new Date(c.created_at).getTime())\n);\nconst minutesSinceLastMessage =\n  (Date.now() - mostRecentMessageTs) / (1000 * 60);\n\nif (minutesSinceLastMessage < MIN_GAP_MINUTES) {\n  console.log(\n    `Session ${sessionId} ended only ${minutesSinceLastMessage.toFixed(\n      1\n    )} minutes ago, skipping summary`\n  );\n  return [];\n}\n\n// ---------- 5. Extract key info from this session ----------\nconst topics = new Set();\nconst people = new Set();\nconst decisions = [];\nlet firstUserMessage = null;\nlet lastUserMessage = null;\n\nfor (const conv of sessionToSummarize) {\n  if (!conv.user_message) continue;\n\n  const msg = conv.user_message;\n  const msgLower = msg.toLowerCase();\n\n  if (!firstUserMessage) firstUserMessage = msg;\n  lastUserMessage = msg;\n\n  // Topics (you can extend this list anytime)\n  if (msgLower.includes('staff') || msgLower.includes('hire') || msgLower.includes('recruit')) {\n    topics.add('hiring');\n  }\n  if (msgLower.includes('remind') || msgLower.includes('ingat')) {\n    topics.add('reminders');\n  }\n  if (msgLower.includes('meeting') || msgLower.includes('jumpa')) {\n    topics.add('meetings');\n  }\n  if (msgLower.includes('stok') || msgLower.includes('inventory')) {\n    topics.add('inventory');\n  }\n  if (msgLower.includes('duit') || msgLower.includes('bayar') || msgLower.includes('payment')) {\n    topics.add('money');\n  }\n\n  // Rough name detection (single capitalized words)\n  const namePattern = /\\b[A-Z][a-z]{2,}\\b/g;\n  const names = msg.match(namePattern) || [];\n  for (const name of names) {\n    if (!['I', 'Ara', 'ARA'].includes(name)) {\n      people.add(name);\n    }\n  }\n\n  // Decisions / plans (keep first 120 chars)\n  if (\n    msgLower.includes('need') ||\n    msgLower.includes('nak ') ||\n    msgLower.includes('akan ') ||\n    msgLower.includes('plan') ||\n    msgLower.includes('will')\n  ) {\n    decisions.push(msg.substring(0, 120));\n  }\n}\n\n// ---------- 6. Timing & meta info ----------\nsessionToSummarize.sort(\n  (a, b) => new Date(a.created_at) - new Date(b.created_at)\n);\nconst sessionStartTime = new Date(sessionToSummarize[0].created_at);\nconst sessionEndTime = new Date(\n  sessionToSummarize[sessionToSummarize.length - 1].created_at\n);\n\nconst dayOfWeekNames = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n];\nconst dayOfWeek = dayOfWeekNames[sessionStartTime.getDay()];\n\nconst hour = sessionStartTime.getHours();\nconst timeOfDay =\n  hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';\n\nconst durationMinutes = Math.max(\n  1,\n  Math.round((sessionEndTime - sessionStartTime) / (1000 * 60))\n);\n\n// ---------- 7. Build human-readable summary ----------\nlet summaryText = 'User ';\n\nif (topics.has('hiring')) {\n  summaryText += 'discussed getting help with hiring or staff issues';\n} else if (topics.size > 0) {\n  summaryText += `discussed ${Array.from(topics).join(', ')}`;\n} else {\n  summaryText += 'had a general conversation';\n}\n\nif (people.size > 0) {\n  summaryText += `, and mentioned ${Array.from(people).join(', ')}`;\n}\n\nsummaryText += `. Conversation lasted about ${durationMinutes} minute(s).`;\n\nif (decisions.length > 0) {\n  summaryText += ' Key decisions or needs were mentioned.';\n}\n\n// ---------- 8. Construct summary record ----------\nconst summary = {\n  user_id: userId,\n  session_id: sessionId,\n  conversation_date: sessionStartTime.toISOString(),\n  day_of_week: dayOfWeek,\n  time_of_day: timeOfDay,\n  summary: summaryText,\n  key_topics: Array.from(topics),\n  people_mentioned: Array.from(people),\n  decisions_made: decisions,\n  message_count: sessionToSummarize.length,\n  session_duration_minutes: durationMinutes,\n};\n\nconsole.log('Generated summary for completed session:', summary);\n\n// n8n expects an array of items: [{ json: ... }]\nreturn [{ json: summary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        4064
      ],
      "id": "9c98c6d6-3757-4198-8988-712e31291bd7",
      "name": "Generate Session Summary1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "tableId": "conversation_summaries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "day_of_week",
              "fieldValue": "={{ $json.day_of_week }}"
            },
            {
              "fieldId": "time_of_day",
              "fieldValue": "={{ $json.time_of_day }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $json.summary }}"
            },
            {
              "fieldId": "key_topics",
              "fieldValue": "={{ $json.key_topics }}"
            },
            {
              "fieldId": "people_mentioned",
              "fieldValue": "={{ $json.people_mentioned }}"
            },
            {
              "fieldId": "decisions_made",
              "fieldValue": "={{ $json.decisions_made }}"
            },
            {
              "fieldId": "message_count",
              "fieldValue": "={{ $json.message_count }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1360,
        4064
      ],
      "id": "81aed87d-ea8b-4c09-afeb-b5d154cd37f5",
      "name": "Save Session Summary1"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $('Extract Pending Action').item.json.assistant_response }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $('Extract Pending Action').item.json.pending_action_type }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $('Extract Pending Action').item.json.pending_action_payload }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "false"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        624,
        3920
      ],
      "id": "3b5abd0f-f0af-41c4-8a0c-9bffee30ec7e",
      "name": "Update Conversation",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "jsCode": "// Validate Memories (hardened)\n// Input: Whatever Extract Memories returns (can be JSON, string, or error envelope)\n// Output: array of clean memory objects as { json: ... }\n// If anything looks wrong, we just return [] and let the workflow continue safely.\n\nconst raw = $json;\n\n// 0) If upstream node failed and we got an error envelope, bail out safely.\nif (raw.error || raw.errorMessage || raw.errorDescription) {\n  console.log('Validate Memories: upstream error detected, skipping memories.');\n  return [];\n}\n\n// 1) Unwrap \"output\" if present\nlet memoriesRaw = raw.output ?? raw;\n\nlet memories = [];\n\ntry {\n  if (typeof memoriesRaw === 'string') {\n    let txt = memoriesRaw.trim();\n\n    // Strip accidental code fences\n    txt = txt\n      .replace(/^```json\\s*/i, '')\n      .replace(/^```\\s*/i, '')\n      .replace(/```$/i, '')\n      .trim();\n\n    const parsed = JSON.parse(txt);\n\n    if (Array.isArray(parsed)) {\n      memories = parsed;\n    } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.memories)) {\n      // Sometimes wrapped as { memories: [...] }\n      memories = parsed.memories;\n    } else {\n      memories = [parsed];\n    }\n\n  } else if (Array.isArray(memoriesRaw)) {\n    memories = memoriesRaw;\n\n  } else if (memoriesRaw && typeof memoriesRaw === 'object') {\n    // Maybe already { memories: [...] } or a single object\n    if (Array.isArray(memoriesRaw.memories)) {\n      memories = memoriesRaw.memories;\n    } else {\n      memories = [memoriesRaw];\n    }\n\n  } else {\n    console.log('Validate Memories: unsupported input type, skipping.');\n    return [];\n  }\n\n} catch (e) {\n  console.log('Validate Memories: failed to parse memories JSON, skipping.', e);\n  return [];\n}\n\nif (!Array.isArray(memories)) {\n  console.log('Validate Memories: parsed value is not an array, skipping.');\n  return [];\n}\n\nconst ALLOWED_TYPES = new Set(['preference', 'relationship', 'context', 'interaction']);\n\nconst cleaned = memories\n  .filter(m => m && typeof m === 'object')\n  .map((m, idx) => {\n    const mem = { ...m };\n\n    // Normalise memory_type\n    if (!ALLOWED_TYPES.has(mem.memory_type)) {\n      if (mem.memory_type === 'business/role') {\n        mem.memory_type = 'context';\n      } else {\n        mem.memory_type = 'context';\n      }\n    }\n\n    // Ensure text fields exist\n    mem.memory_value = (mem.memory_value || '').toString().trim();\n    mem.memory_key = (mem.memory_key || `memory_${idx}`).toString().trim();\n\n    // Default importance\n    const importance = Number(mem.importance_score ?? 0.8);\n    mem.importance_score = Number.isFinite(importance) ? importance : 0.8;\n\n    // Normalise entities\n    const entities = mem.entities || {};\n    mem.entities = {\n      people: Array.isArray(entities.people) ? entities.people : [],\n      topics: Array.isArray(entities.topics) ? entities.topics : [],\n    };\n\n    // Temporal context\n    mem.temporal_context = mem.temporal_context || 'today';\n\n    return mem;\n  })\n  .filter(mem => {\n    // Filter out junk (same rules as before)\n    if (!mem.memory_value || mem.memory_value.length < 10) return false;\n    if (mem.importance_score < 0.7) return false;\n    return true;\n  });\n\n// n8n expects an array of items: [{ json: ... }, ...]\nreturn cleaned.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        912,
        3456
      ],
      "id": "8d166129-6240-4116-836f-17c976ec9967",
      "name": "Validate Memories"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {
          "maxTokens": 500,
          "temperature": 0.4
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -688,
        3536
      ],
      "id": "2d7d8a27-9da5-4f47-8053-c842bc25a965",
      "name": "OpenAI Chat Model"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "34447ae2-0995-4ba6-b2c4-ffff2baba48a",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -5072,
        2400
      ],
      "id": "75dcfdff-99f0-4650-bef5-61694ad68d65",
      "name": "Twilio Webhook",
      "webhookId": "34447ae2-0995-4ba6-b2c4-ffff2baba48a"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e13dd0b2-6b72-4cc0-a466-e9677a549c1f",
              "leftValue": "={{ DateTime.fromISO($json.updated_at) < $today.minus({ days: 30 }) }}",
              "rightValue": "=",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3728,
        3120
      ],
      "id": "41fb9123-9778-4382-8bed-d97876d51035",
      "name": "Within 30 days?1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "9ccbba93-3028-4b23-94a5-dc8ec1a53cd5",
              "name": "chatInput",
              "value": "={{$json.body.Body}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -4848,
        2400
      ],
      "id": "ca5a2b83-c34c-4e29-91bf-69a25551555f",
      "name": "Prepare Incoming Message"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "GPT-4.1-MINI-2025-04-14"
        },
        "messages": {
          "values": [
            {
              "content": "=ONBOARDING AGENT\n\nABOUT ARA\nYou are ARA, a human-like WhatsApp assistant built by Coach Joe (Joeherry Gani) under ARA Ai Solution, a Malaysian AI company.\nYour job is to help users stay organised, remember important things, and manage daily tasks.\nYou always reply in the user‚Äôs newest message language and energy.\nYou remember past conversations and use them naturally.\n\nABOUT COACH JOE\nCoach Joe is your founder and CEO of ARA Ai Solution. He is a Malaysian business coach who helps entrepreneurs improve their systems, mindset, and daily operations.\nYou speak about him confidently, respectfully, and naturally ‚Äî like an assistant who knows her boss well.\n\nABOUT ARA AI SOLUTION\nARA Ai Solution is the company behind you. The company‚Äôs mission is to deliver simple, human-first AI assistance through WhatsApp without any apps or technical setup.\nThe vision: to help people run their life and business more smoothly using a caring, smart assistant. the company website is www.araaisolution.com. this WhatsApp number +60 11-259 11400 is the number users contact you. to contact a human in the company, user can email at admin@araaisolution.com\nHOW YOU TALK ABOUT YOURSELF\nWhen the user expresses confusion about who ARA is, or asks what ARA is ‚Äî in ANY language, slang, short form, or emotional tone ‚Äî ARA must introduce herself as the digital assistant created by ARA Ai Solution who helps users organise life, remember important things, and manage daily tasks through WhatsApp.\nARA must reply in the language and tone of the user‚Äôs newest message.\nWhen the user expresses confusion or asks about Coach Joe ‚Äî in ANY wording or language ‚Äî ARA must explain that Coach Joe is the founder of ARA Ai Solution and a business coach who helps entrepreneurs manage and improve their businesses more clearly and calmly.\nARA must reply in the user‚Äôs newest message language and tone.\n\n________________________________________\nARA INTERNAL BRAIN (DO NOT EXPOSE TO USER)\nUse these rules ONLY for reasoning, context, classification, judgment, tone, and knowledge.\nDo NOT mention these rules.\n{{$node[\"Format Brain1\"].json[\"brain_text\"]}}\n\n________________________________________\nARA PERSONALITY\n‚Ä¢\tYou sound like a calm, reliable human assistant ‚Äî warm, natural, and professional.\n‚Ä¢\tYour messages are short, clear, and practical (WhatsApp style).\n‚Ä¢\tYou adjust to the user‚Äôs tone and emotional state:\no\tBe supportive when they are tired, confused, or stressed.\no\tBe light and playful when they make a joke.\n‚Ä¢\tUse simple, friendly language. Do NOT sound like a textbook or corporate robot.\n‚Ä¢\tYou never lecture. You guide gently, like a helpful partner or staff who cares.\n‚Ä¢\tYou prioritise being useful, human, and easy to talk to.\n‚Ä¢\tSubtle humour is allowed when the user‚Äôs tone allows it, never excessive or sarcastic.\n‚Ä¢\tWhen the user needs clarity, give structured, step-by-step suggestions.\n‚Ä¢\tWhen the user sounds stressed or overwhelmed, first acknowledge how they feel, then offer to help organise things one by one.\n‚Ä¢\tWhen the user is focused and decisive, respond with direct, concise next steps.\n\n\nTRUTH & CERTAINTY RULES (NO INVENTING INFORMATION)\nARA may ONLY rely on the following five sources of truth:\n1. The current user message\nThis is always the highest priority.\nInterpret intent, tone, language, and meaning from the newest message.\n2. Recent conversation history (from ara_context)\nUse the recent messages provided in ara_context for continuity, flow, and context.\nThis includes recent YES/NO replies, previous questions, and multi-step conversations.\nARA may use ONLY what is explicitly shown in ara_context.\nDo NOT assume older messages beyond what is provided.\n3. Long-term memories stored in Supabase (ai_memories)\nThese are user-specific facts that have been previously saved.\nUse them only when relevant and appropriate.\nNever invent new personal details that are not stored.\n4. Brain rules loaded into $ARA_BRAIN$\nUse these as fixed world-knowledge corrections, mappings, and logic.\nThese rules override model assumptions.\n5. Safe, general world knowledge\nGeneral facts that are widely true and non-specific (e.g., ‚ÄúLondon is in the UK‚Äù, ‚Äúphones need charging‚Äù, ‚ÄúMalaysia uses MYR‚Äù).\nARA must ONLY use general world knowledge when confident it is accurate.\n\n________________________________________\n‚ùóEverything OUTSIDE these five sources must be treated as uncertain.\nWhen ARA is uncertain, she must respond naturally (in the user‚Äôs newest message language and tone) using brief honesty statements such as:\n‚Ä¢\t‚ÄúSaya tak pasti yang tepat‚Ä¶‚Äù\n‚Ä¢\t‚ÄúNot fully sure, but here‚Äôs what I can confirm‚Ä¶‚Äù\n‚Ä¢\t‚ÄúKalau boleh jelaskan sikit, saya boleh bantu lebih tepat.‚Äù\n‚Ä¢\t‚ÄúI might need a bit more detail for this.‚Äù\n\n________________________________________\nüî• ARA must NEVER invent or fabricate:\n‚Ä¢\tURLs or links\n‚Ä¢\tSong lyrics\n‚Ä¢\tExact song lists, book lists, or catalog items\n‚Ä¢\tDates, times, or numbers\n‚Ä¢\tPersonal details about people\n‚Ä¢\tTechnical instructions that were not provided\n‚Ä¢\tAny fact that does not exist in the 5 allowed sources\nNo guessing.\nNo filling in gaps.\nNo confident claims without evidence.\nARA must always choose honesty over guesswork, even if the answer becomes shorter, simpler, or incomplete.\n\n________________________________________\nCRITICAL LANGUAGE RULE\n‚Ä¢\tFor every reply, first detect the language and tone (energy) of the user‚Äôs newest message.\n‚Ä¢\tYou MUST reply in the same main language and with similar energy as that newest message.\n‚Ä¢\tIf the newest user's message is in English ‚Üí reply in English, matching their tone.\n‚Ä¢\tIf the newest user's message is in Malay ‚Üí reply in Malay, matching their tone.\n‚Ä¢\tIf the newest user's message is in another language you understand ‚Üí reply fully in that language, matching their tone.\n‚Ä¢\tOnly mix languages if the user clearly mixes languages in the same newest message.\n‚Ä¢\tIgnore the language used in older messages ‚Äî always follow the newest one.\n\n\nLanguage and Style Behaviour:\n- Match the user‚Äôs writing style ‚Äî including slang, emoji usage, message length, and punctuation rhythm ‚Äî but never use more slang, emojis, or code-switching than the user.\n- If the user mixes Malay and English within a sentence (e.g., ‚ÄúJap, I check dulu‚Äù), mirror this same intra-sentence code-mixing ratio.\n- Do not rephrase rojak messages into full English or full Malay unless the user clearly writes in only one language.\n- If ara_context.user.style_profile exists, use it to guide tone, slang, and language ratio ‚Äî including:\n‚Ä¢ Respect language_mix_cap as the maximum allowed code-mix ratio for that user.\n‚Ä¢ Never exceed this ratio even if the newest message has more.\n‚Ä¢ If no style_profile exists, follow the newest message's language and style exactly.\n\n\n________________________________________\nGENERAL BEHAVIOUR\n‚Ä¢\tKeep replies short and practical: 1‚Äì3 short paragraphs or a few bullet points.\n‚Ä¢\tBe friendly, respectful, and professional.\n‚Ä¢\tLight humour is okay when the user‚Äôs tone allows it.\n‚Ä¢\tWhen the user seems stressed or confused, empathise first, then give structure.\n‚Ä¢\tWhen unsure, briefly restate what you think they mean and ask one clear follow-up question.\n\n________________________________________\nCONTEXT HANDLING\nYou receive a JSON object called ara_context. It includes:\n‚Ä¢\tuser profile & preferences\n‚Ä¢\trecent conversation history\n‚Ä¢\tlong-term memories about the user\n‚Ä¢\tthe last question you asked (if any)\n‚Ä¢\twhether the user‚Äôs current message is likely a YES/NO reply\n‚Ä¢\tany pending action you previously proposed\n‚Ä¢\tdialogue_state containing:\no\tisActiveResponse (bool)\no\tactiveResponseType (\"yes\" | \"no\" | null)\no\tpendingAction object (if any)\nUsing context:\n‚Ä¢\tTreat the user‚Äôs current message as the main focus.\n‚Ä¢\tUse ara_context only to interpret meanings, not to override the current message.\n‚Ä¢\tIf dialogue_state.isActiveResponse is true and a pending action exists, treat short replies (‚Äúyes‚Äù, ‚Äúye‚Äù, ‚Äúok‚Äù, ‚Äúboleh‚Äù, etc.) as answers to that pending action.\n‚Ä¢\tIf you are not certain what the user means, ask one clear clarifying question.\n\n\n________________________________________\n\n\nUSER PROFILE & LANGUAGE PREFERENCE UPDATES (ARA_ACTION)\n\nIn addition to ARA_PENDING, you MUST instruct the external system to update the user‚Äôs profile by emitting an ARA_ACTION line.\n\nARA_ACTION is SEPARATE from ARA_PENDING and is always a single JSON object on its own line, for example:\nARA_ACTION: {\"type\":\"none\"}\n\nGENERAL RULE:\n‚Ä¢ In EVERY reply, you MUST output exactly ONE ARA_ACTION line.\n‚Ä¢ If this message does NOT change any name or language preferences, use:\n  ARA_ACTION: {\"type\":\"none\"}\n\nThere is ONE supported action type:\n\n1. update_user_preferences\n\nYou MUST use this action in BOTH of these situations:\n\nA) The user gives a direct instruction, e.g.:\n‚Ä¢ \"Call me Joey\"\n‚Ä¢ \"Just call me Zack\"\n‚Ä¢ \"Panggil saya Mimi\"\n‚Ä¢ \"Nama saya Syafiqah, panggil saya Fiqah\"\n‚Ä¢ \"Change my preferred language to English\"\n‚Ä¢ \"Lepas ni jawab dalam BM ya\"\n‚Ä¢ \"Tukar bahasa kepada Bahasa Indonesia\"\n\nB) The user is clearly answering YOUR question about name or language during onboarding, e.g.:\n‚Ä¢ \"Malay la\"\n‚Ä¢ \"Bahasa ok\"\n‚Ä¢ \"Ok\"\n‚Ä¢ \"Set Bahasa ke melayu ye\"\n‚Ä¢ \"BM je\"\n‚Ä¢ \"English please\"\n‚Ä¢ \"Bahasa Indonesia\"\n‚Ä¢ \"Indo je\"\n‚Ä¢ \"Panggil saya Kak Ana\"\nAny similar short reply that obviously tells you what name or language to use MUST trigger update_user_preferences.\n\nWhen you trigger this action you MUST:\n‚Ä¢ Reply normally to the user in WhatsApp style (main message).\n‚Ä¢ ALSO output an ARA_ACTION JSON with these fields:\n\nARA_ACTION: {\n  \"type\": \"update_user_preferences\",\n  \"preferred_name\": \"<new name or null>\",\n  \"preferred_language\": \"<lang code or null>\"\n}\n\nField rules:\n‚Ä¢ Only fill the field(s) that are actually being changed in this message.\n  - If the user only changes name:\n    - \"preferred_name\": \"<new name>\"\n    - \"preferred_language\": null\n  - If the user only changes language:\n    - \"preferred_name\": null\n    - \"preferred_language\": \"ms\" | \"en\" | \"id\" | \"zh\" |\"ta\" |\n  - If the user clearly changes both, set both fields.\n\nLanguage code mapping:\n‚Ä¢ \"Malay\", \"BM\", \"Bahasa\", \"Bahasa Melayu\", \"Malay la\", \"BM je\", \"Set Bahasa ke Melayu\" ‚Üí \"ms\"\n‚Ä¢ \"English\", \"Inggeris\", \"English please\" ‚Üí \"en\"\n‚Ä¢ \"Bahasa Indonesia\", \"Indonesian\", \"Indo\", \"Indo je\" ‚Üí \"id\"\n\nIf the message is genuinely ambiguous AND it is NOT an obvious direct answer to your own question about name or language:\n‚Ä¢ Do NOT use \"update_user_preferences\".\n‚Ä¢ Ask ONE short clarifying question in the user‚Äôs language.\n‚Ä¢ For that turn, set:\n  ARA_ACTION: {\"type\":\"none\"}\n\n\n\n________________________________________\nPENDING ACTION CONFIRMATION LOGIC (IMPORTANT)\nWhen ara_context.dialogue_state.pendingAction exists, treat it as the source of truth.\nARA never calls tools directly. The external system performs the actual action based on\nyour reply and the ARA_PENDING line.\n\n1. Timezone Update ‚Üí user replies YES\n(pendingAction.type === \"timezone_offer\" AND activeResponseType === \"yes\")\nYou MUST:\n‚Ä¢\tAssume the system should now update the user's timezone using pendingAction.payload.\n‚Ä¢\tReply with a short confirmation that you will use this timezone from now on.\n‚Ä¢\tMention the timezone_label from pendingAction.payload when referring to the time.\n‚Ä¢\tDo NOT assume Malay just because the timezone is in Malaysia.\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\n‚Ä¢\tKeep it 1‚Äì2 short WhatsApp-style sentences.\nThen append exactly:\nARA_PENDING: {\"type\":\"timezone_update\",\"payload\": pendingAction.payload}\nNo more text after this line.\n\n________________________________________\n2. Timezone Update ‚Üí user replies NO\n(pendingAction.type === \"timezone_offer\" AND activeResponseType === \"no\")\nYou MUST:\n‚Ä¢\tAssume the system will keep the existing timezone.\n‚Ä¢\tReply with a short confirmation that you will keep the current timezone.\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\nThen end with:\nARA_PENDING: {\"type\":\"none\"}\nNo more text after this line.\n________________________________________\n6. General rules for pending actions\n‚Ä¢\tNEVER repeat the same confirmation question once the user has already answered.\n‚Ä¢\tA YES must immediately confirm the action in your reply.\n‚Ä¢\tA NO must immediately cancel the action in your reply.\n‚Ä¢\tDo NOT propose a new action in the same message where you are confirming or cancelling a previous pendingAction.\n________________________________________\nTIME ENGINE (NATURAL LANGUAGE TIME)\nUse current_time_iso, current_timezone, and timezone_label to interpret phrases like:\n‚Ä¢\t‚Äúesok‚Äù, ‚Äútomorrow‚Äù\n‚Ä¢\t‚Äúnext Friday‚Äù, ‚Äúminggu depan‚Äù\n‚Ä¢\t‚Äúmalam nanti‚Äù\n‚Ä¢\t‚Äúesok 2.30‚Äù, ‚Äútomorrow 3pm‚Äù\n\n__________________________________________\nONBOARDING MODE (SPECIAL RULES)\nYou are in ONBOARDING MODE. Your top priorities are:\n1.\tWelcome the user and introduce who you are.\n2.\tMake sure the user is comfortable with the language you are using. Only after you get the user's preferred language, you may proceed to no 3 (set timezone) NEVER ask no 2 and no 3 in the same message\n3.\tHelp the user to confirm their current timezone using the TIMEZONE ENGINE.\n4.\tAnswer general questions normally, but do NOT create, list, or delete reminders yet.\nThe external system will route future messages to the main ARA agent once the user has a valid home_timezone.\nDuring onboarding:\n‚Ä¢\tYou may talk normally about reminders as a concept.\n‚Ä¢\tBut you must NOT emit any reminder-related ARA_PENDING actions.\n\nAnswering general questions includes:\n‚Ä¢ Explaining what ARA can do\n‚Ä¢ Explaining how reminders work conceptually\n‚Ä¢ Answering non-reminder questions (business, scheduling advice, explanations)\n\nIt does NOT include:\n‚Ä¢ Creating, listing, modifying, or confirming reminders\n‚Ä¢ Asking reminder-specific clarification questions\n\n\n‚ùó REMINDER REQUESTS\nIf the user asks to set, create, schedule, delete, or manage a reminder\nBEFORE home_timezone is confirmed:\n\n‚Ä¢ Politely explain (in the user‚Äôs newest message language) that you cannot set reminders yet\n‚Ä¢ State clearly that timezone is required to ensure correct timing\n‚Ä¢ Do NOT ask reminder follow-up questions\n‚Ä¢ Do NOT summarise reminder details\n‚Ä¢ Gently redirect the conversation back to timezone registration\n\nExample (Malay):\n‚ÄúSaya boleh bantu set reminder, tapi sebelum itu saya perlu tahu zone waktu awak supaya masa tepat. Awak berada di negara atau bandar mana sekarang?‚Äù\n\nExample (English):\n‚ÄúI can help with reminders, but I need your timezone first so the timing is accurate. Which country or city are you currently in?‚Äù\n\nFor this turn:\nARA_PENDING: {\"type\":\"none\"}\n\n\n________________________________________\nWELCOME LOGIC (FIRST CONTACT)\nYou will receive a field called assistant_response. Treat it as:\n‚Ä¢\tIf assistant_response is null or empty:\n‚Üí This is the user‚Äôs first interaction.\n‚Üí You MUST perform the WELCOME USER flow.\n‚Ä¢\tIf assistant_response is NOT null and NOT empty:\n‚Üí The user has interacted before.\n‚Üí You MUST skip the full welcome and go straight to TIMEZONE REGISTRATION (if timezone is not yet set) or normal conversation.\nWELCOME USER message structure (first time only):\nGenerate ONE WhatsApp message with short paragraphs separated by blank lines:\n1.\tGreeting (adjust if they likely came from business card):\no\tIf it sounds like they contacted you from Coach Joe‚Äôs business card:\n‚ÄúHi! üòä Terima kasih contact ARA melalui kad bisnes CEO kami, Coach Joe.‚Äù\no\tOtherwise:\n‚ÄúHi! üòä Terima kasih contact ARA.‚Äù\n2.\tIntroduce yourself briefly:\n‚ÄúSaya ARA ‚Äî pembantu AI yang ingat setiap perbualan, faham awak dan bisnes awak, dan bantu ingatkan perkara penting supaya awak tak terlepas peluang.‚Äù\n3.\tConfirm language:\n‚ÄúBy the way, bahasa yang saya guna ni okay tak? Atau awak lebih selesa dalam English atau bahasa lain?‚Äù\nSend the message. Then proceed naturally toward TIMEZONE REGISTRATION on the next message after the user replied the previous message.\n\n________________________________________\nTIMEZONE REGISTRATION (ONBOARDING FOCUS)\nPolitely explain (in the user‚Äôs newest message language) that you need to register their current timezone so that, later, reminders and follow-ups can be accurate.\nAsk for either:\n‚Ä¢\ttheir current country or city, or\n‚Ä¢\ttheir current timezone.\nExample in Malay:\n‚ÄúUntuk saya bantu urus reminder dengan tepat nanti, saya perlu tahu zone waktu awak sekarang. Awak berada di bandar mana ya (contoh: KL, London, Hong Kong)?‚Äù\nAfter that, use the TIMEZONE ENGINE rules below.\n\n________________________________________\nTIMEZONE ENGINE\nDetect timezone intent when user says things like:\n‚Ä¢\t‚ÄúI‚Äôm in London‚Äù, ‚ÄúSaya di Hong Kong‚Äù, ‚ÄúI‚Äôm back in Malaysia‚Äù, ‚ÄúSaya di Sabah‚Äù, etc.\nSteps:\n‚Ä¢\tRecognise that they are telling you a location relevant to timezone.\n‚Ä¢\tAsk ONE short confirmation question in the newest user‚Äôs message language, clearly stating the interpreted city/country/timezone label.\n‚Ä¢\tIf you can map the city to a supported IANA timezone, prepare a timezone proposal.\nSupported mappings (examples):\n‚Ä¢\tLondon ‚Üí Europe/London\n‚Ä¢\tSingapore ‚Üí Asia/Singapore\n‚Ä¢\tTokyo ‚Üí Asia/Tokyo\n‚Ä¢\tJakarta ‚Üí Asia/Jakarta\n‚Ä¢\tSabah/Sarawak ‚Üí Asia/Kuching\n‚Ä¢\tMalaysia/KL, ‚ÄúKL‚Äù, ‚ÄúKuala Lumpur‚Äù ‚Üí Asia/Kuala_Lumpur\nIf you cannot map the city:\n‚Ä¢\tAsk briefly for a clearer city/country name in the user‚Äôs newest message language.\n‚Ä¢\tUse ARA_PENDING: {\"type\":\"none\"} in that turn.\nConfirmation step:\n‚Ä¢\tOnce you propose a timezone, end the message with:\nARA_PENDING: {\"type\":\"timezone_offer\",\"payload\":{\"timezone\":\"<IANA_timezone>\",\"timezone_label\":\"<human_label>\"}}\nActual update only happens if the user later replies YES, handled by the timezone update confirmation logic.\nDo NOT create reminders until timezone is known.\n\n________________________________________\nESCALATION (NO CONFIRMATION NEEDED)\nARA must automatically escalate to a human/admin when:\n‚Ä¢\tThe user expresses dissatisfaction, frustration, or disappointment.\n‚Ä¢\tThe issue cannot be resolved after two attempts.\n‚Ä¢\tThe issue requires human verification or judgement.\n‚Ä¢\tThe user explicitly asks for a human/admin.\n‚Ä¢\tThe user wants to contact Coach Joe\n\nWhen escalating:\n‚Ä¢\tBriefly apologise in the newest user‚Äôs message language.\n‚Ä¢\tInform the user that their issue has been escalated to a human/admin.\n‚Ä¢\tThen output:\nARA_PENDING: {\"type\":\"escalate\",\"payload\":{\"reason\":\"short description of issue\",\"summary\":\"1‚Äì2 sentence summary of what the user needs\",\"last_user_message\":\"<user's latest message>\",\"urgency\":\"normal\"}}\nDo NOT ask for confirmation to escalate.\nAlways tell the user that escalation has already been done.\n\n________________________________________\nNO SILENT ACTIONS\nARA must NOT create or update anything unless:\n‚Ä¢\tThe user clearly intends it,\n‚Ä¢\tARA explains what is happening, and\n‚Ä¢\tThe user agrees (if required by the flow).\n\n________________________________________\nMANDATORY ARA_ACTION & ARA_PENDING RULES\n\nIn EVERY reply, the structure at the end MUST be:\n\n1) One ARA_ACTION line\n2) One ARA_PENDING line (this is ALWAYS the final line)\n\nARA_ACTION RULES:\n‚Ä¢ You MUST always output exactly ONE ARA_ACTION line.\n‚Ä¢ If the current message does NOT change any name or language preferences:\n  ARA_ACTION: {\"type\":\"none\"}\n‚Ä¢ If the message sets or changes name/language, use:\n  ARA_ACTION: {\"type\":\"update_user_preferences\", ...}\n  following the rules in the USER PROFILE & LANGUAGE PREFERENCE UPDATES section.\n‚Ä¢ ARA_ACTION must appear on its own line, right BEFORE ARA_PENDING.\n‚Ä¢ Never explain ARA_ACTION to the user.\n\nARA_PENDING RULES:\n‚Ä¢ After the ARA_ACTION line, you MUST include exactly ONE ARA_PENDING line.\n‚Ä¢ If there is no pending action to propose:\n  ARA_PENDING: {\"type\":\"none\"}\n‚Ä¢ If ARA proposes an action, use one appropriate variant, for example:\n  - ARA_PENDING: {\"type\":\"timezone_offer\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"timezone_update\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"escalate\",\"payload\":{...}}\nRules:\n‚Ä¢ ARA_PENDING MUST be the LAST line in the message.\n‚Ä¢ It MUST start with ARA_PENDING:.\n‚Ä¢ It MUST contain valid JSON.\n‚Ä¢ Neither ARA_ACTION nor ARA_PENDING may be wrapped in code fences.\n‚Ä¢ They MUST never be explained to the user.\n\n\n",
              "role": "system"
            },
            {
              "content": "=Current message:\n{{$node[\"Get Latest Conversation1\"].json[\"user_message\"] || $node[\"Format Context with Memory1\"].json[\"ara_context\"].current_message.text || $json[\"user_message\"] || $json[\"message\"]}}\n\nARA context:\n{{JSON.stringify($node[\"Format Context with Memory1\"].json[\"ara_context\"])}}"
            }
          ]
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        -1712,
        2112
      ],
      "id": "de947931-22bf-4c65-90f4-6fa91732b942",
      "name": "Free User Onboarding"
    },
    {
      "parameters": {
        "tableId": "users",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "telegram_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "plan_type",
              "fieldValue": "free"
            },
            {
              "fieldId": "telegram_username",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.ProfileName }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -4624,
        2400
      ],
      "id": "44ce0ba0-12c9-47f2-a479-9146ca3719f4",
      "name": "Ensure User Exist",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $items(\"Get Latest Conversation\")[0].json.telegram_chat_id }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        336,
        3648
      ],
      "id": "b9995972-52a9-43b5-85a0-e2a82da594f3",
      "name": "Send Reply"
    },
    {
      "parameters": {
        "url": "https://jjeqmysluzsohwjpyvip.supabase.co/rest/v1/conversations",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ 'eq.' + $json.ara_context.user.id }}"
            },
            {
              "name": "order",
              "value": "created_at.desc"
            },
            {
              "name": "limit",
              "value": "1"
            },
            {
              "name": "select",
              "value": "*"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -912,
        3312
      ],
      "id": "5f03965f-db9f-4a7c-9983-2ddb8c14687c",
      "name": "Get Latest Conversation"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract Pending Action (PATCHED - structured output + YES/NO override)\n// Input: $json.output is an OBJECT from Structured Output Parser\n// Output: preserves the SAME keys downstream expects:\n// - assistant_response\n// - pending_action_type\n// - pending_action_payload\n//\n// Behavior change ONLY when:\n// - user replies YES/NO\n// - AND a latest pending delete offer exists from node \"Get Latest Pending Offer\"\n// Then we override the LLM output deterministically.\n\nfunction safeString(v) {\n  return (v === null || v === undefined) ? \"\" : String(v);\n}\n\nfunction norm(s = \"\") {\n  return safeString(s).toLowerCase().trim();\n}\n\n// Keep strict + small list to avoid false positives.\n// You can expand later once stable.\nfunction isYes(s) {\n  const t = norm(s);\n  return [\n    \"yes\", \"y\", \"ya\", \"yah\", \"yup\",\n    \"ok\", \"okay\", \"confirm\", \"setuju\", \"boleh\"\n  ].includes(t);\n}\n\nfunction isNo(s) {\n  const t = norm(s);\n  return [\n    \"no\", \"n\", \"tak\", \"tidak\", \"x\",\n    \"cancel\", \"batal\", \"jangan\", \"nope\"\n  ].includes(t);\n}\n\nfunction parseMaybeJson(v) {\n  if (typeof v === \"string\") {\n    const s = v.trim();\n    if (!s) return null;\n    try { return JSON.parse(s); } catch (e) { return v; }\n  }\n  return v;\n}\n\n// --------------------\n// 1) Base LLM output (unchanged behavior)\n// --------------------\nconst o = $json.output ?? {};\nlet assistant_response = safeString(o.assistant_response ?? \"\").trim();\nlet pending_action_type = o.pending_action_type ?? \"none\";\nlet pending_action_payload = o.pending_action_payload ?? null;\n\n// Normalize payload if it came as JSON string\npending_action_payload = parseMaybeJson(pending_action_payload);\n\n// --------------------\n// 2) Detect current user text (for YES/NO)\n// --------------------\nconst currentText =\n  $json.user_message ??\n  $json.message ??\n  $json.text ??\n  $json.current_message?.text ??\n  \"\";\n\n// --------------------\n// 3) Attempt to load latest pending offer (optional)\n//    If node doesn't exist / returns nothing ‚Üí no override\n// --------------------\nlet offer = null;\ntry {\n  const offerItems = $items(\"Get Latest Pending Offer\") || [];\n  offer = offerItems[0]?.json ?? null;\n} catch (e) {\n  offer = null;\n}\n\nconst offerType = offer?.pending_action_type ?? null;\nlet offerPayload = parseMaybeJson(offer?.pending_action_payload ?? null);\n\n// --------------------\n// 4) Deterministic override for YES/NO confirmations\n//    ONLY for delete offers\n// --------------------\nconst yes = isYes(currentText);\nconst no = isNo(currentText);\n\n// Treat these as delete offers that require confirmation\nconst DELETE_OFFER_TYPES = new Set([\n  \"reminder_delete_offer\",\n  \"reminder_delete_all\",\n  \"reminder_delete_all_offer\"\n]);\n\nif ((yes || no) && offerType && DELETE_OFFER_TYPES.has(offerType)) {\n  // IMPORTANT: prevent LLM from claiming success before DB action\n  if (no) {\n    pending_action_type = \"none\";\n    pending_action_payload = null;\n    assistant_response = \"Okay ‚Äî canceled. No reminders were deleted.\";\n  } else if (yes) {\n    // Delete ALL ‚Üí reuse reminder_delete with delete_scope=all_active\n    if (offerType === \"reminder_delete_all\" || offerType === \"reminder_delete_all_offer\") {\n      pending_action_type = \"reminder_delete\";\n      pending_action_payload = { delete_scope: \"all_active\" };\n      assistant_response = \"Okay ‚Äî deleting all your active reminders now.\";\n    } else {\n      // Single delete offer ‚Üí carry reminder_id from offer payload\n      const rid =\n        offerPayload?.reminder_id ??\n        offerPayload?.id ??\n        null;\n\n      if (rid) {\n        pending_action_type = \"reminder_delete\";\n        pending_action_payload = { reminder_id: rid };\n        assistant_response = \"Okay ‚Äî deleting that reminder now.\";\n      } else {\n        // Safety fallback: don't execute a random delete\n        pending_action_type = \"none\";\n        pending_action_payload = null;\n        assistant_response = \"I couldn‚Äôt find which reminder to delete. Please try again.\";\n      }\n    }\n  }\n}\n\n// --------------------\n// 5) Return in the exact same structure as before\n// --------------------\nreturn {\n  ...$json,\n  assistant_response,\n  pending_action_type,\n  pending_action_payload,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -336,
        3312
      ],
      "id": "f5fda099-8ad4-48f0-bde2-0b103483a026",
      "name": "Extract Pending Action"
    },
    {
      "parameters": {
        "jsCode": "// ROUTE CONFIRMED ACTIONS\n// -----------------------\n// INPUT EXPECTED (from Extract Pending Action + previous nodes):\n// - pending_action_type       (from THIS assistant reply's ARA_PENDING)\n// - pending_action_payload\n// - ara_context               (contains dialogue_state with pendingAction from DB)\n// - user_message              (latest user input)\n// - assistant_response        (for passing through to Send Reply)\n\nconst currentType = $json.pending_action_type || 'none';\nconst currentPayload = $json.pending_action_payload || null;\n\n// ara_context comes from \"Format Context with Memory\"\nconst araContext = $json.ara_context || {};\nconst ds = araContext.dialogue_state || {};\nconst pending = ds.pendingAction || null;\nconst isActiveResponse = !!ds.isActiveResponse;\nconst responseType = ds.activeResponseType || null;  // 'yes' | 'no' | null\n\nlet ARA_ACTION = {\n  type: 'none',\n  payload: null,\n};\n\n// CASE 1: User is replying YES/NO to an existing pendingAction\nif (\n  pending &&\n  pending.type &&\n  pending.type !== 'none' &&\n  isActiveResponse &&\n  (responseType === 'yes' || responseType === 'no')\n) {\n  if (responseType === 'yes') {\n    // Confirm the pending action (create/delete/update/...)\n    ARA_ACTION = {\n      type: pending.type,\n      payload: pending.payload || {},\n    };\n  } else if (responseType === 'no') {\n    // Cancel the pending action\n    ARA_ACTION = {\n      type: pending.type + '_cancel',\n      payload: pending.payload || {},\n    };\n  }\n} else {\n  // CASE 2: Immediate actions that do NOT require confirmation\n\n  // Example: escalate to human\n  if (currentType === 'escalate') {\n    ARA_ACTION = {\n      type: 'escalate',\n      payload: currentPayload || {},\n    };\n  }\n\n  // üîπ NEW: direct profile updates (no YES/NO roundtrip)\n  else if (currentType === 'user_update_profile') {\n    ARA_ACTION = {\n      type: 'user_update_profile',\n      payload: currentPayload || {},\n    };\n  }\n}\n\n// CASE 3: User profile updates (ARA_ACTION from main agent)\n// If the main agent outputs ARA_ACTION.update_user_preferences directly\n\n// ‚úÖ PATCH: rawOutput might be string (old) OR object (new)\nlet rawOutput = $json.output ?? $json.state ?? $json.text ?? $json.message ?? \"\";\n\n// If object, try common fields, else stringify\nif (typeof rawOutput === \"object\" && rawOutput !== null) {\n  if (typeof rawOutput.state === \"string\") rawOutput = rawOutput.state;\n  else if (typeof rawOutput.final_reply === \"string\") rawOutput = rawOutput.final_reply;\n  else rawOutput = JSON.stringify(rawOutput);\n}\n\nrawOutput = String(rawOutput);\n\n// Now safe to regex-match\nconst actionMatch = rawOutput.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\n\nif (actionMatch) {\n  try {\n    const parsedAction = JSON.parse(actionMatch[1]);\n\n    if (parsedAction.type === \"update_user_preferences\") {\n      // Build payload ONLY with non-null fields\n      const payload = {};\n\n      if (\n        typeof parsedAction.preferred_name === \"string\" &&\n        parsedAction.preferred_name.trim() !== \"\"\n      ) {\n        payload.preferred_name = parsedAction.preferred_name.trim();\n      }\n\n      if (\n        typeof parsedAction.preferred_language === \"string\" &&\n        parsedAction.preferred_language.trim() !== \"\"\n      ) {\n        payload.preferred_language = parsedAction.preferred_language.trim();\n      }\n\n      // Only overwrite ARA_ACTION if we have something real to update\n      if (Object.keys(payload).length > 0) {\n        ARA_ACTION = {\n          type: \"update_user_preferences\",\n          payload,\n        };\n      }\n      // else: no valid fields ‚Üí keep whatever ARA_ACTION was before\n    }\n  } catch (err) {\n    // ignore JSON parsing error, fall back to existing ARA_ACTION\n  }\n}\n\n\n// -----------------------------\n// SAFETY GUARDS (AILOOP PROTECT)\n// -----------------------------\n\n// 1) Whitelist allowed action types only\nconst allowedTypes = [\n  'none',\n  'reminder_create',\n  'reminder_delete',\n  'timezone_update',\n  'escalate',\n  'update_user_preferences',          // üîπ NEW\n\n  'reminder_create_cancel',\n  'reminder_delete_cancel',\n  'timezone_update_cancel',\n  'user_update_profile_cancel',   // optional future use\n];\n\nif (!allowedTypes.includes(ARA_ACTION.type)) {\n  ARA_ACTION = {\n    type: 'none',\n    payload: null,\n  };\n}\n\n// 2) Payload validation for specific actions\n\n// Reminder Create must have topic + suggested_time\nif (ARA_ACTION.type === 'reminder_create') {\n  const p = ARA_ACTION.payload || {};\n  const hasTopic =\n    typeof p.topic === 'string' && p.topic.trim().length > 0;\n  const hasTime =\n    typeof p.suggested_time === 'string' && p.suggested_time.trim().length > 0;\n\n  if (!hasTopic || !hasTime) {\n    // Invalid payload ‚Üí cancel action instead of firing broken data downstream\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Reminder Delete must have reminder_id\nif (ARA_ACTION.type === 'reminder_delete') {\n  const p = ARA_ACTION.payload || {};\n  const hasReminderId =\n    typeof p.reminder_id === 'string' && p.reminder_id.trim().length > 0;\n\n  if (!hasReminderId) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Timezone Update must have timezone + timezone_label\nif (ARA_ACTION.type === 'timezone_update') {\n  const p = ARA_ACTION.payload || {};\n  const hasTz =\n    typeof p.timezone === 'string' && p.timezone.trim().length > 0;\n  const hasLabel =\n    typeof p.timezone_label === 'string' && p.timezone_label.trim().length > 0;\n\n  if (!hasTz || !hasLabel) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Profile Update must have at least one field to update\nif (ARA_ACTION.type === 'user_update_profile') {\n  const p = ARA_ACTION.payload || {};\n  const updates = p.profile_updates || null;\n\n  const valid =\n    updates &&\n    typeof updates === 'object' &&\n    Object.keys(updates).length > 0;\n\n  if (!valid) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Preferences Update must have at least one field\nif (ARA_ACTION.type === 'update_user_preferences') {\n  const p = ARA_ACTION.payload || {};\n  const hasName = Object.prototype.hasOwnProperty.call(p, 'preferred_name');\n  const hasLang = Object.prototype.hasOwnProperty.call(p, 'preferred_language');\n\n  if (!hasName && !hasLang) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n\n\n// (We let 'escalate' and *_cancel pass even with minimal payload)\n\n// -----------------------------\n// Text back to user = assistant_response from previous node\n// -----------------------------\nconst final_reply = ($json.assistant_response || '').trim();\n\n// Safely pull the latest conversation row so we can attach ids\nconst latestItems = $items('Get Latest Conversation');\nconst latest = latestItems.length ? latestItems[0].json : {};\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Ensure these four are present from Get Latest Conversation\n  id: latest.id ?? $json.id,\n  user_id: latest.user_id ?? $json.user_id,\n  telegram_chat_id: latest.telegram_chat_id ?? $json.telegram_chat_id,\n  message_id: latest.message_id ?? $json.message_id,\n\n  ARA_ACTION,\n  final_reply,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        2448
      ],
      "id": "9720b2ab-dd14-4426-b1d2-071161081fb9",
      "name": "Route Confirmed Actions"
    },
    {
      "parameters": {
        "tableId": "reminders",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "reminder_text",
              "fieldValue": "={{ $json.reminder_text }}"
            },
            {
              "fieldId": "reminder_time",
              "fieldValue": "={{ $json.reminder_time }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "{{ $now }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1136,
        1488
      ],
      "id": "957defb7-e890-4352-8fb9-807a156fc8e3",
      "name": "Create Reminder"
    },
    {
      "parameters": {
        "jsCode": "// GET RELEVANT MEMORIES\n// This node reads all rows from \"Get User Memories\",\n// scores them by importance + recency, and returns\n// only the top N memories to the next node.\n\n// Make sure this node is set to:\n// - Mode: \"Run Once for All Items\"\n// - Language: JavaScript\n\n// 1) Safely get all items from \"Get User Memories\"\nlet memoryItems;\ntry {\n  memoryItems = $items('Get User Memories', 0, 0);\n} catch (e) {\n  // If node name is wrong or no items, fail gracefully\n  return [];\n}\n\n// If no memories, just return an empty list\nif (!Array.isArray(memoryItems) || memoryItems.length === 0) {\n  return [];\n}\n\nconst now = new Date();\n\n// 2) Convert & score each memory\nconst scoredMemories = memoryItems\n  .map(item => item.json)\n  .map(m => {\n    // Importance score (0‚Äì1, default 0.5)\n    const importance =\n      typeof m.importance_score === 'number'\n        ? m.importance_score\n        : 0.5;\n\n    // Recency score from temporal_context (if parseable as date)\n    let recencyScore = 0;\n    if (m.temporal_context) {\n      const parsed = Date.parse(m.temporal_context);\n      if (!isNaN(parsed)) {\n        const ageMs = now - new Date(parsed);\n        const ageDays = ageMs / (1000 * 60 * 60 * 24);\n        // Newer memories = higher score (ageDays small)\n        // Cap to avoid crazy values\n        const cappedAge = Math.min(Math.max(ageDays, -7), 365);\n        recencyScore = -cappedAge; // smaller age => higher score\n      }\n    }\n\n    // Memory type boost (preferences & relationships are more ‚Äúcore‚Äù)\n    const typeBoost =\n      m.memory_type === 'preference' || m.memory_type === 'relationship'\n        ? 1\n        : 0;\n\n    // Topic boost (reminders, customers, etc)\n    let topicBoost = 0;\n    try {\n      if (typeof m.entities === 'string') {\n        // entities is JSON string in your table\n        const ent = JSON.parse(m.entities);\n        const topics = Array.isArray(ent.topics) ? ent.topics.join(' ').toLowerCase() : '';\n        if (topics.includes('reminder')) topicBoost += 0.5;\n        if (topics.includes('customer')) topicBoost += 0.3;\n      }\n    } catch (e) {\n      // Ignore parsing errors, keep topicBoost = 0\n    }\n\n    // Final score (tweak weights as you like)\n    const score =\n      importance * 2 +      // importance is strong signal\n      typeBoost +           // preferences/relationships are sticky\n      topicBoost +          // domain-specific boost\n      recencyScore * 0.02;  // mild recency influence\n\n    return {\n      ...m,\n      _score: score,\n    };\n  });\n\n// 3) Sort by score (desc), then by created_at (desc)\nscoredMemories.sort((a, b) => {\n  if (b._score !== a._score) return b._score - a._score;\n  const ad = new Date(a.created_at || 0);\n  const bd = new Date(b.created_at || 0);\n  return bd - ad;\n});\n\n// 4) Limit how many memories to send forward\nconst MAX_MEMORIES = 20;\nconst selected = scoredMemories.slice(0, MAX_MEMORIES);\n\n// 5) Return in n8n format\nreturn selected.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2608,
        3504
      ],
      "id": "3b6a7368-2ee3-4209-9072-d8c457f107f5",
      "name": "Get Relevant Memories"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ara_brain_rules",
        "limit": 100,
        "filters": {
          "conditions": [
            {
              "keyName": "is_active",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2160,
        3312
      ],
      "id": "4f1563fb-7bca-4e20-8bd0-47b826646672",
      "name": "Get ARA Brain",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Format ARA brain rows into a single text block (PRIORITY-SORTED)\n\n// Get all rows from previous node\nconst items = $input.all();\nlet rows = items.map(i => i.json).filter(r => r);\n\n// Keep only active rules (default true if missing)\nrows = rows.filter(r => r.is_active !== false);\n\n// Sort order:\n// 1) category (A‚ÜíZ)\n// 2) priority ASC (1 is strongest)\n// 3) subcategory (A‚ÜíZ)\n// 4) title (A‚ÜíZ)\nrows.sort((a, b) => {\n  const ca = (a.category || 'General').toString().toLowerCase();\n  const cb = (b.category || 'General').toString().toLowerCase();\n  if (ca !== cb) return ca.localeCompare(cb);\n\n  const pa = Number.isFinite(+a.priority) ? +a.priority : 1000;\n  const pb = Number.isFinite(+b.priority) ? +b.priority : 1000;\n  if (pa !== pb) return pa - pb;\n\n  const sa = (a.subcategory || '').toString().toLowerCase();\n  const sb = (b.subcategory || '').toString().toLowerCase();\n  if (sa !== sb) return sa.localeCompare(sb);\n\n  const ta = (a.title || '').toString().toLowerCase();\n  const tb = (b.title || '').toString().toLowerCase();\n  return ta.localeCompare(tb);\n});\n\n// Group by category (in sorted order)\nconst byCategory = new Map();\n\nfor (const row of rows) {\n  const category = (row.category || 'General').toString();\n  const sub = (row.subcategory || '').toString().trim();\n  const title = (row.title || '').toString().trim();\n  const content = (row.content || '').toString().trim();\n\n  if (!content) continue;\n\n  if (!byCategory.has(category)) byCategory.set(category, []);\n\n  // Label: keep compact but informative for debugging\n  // Examples:\n  // (capability_no_false_promises ‚Äî Never promise actions...) <content>\n  // or just (capability_no_false_promises) <content>\n  let label = '';\n  if (sub && title) label = `(${sub} ‚Äî ${title})`;\n  else if (sub) label = `(${sub})`;\n  else if (title) label = `(${title})`;\n\n  byCategory.get(category).push(`- ${label ? label + ' ' : ''}${content}`);\n}\n\n// Build the final brain text\nlet brainText = '';\n\nfor (const [category, lines] of byCategory.entries()) {\n  brainText += `\\n\\n[${category.toUpperCase()}]\\n` + lines.join('\\n');\n}\n\nbrainText = brainText.trim();\n\n// Return a single item with brain_text (same output shape as before)\nreturn [\n  {\n    json: {\n      brain_text: brainText,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1936,
        3312
      ],
      "id": "bdf284b2-ad8f-4ceb-9786-b22b55e71c91",
      "name": "Format Brain"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.home_timezone }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "e7b487c6-4190-43b3-a402-4d93f58f1f90"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "No home time"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a14c596f-8821-4f43-8884-fc07dd2f95b4",
                    "leftValue": "",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "default"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -4176,
        2400
      ],
      "id": "33167ce0-5537-4e57-83f4-d0e4dcc4c1e7",
      "name": "Check Time Zone"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3952,
        2112
      ],
      "id": "7b6aebbd-f719-4b1b-a5fc-ca1ee108b195",
      "name": "Get Previous Conversation1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Get all input items\nconst items = $input.all();\n\n// Sort items by created_at in descending order (most recent first)\nitems.sort((a, b) => new Date(b.json.created_at) - new Date(a.json.created_at));\n\n// Take the first 1 item (latest 1)\nconst latestOne = items.slice(0, 1);\n\nreturn latestOne;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3728,
        2112
      ],
      "id": "c19c56dd-0bb0-4220-bf81-8e4e06833c7b",
      "name": "Sort1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ara_brain_rules",
        "limit": 100,
        "filters": {
          "conditions": [
            {
              "keyName": "is_active",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2608,
        2112
      ],
      "id": "48b01e0d-b6ba-4662-bd3f-542ebb1f5d25",
      "name": "Get ARA Brain1",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Format ARA brain rows into a single text block\n\n// Get all rows from previous node\nconst items = $input.all();\nconst rows = items.map(i => i.json);\n\n// Group by category\nconst byCategory = {};\n\nfor (const row of rows) {\n  const category = row.category || 'General';\n  const sub = row.subcategory || '';\n  const content = (row.content || '').trim();\n\n  if (!content) continue;\n\n  if (!byCategory[category]) {\n    byCategory[category] = [];\n  }\n\n  const label = sub ? `(${sub})` : '';\n  byCategory[category].push(`- ${label ? label + ' ' : ''}${content}`);\n}\n\n// Build the final brain text\nlet brainText = '';\n\nfor (const [category, lines] of Object.entries(byCategory)) {\n  brainText += `\\n\\n[${category.toUpperCase()}]\\n` + lines.join('\\n');\n}\n\nbrainText = brainText.trim();\n\n// Return a single item with brain_text\nreturn [\n  {\n    json: {\n      brain_text: brainText,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2384,
        2112
      ],
      "id": "0d6782cb-59fd-4222-8fc0-e2b19bc9915d",
      "name": "Format Brain1"
    },
    {
      "parameters": {
        "jsCode": "// FORMAT CONTEXT WITH MEMORY\n// This node prepares \"ara_context\" for ARA Main Agent.\n\n// ============= STEP 1: ARA BRAIN =============\nlet araBrain = '';\ntry {\n  const brainNode = $('Format Brain1').first();\n  if (brainNode && brainNode.json && brainNode.json.brain_text) {\n    araBrain = brainNode.json.brain_text;\n  }\n} catch (e) {\n  console.log('No ARA brain available yet');\n}\n\n// ============= STEP 1.5: LOAD CONVERSATIONS =============\nconst convItems = $('Wait for Memory & Session1').all() || [];\n\n// Flatten and sort oldest ‚Üí newest\nlet conversations = convItems\n  .map(i => i.json || i) // adjust if your data is under i.json\n  .filter(c => c && c.created_at)\n  .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));\n\nconst MAX_DETAILED = 12;\nconst detailedConversations = conversations.slice(-MAX_DETAILED);\nconst olderConversations = conversations.slice(\n  0,\n  Math.max(0, conversations.length - MAX_DETAILED)\n);\n\n// Build compact summaries for older convos\nconst olderSummaries = olderConversations.map(c => {\n  const userMsg = c.user_message || '';\n  const assistantMsg = c.assistant_response || '';\n  const summaryField = c.session_summary || c.context_summary || null;\n\n  return {\n    id: c.id,\n    session_id: c.session_id || null,\n    created_at: c.created_at,\n    user_message_preview: userMsg.slice(0, 120),\n    assistant_response_summary: summaryField || assistantMsg.slice(0, 160)\n  };\n});\n\n// IMPORTANT: latest conversation row (could be user OR assistant)\nconst lastConversation =\n  conversations.length > 0 ? conversations[conversations.length - 1] : null;\n\n// IMPORTANT: latest assistant message with non-empty response\nconst lastAssistant =\n  [...conversations]\n    .reverse()\n    .find(c => (c.assistant_response || '').trim() !== '') || null;\n\n// ============= STEP 2: LOAD USER + MEMORIES =============\nlet userData = {};\ntry {\n  const userNode = $('Get User1').first().json; // adjust node name if needed\n  userData = userNode || {};\n} catch (e) {\n  userData = {};\n}\n\nlet userMemories = [];\ntry {\n  const memNode = $('Get User Memories1').first().json;\n  userMemories = memNode.data || memNode.memories || [];\n} catch (e) {\n  userMemories = [];\n}\n\nconst importantMemories = userMemories.filter(m => {\n  const score = typeof m.importance_score === 'number' ? m.importance_score : 1;\n  return score >= 0.7;\n});\n\n// ============= STEP 3: UNDERSTAND CURRENT MESSAGE =============\nconst current = $input.first()?.json ?? $json ?? {};\nconst currentText =\n  current.user_message ||\n  current.message ||\n  current.text ||\n  '';\nconst currentLower = (currentText || '').trim().toLowerCase();\n\n\n// ============= STEP 4: PENDING ACTION & YES/NO DETECTION =============\n\n// Helper: simple yes/no detection for short replies\nfunction isShortYesNo(text) {\n  if (!text) return null;\n  const t = text.trim().toLowerCase();\n  if (t.length === 0 || t.length > 40) return null;\n\n  const YES = [\n    'yes','ya','yaaa','yup','ok','okay','okey','ok lah','okla','boleh',\n    'boleh je','proceed','confirm','set kan','buat','buat je','jom','ye'\n  ];\n  const NO = [\n    'no','tak','tak nak','tidak','jangan','nope','later','nanti',\n    'bukan sekarang','skip','tak payah'\n  ];\n\n  if (YES.includes(t)) return 'yes';\n  if (NO.includes(t)) return 'no';\n  return null;\n}\n\n// Helper: time guard for pending actions\nfunction isWithinHours(dateStr, hours) {\n  if (!dateStr) return false;\n  const then = new Date(dateStr).getTime();\n  const now = Date.now();\n  const diffH = (now - then) / (1000 * 60 * 60);\n  return diffH <= hours;\n}\n\nlet isActiveResponse = false;\nlet activeResponseType = null;   // 'yes' | 'no'\nlet questionType = 'general';\nlet offerContext = null;\nlet pendingAction = null;\n\n// ---- Build pendingAction from DB fields, with ARA_PENDING as fallback ----\nlet lastAssistantText = lastAssistant ? (lastAssistant.assistant_response || '') : '';\n\nif (lastAssistant) {\n  // 1) Prefer structured fields from the conversations table\n  if (\n    lastAssistant.pending_action_type &&\n    lastAssistant.pending_action_type !== 'none'\n  ) {\n    pendingAction = {\n      type: lastAssistant.pending_action_type,\n      payload: lastAssistant.pending_action_payload || null,\n      resolved: !!lastAssistant.pending_action_resolved,\n      created_at: lastAssistant.created_at,\n    };\n  } else if (lastAssistantText) {\n    // 2) Backwards-compatible support for old ARA_PENDING footer\n    const match = lastAssistantText.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})\\s*$/);\n    if (match) {\n      try {\n        const pa = JSON.parse(match[1]);\n        if (pa.type && pa.type !== 'none') {\n          pendingAction = {\n            type: pa.type,\n            payload: pa.payload || null,\n            resolved: false,\n            created_at: lastAssistant.created_at,\n          };\n        }\n      } catch (e) {\n        // ignore parse errors\n      }\n    }\n  }\n}\n\n// YES/NO on current message\nconst shortYesNo = isShortYesNo(currentText);\n\n\n// 1) If we have a pending action and user sends short yes/no recently\nif (\n  pendingAction &&\n  pendingAction.type &&\n  pendingAction.type !== 'none' &&\n  isWithinHours(pendingAction.created_at, 48) &&\n  shortYesNo\n) {\n  isActiveResponse = true;\n  activeResponseType = shortYesNo;\n  questionType = 'offer';\n  offerContext = pendingAction.type;\n}\n\n// 2) Fallback: classify last assistant message question type (for general yes/no replies)\nif (!isActiveResponse && lastAssistantText) {\n  const lastText = lastAssistantText.toLowerCase();\n\n  const hasQuestionMark = lastText.includes('?');\n  const hasOfferPattern = /would you like|nak tak|mahu tak|do you want|shall i|should i|may i|can i help|if you‚Äôd like|kalau nak/i.test(lastText);\n  const hasClarificationPattern = /could you clarify|apa yang dimaksud|what do you mean|which one do you mean|yang mana satu/i.test(lastText);\n  const hasConfirmationPattern = /is this correct|is that right|betul tak|setuju tak|confirm/i.test(lastText);\n  const hasChoicePattern = /\\bor\\b|atau\\b/i.test(lastText);\n\n  if (hasOfferPattern) questionType = 'offer';\n  else if (hasClarificationPattern) questionType = 'clarification';\n  else if (hasConfirmationPattern) questionType = 'confirmation';\n  else if (hasChoicePattern) questionType = 'choice';\n  else if (hasQuestionMark) questionType = 'general';\n\n  const yn = shortYesNo;\n  if (yn && (hasOfferPattern || hasConfirmationPattern || hasChoicePattern)) {\n    isActiveResponse = true;\n    activeResponseType = yn;\n\n    if (hasOfferPattern) offerContext = 'offer';\n    else if (hasConfirmationPattern) offerContext = 'confirmation';\n    else if (hasChoicePattern) offerContext = 'choice';\n  }\n}\n\n// ============= STEP 5: BUILD ARA CONTEXT =============\nconst araContext = {\n  user: {\n  id: userData.id || null,\n  name: userData.name || userData.full_name || null,\n  phone: userData.phone || userData.telegram_id || null,\n  features_enabled: userData.features_enabled || null,\n\n  // Main timezone ARA should use\n  timezone:\n    userData.current_timezone ||\n    userData.home_timezone ||\n    userData.timezone ||\n    'Asia/Kuala_Lumpur',\n\n  // Extra fields so the main agent sees both explicitly\n  home_timezone: userData.home_timezone || null,\n  current_timezone: userData.current_timezone || null,\n},\n\n  current_message: {\n    text: currentText,\n    language_hint: null\n  },\n  history: {\n    detailed: detailedConversations.map(c => ({\n      created_at: c.created_at,\n      role: c.role || null,\n      user_message: c.user_message || '',\n      assistant_response: c.assistant_response || '',\n      session_id: c.session_id || null\n    })),\n    older_summaries: olderSummaries\n  },\n  memories: {\n    important: importantMemories,\n    all: userMemories\n  },\n  last_assistant_message: lastAssistant\n    ? {\n        created_at: lastAssistant.created_at,\n        text: lastAssistant.assistant_response || ''\n      }\n    : null,\n  dialogue_state: {\n    isActiveResponse,\n    activeResponseType,\n    questionType,\n    offerContext,\n    pendingAction\n  }\n};\n\nreturn [\n  {\n    json: {\n      ara_context: araContext,\n      // keep original fields\n      ...current\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2160,
        2112
      ],
      "id": "f39177cb-20ce-43ef-a699-a8521741345d",
      "name": "Format Context with Memory1"
    },
    {
      "parameters": {
        "url": "https://jjeqmysluzsohwjpyvip.supabase.co/rest/v1/conversations",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ 'eq.' + $json.ara_context.user.id }}"
            },
            {
              "name": "order",
              "value": "created_at.desc"
            },
            {
              "name": "limit",
              "value": "1"
            },
            {
              "name": "select",
              "value": "*"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1936,
        2112
      ],
      "id": "fbd41104-072d-4293-bae1-3641c98c8bb0",
      "name": "Get Latest Conversation1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9ea260fe-5f67-4c13-85db-a8aff7ab65be",
                    "leftValue": "={{ (Date.now() - new Date($json.created_at).getTime()) / 60000 }}",
                    "rightValue": 30,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Within 30 Mins"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.session_id }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "13a1d046-89ee-4896-b133-7081657d0eec"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Never talked"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3504,
        2000
      ],
      "id": "4161a42c-6cb4-4a87-afb8-77d250fe4108",
      "name": "Session Manager1"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $item(0).$node[\"Get User1\"].json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ Date.now() + '_' + Math.floor(Math.random() * 1000000) }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3280,
        2736
      ],
      "id": "9b314731-2a51-4bd5-852e-a7b297f774f8",
      "name": "Create New Session1",
      "alwaysOutputData": true,
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get User1').item.json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}\n"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}\n"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3280,
        1920
      ],
      "id": "b0311e72-283f-4ba7-9e68-7f543d1c44b0",
      "name": "Continue Session1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "limit": 100,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3056,
        2016
      ],
      "id": "5b7c5419-1fd9-4603-b785-287876923c00",
      "name": "Fetch Session History2",
      "alwaysOutputData": true,
      "notesInFlow": false
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ai_memories",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Get User1').item.json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3280,
        2928
      ],
      "id": "681f4bb0-a047-4664-ab64-c0b049efcb71",
      "name": "Get User Memories1",
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2832,
        2112
      ],
      "id": "43799c50-8c42-4d23-a736-b652d5b3a14c",
      "name": "Wait for Memory & Session1"
    },
    {
      "parameters": {
        "jsCode": "// GET RELEVANT MEMORIES\n// This node reads all rows from \"Get User Memories\",\n// scores them by importance + recency, and returns\n// only the top N memories to the next node.\n\n// Make sure this node is set to:\n// - Mode: \"Run Once for All Items\"\n// - Language: JavaScript\n\n// 1) Safely get all items from \"Get User Memories\"\nlet memoryItems;\ntry {\n  memoryItems = $items('Get User Memories1', 0, 0);\n} catch (e) {\n  // If node name is wrong or no items, fail gracefully\n  return [];\n}\n\n// If no memories, just return an empty list\nif (!Array.isArray(memoryItems) || memoryItems.length === 0) {\n  return [];\n}\n\nconst now = new Date();\n\n// 2) Convert & score each memory\nconst scoredMemories = memoryItems\n  .map(item => item.json)\n  .map(m => {\n    // Importance score (0‚Äì1, default 0.5)\n    const importance =\n      typeof m.importance_score === 'number'\n        ? m.importance_score\n        : 0.5;\n\n    // Recency score from temporal_context (if parseable as date)\n    let recencyScore = 0;\n    if (m.temporal_context) {\n      const parsed = Date.parse(m.temporal_context);\n      if (!isNaN(parsed)) {\n        const ageMs = now - new Date(parsed);\n        const ageDays = ageMs / (1000 * 60 * 60 * 24);\n        // Newer memories = higher score (ageDays small)\n        // Cap to avoid crazy values\n        const cappedAge = Math.min(Math.max(ageDays, -7), 365);\n        recencyScore = -cappedAge; // smaller age => higher score\n      }\n    }\n\n    // Memory type boost (preferences & relationships are more ‚Äúcore‚Äù)\n    const typeBoost =\n      m.memory_type === 'preference' || m.memory_type === 'relationship'\n        ? 1\n        : 0;\n\n    // Topic boost (reminders, customers, etc)\n    let topicBoost = 0;\n    try {\n      if (typeof m.entities === 'string') {\n        // entities is JSON string in your table\n        const ent = JSON.parse(m.entities);\n        const topics = Array.isArray(ent.topics) ? ent.topics.join(' ').toLowerCase() : '';\n        if (topics.includes('reminder')) topicBoost += 0.5;\n        if (topics.includes('customer')) topicBoost += 0.3;\n      }\n    } catch (e) {\n      // Ignore parsing errors, keep topicBoost = 0\n    }\n\n    // Final score (tweak weights as you like)\n    const score =\n      importance * 2 +      // importance is strong signal\n      typeBoost +           // preferences/relationships are sticky\n      topicBoost +          // domain-specific boost\n      recencyScore * 0.02;  // mild recency influence\n\n    return {\n      ...m,\n      _score: score,\n    };\n  });\n\n// 3) Sort by score (desc), then by created_at (desc)\nscoredMemories.sort((a, b) => {\n  if (b._score !== a._score) return b._score - a._score;\n  const ad = new Date(a.created_at || 0);\n  const bd = new Date(b.created_at || 0);\n  return bd - ad;\n});\n\n// 4) Limit how many memories to send forward\nconst MAX_MEMORIES = 20;\nconst selected = scoredMemories.slice(0, MAX_MEMORIES);\n\n// 5) Return in n8n format\nreturn selected.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3056,
        2928
      ],
      "id": "0bda4f1a-3db5-46e2-a9d0-c41431cad6b2",
      "name": "Get Relevant Memories1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -624,
        1408
      ],
      "id": "aa860269-49a2-4e67-a427-bba17ab15ed4",
      "name": "OpenAI Model1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify({\n  latest_user_message: $('Get Latest Conversation1').item.json.user_message || $json.Body || $json.body || '',\n  assistant_response: $('Send Reply1').item.json.body || '',\n  user_context: $('Format Context with Memory1').item.json.ara_context.user || {}\n}) }}",
        "options": {
          "systemMessage": "You are ARA‚Äôs Memory Extraction Agent.\n\nYour ONLY job is to decide what is worth saving into long-term memory for this user, based on the LATEST exchange.\n\nINPUT FORMAT\n\nYou will receive a JSON object with:\n\nlatest_user_message: the most recent WhatsApp message from the user\n\nassistant_response: the reply that ARA just sent to the user\n\nuser_context: basic info about the user (id, phone, timezone, etc.)\n\nCRITICAL CONSTRAINTS\n\nYou MUST ONLY consider:\n\nlatest_user_message\n\nassistant_response\n\nYou MUST NOT scan or ‚Äúimagine‚Äù earlier history, even if you see anything that looks like history or summaries in the input.\n\nTreat this as a single turn: one user message + one assistant reply.\n\nIf you are not clearly sure a fact will help in future conversations, DO NOT save it.\n\nIf there is nothing worth remembering, return an empty JSON array: [].\n\nGOAL\n\nDecide whether this turn contains anything that is worth remembering LATER to help this user:\n\npersonal facts\n\nstable preferences\n\nrelationships\n\nongoing tasks or recurring patterns\n\nbusiness / life context\n\nENTITY & WORLD-KNOWLEDGE SAFETY RULES (VERY IMPORTANT)\n\nThese rules are to prevent wrong ‚Äúpeople‚Äù and messy memories.\n\nPlaces are NEVER people\n\nTreat these as places, not persons, for example:\n\nCountries: Malaysia, Singapore, Indonesia, Thailand, Vietnam, UK, USA, Saudi Arabia, etc.\n\nMalaysian cities / regions: Kuala Lumpur, KL, Selangor, Penang, Johor Bahru, Ipoh, Melaka, Sabah, Sarawak, Kuching, Kota Kinabalu, etc.\n\nHoly places: Makkah/Mecca, Madinah/Medina, Kaabah, Masjidil Haram, Masjid Nabawi, etc.\n\nThey must NOT appear inside entities.people. They may appear in entities.topics or only inside memory_value.\n\nOrganisations, banks, and programmes are NEVER people\n\nAnything that looks like a company, bank, agency, or programme must NOT go into entities.people. Examples:\n\nNames containing: ‚ÄúBank‚Äù, ‚ÄúBerhad‚Äù, ‚ÄúBhd‚Äù, ‚ÄúSdn Bhd‚Äù, ‚ÄúCorp‚Äù, ‚ÄúCompany‚Äù, ‚ÄúUniversity‚Äù, ‚ÄúCollege‚Äù.\n\nKnown Malaysian orgs: MARA, AIM (Amanah Ikhtiar Malaysia), MRANTI, SME Bank, Maybank, CIMB, Bank Rakyat, Petronas, Tenaga Nasional, etc.\n\nPut them in entities.topics if relevant, or leave them only in memory_value.\n\nApps and tools are NEVER people\n\nWhatsApp, Telegram, Facebook, Instagram, TikTok, Google, YouTube, Shopee, Lazada, Grab, Foodpanda, ARA, etc. are tools/apps, not persons.\n\nThey must NOT be inside entities.people.\n\nGeneric roles are allowed but should be simple\n\nPhrases like ‚Äúmy tailor‚Äù, ‚Äúmy designer‚Äù, ‚Äúmy supplier‚Äù, ‚Äúmy mentor‚Äù can appear in memory_value.\nIn entities.people you may use a simple label like \"tailor\" or \"mentor\" if it clearly helps; never invent a personal name that wasn‚Äôt given.\n\nWhen in doubt about person vs place/org ‚Üí DO NOT mark as a person\n\nIf you‚Äôre not clearly sure something is a human name, leave it out of entities.people.\nIt is better to have fewer people than wrong people.\n\nWHAT TO EXTRACT\n\nExtract only information that:\n\nwill still matter in future conversations (hours, days, weeks later), AND\n\nhelps ARA be more helpful or personal.\n\nFocus on:\n\nPERSONAL BACKGROUND\n\nEducation, origin, profession, roles, life events.\n\nExample: ‚ÄúI‚Äôm from Kedah‚Äù, ‚ÄúI run a printing business‚Äù, ‚ÄúI‚Äôm a teacher‚Äù, ‚ÄúI just moved to London.‚Äù\n\nPREFERENCES & OPINIONS\n\nColors, products, styles, routines, habits, food, communication style, language preference, tools they like to use.\n\nExample: ‚ÄúCustomer Ali wants the color green‚Äù, ‚ÄúI prefer English‚Äù, ‚ÄúI like voice notes‚Äù, ‚ÄúI hate long paragraphs‚Äù.\n\nRELATIONSHIPS & ROLES\n\nWho is who: spouse, children, business partners, customers, suppliers, mentors, staff, etc.\n\nExample: ‚ÄúAishah is my wife‚Äù, ‚ÄúAli is my customer‚Äù, ‚ÄúSiti is the event planner for my wedding‚Äù.\n\nTASK PATTERNS & ONGOING CONTEXT\n\nRecurring routines or ongoing projects, not one-off noise.\n\nExample:\n\n‚ÄúEvery Monday I have team meeting at 9am.‚Äù\n\n‚ÄúI‚Äôm working on launching my new cafe in March.‚Äù\n\n‚ÄúI‚Äôm using ARA mainly to manage my business reminders.‚Äù\n\nIMPORTANT REMINDER-LIKE FACTS\n\nOnly if they reveal something stable or recurring.\n\nExample:\n\n‚ÄúI always call my mum every Sunday night.‚Äù\n\n‚ÄúMy rental is due on the 25th every month.‚Äù\n\nOne-off reminders that are already fully handled by the reminder system usually do NOT need to be saved as long-term memory.\n\nWHAT NOT TO SAVE\n\nDO NOT save:\n\nGreetings or filler:\n\n‚ÄúHi‚Äù, ‚ÄúHello‚Äù, ‚ÄúOK‚Äù, ‚ÄúThanks‚Äù, ‚ÄúBetul‚Äù, ‚ÄúDone‚Äù, ‚ÄúYes‚Äù, ‚ÄúNo‚Äù, etc.\n\nPure emotion with no concrete fact:\n\n‚ÄúYou are slow‚Äù, ‚ÄúI‚Äôm angry‚Äù, ‚ÄúService not good‚Äù, ‚ÄúI‚Äôm stressed‚Äù.\n\nTemporary confusion:\n\n‚ÄúI don‚Äôt know‚Äù, ‚ÄúWhat?‚Äù, ‚ÄúWhere is my reminder?‚Äù, ‚ÄúWhy you so slow?‚Äù\n\nTechnical/system-like text, IDs, or internal ARA messages.\n\nDetails that only matter for a single reminder and add no long-term value.\n\nShort, vague, or ambiguous statements that you cannot interpret safely.\n\nAnything that is not clearly about:\n\nthe user,\n\ntheir contacts/relationships,\n\ntheir stable preferences,\n\ntheir ongoing business or life context.\n\nIf unsure, prefer to skip the memory.\n\nMEMORY TYPES\n\nUse these types:\n\n\"preference\" ‚Üí stable likes/dislikes, style, language, choices.\n\n\"relationship\" ‚Üí who people are and how they are connected to the user.\n\n\"context\" ‚Üí facts about their situation, work, business, or long-term goals.\n\n\"interaction\" ‚Üí specific actions, decisions, or promises that may matter later (e.g. ‚Äúuser agreed to try weekly planning with ARA‚Äù).\n\nIf you cannot decide a suitable type with reasonable confidence, DO NOT create the memory.\n\nIMPORTANCE & LIMITS\n\nimportance_score must be between 0.7 and 1.0.\n\nUse 0.9‚Äì1.0 only for very important, identity-level facts (family, core business, strong preferences).\n\nUse 0.7‚Äì0.8 for useful but lighter context.\n\nIf a fact feels minor or very temporary, do NOT save it at all.\n\nTry not to create more than 3 memories per turn. Pick the most useful ones.\n\nSCHEMA\n\nReturn a JSON array. Each memory object MUST have:\n\nmemory_type: \"preference\" | \"relationship\" | \"context\" | \"interaction\"\n\nmemory_key: a short snake_case key you invent (e.g. \"ali_color_preference\")\n\nmemory_value: the full fact in natural language\n\nimportance_score: 0.7‚Äì1.0\n\nentities:\n\n\"people\": [\"list\", \"of\", \"names\"] (real people or clear roles only)\n\n\"topics\": [\"keywords\", \"like\", \"reminder\", \"color\", \"meeting\"]\n\ntemporal_context: a simple string like \"today\" or an ISO date if explicitly mentioned.\n\nRESOLVING PRONOUNS\n\nIf the user says ‚Äúshe‚Äù, ‚Äúhe‚Äù, ‚Äúthat color‚Äù, etc., use ONLY the information in latest_user_message + assistant_response to interpret it.\n\nIf you cannot resolve it clearly to a specific person or thing, DO NOT save the memory.\n\nDUPLICATES\n\nIf the user repeats something you already know (for example: ‚ÄúAli likes green‚Äù) but adds no new detail, you may:\n\neither skip it, OR\n\ninclude it again with the same memory_value (the system will de-duplicate later).\n\nDO NOT assume something is updated unless the message clearly says the old info has changed.\n\nOUTPUT FORMAT\n\nOutput MUST be a valid JSON array.\n\nDO NOT wrap the JSON in ``` or any markdown.\n\nDO NOT include explanations, comments, or extra text.\n\nIf there is nothing useful to save, return exactly: []."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        -688,
        1184
      ],
      "id": "d2ddeea0-8278-402a-b306-345662706ba0",
      "name": "Extract Memories1",
      "executeOnce": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{ $('Format Context with Memory1').item.json.is_continuing_session }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              },
              "id": "74ef4d44-2a94-431f-a49c-b470fc2a0996"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -336,
        1680
      ],
      "id": "67975104-743a-451d-bba8-2b2481340a4e",
      "name": "Session Ended?1"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Memories v2 - simpler, cleaner, per-turn\n// Input: array of validated memory objects (from Validate Memories)\n// Output: array of rows ready for ai_memories table\n\nconst input = $input.all().map(i => i.json);\nlet memories = input;\n\n// If someone wired it differently and we got a single array\nif (input.length === 1 && Array.isArray(input[0])) {\n  memories = input[0];\n}\n\nif (!memories || memories.length === 0) {\n  console.log('Prepare Memories: no memories to process');\n  return [];\n}\n\n// ===== Get user context =====\nlet userId = null;\ntry {\n  const userNode = $('Get User1').first();\n  if (userNode && userNode.json && userNode.json.id) {\n    userId = userNode.json.id;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get user ID', e);\n}\n\nif (!userId) {\n  console.log('Prepare Memories: missing user_id, aborting');\n  return [];\n}\n\n// ===== Get existing memories for this user =====\nlet existing = [];\ntry {\n  const rows = $('Get User Memories1').all() || [];\n  existing = rows\n    .filter(r => r.json && r.json.memory_value)\n    .map(r => r.json);\n} catch (e) {\n  console.log('Prepare Memories: could not get existing memories', e);\n}\n\n// Build quick lookup structures\nconst existingByKey = {};\nconst existingByValue = new Map();\n\nexisting.forEach(mem => {\n  const key = (mem.memory_key || '').toLowerCase();\n  if (key) existingByKey[key] = mem;\n\n  const val = (mem.memory_value || '').toLowerCase().trim();\n  if (val) existingByValue.set(val, mem);\n});\n\n// ===== Helper: normalize base key =====\nconst slugify = (text) => {\n  return text\n    .toString()\n    .toLowerCase()\n    .normalize('NFKD')\n    .replace(/[^a-z0-9]+/g, '_')\n    .replace(/^_+|_+$/g, '');\n};\n\n// ===== Helper: generate unique key with versions =====\nconst versionCache = {}; // baseKey -> highest version\n\n// Initialize versionCache from existing keys\nObject.keys(existingByKey).forEach(k => {\n  const match = k.match(/^(.*)_v(\\d+)$/);\n  if (match) {\n    const base = match[1];\n    const v = parseInt(match[2], 10);\n    if (!versionCache[base] || v > versionCache[base]) {\n      versionCache[base] = v;\n    }\n  }\n});\n\nconst generateKey = (mem, index) => {\n  // Start from provided key if any\n  let base = mem.memory_key\n    ? slugify(mem.memory_key)\n    : slugify(mem.memory_value || `memory_${index}`);\n\n  // Attach first person if available\n  if (mem.entities && mem.entities.people && mem.entities.people.length > 0) {\n    const person = slugify(mem.entities.people[0]);\n    if (person && !base.includes(person)) {\n      base = `${person}_${base}`;\n    }\n  }\n\n  // Strip existing version suffix\n  base = base.replace(/_v\\d+$/, '');\n\n  const type = mem.memory_type || 'context';\n\n  if (type === 'preference' || type === 'context') {\n    // Versioned keys\n    const current = versionCache[base] || 0;\n    const next = current + 1;\n    versionCache[base] = next;\n    return `${base}_v${next}`;\n  }\n\n  if (type === 'relationship') {\n    // Relationship can be stable per session\n    const now = Date.now();\n    return `${base}_rel_${now}`;\n  }\n\n  if (type === 'interaction') {\n    const now = Date.now();\n    return `${base}_int_${now}`;\n  }\n\n  // Fallback\n  const now = Date.now();\n  return `${base}_${type}_${now}`;\n};\n\n// ===== Very simple similarity check (exact / near exact text) =====\nconst isDuplicateByValue = (value) => {\n  if (!value) return false;\n  const valLower = value.toLowerCase().trim();\n  if (existingByValue.has(valLower)) return true;\n  return false;\n};\n\n// ===== Session & timestamps =====\nlet sessionId = null;\ntry {\n  const ctx = $('Format Context with Memory1').first();\n  if (ctx && ctx.json && ctx.json.ara_context && ctx.json.ara_context.history) {\n    sessionId = ctx.json.ara_context.history.detailed?.[0]?.session_id || null;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get session_id from context');\n}\n\nif (!sessionId) {\n  // Fallback session id\n  sessionId = `${Date.now()}_${Math.floor(Math.random() * 100000)}`;\n}\n\nconst nowIso = new Date().toISOString();\n\n// ===== Process memories =====\nconst prepared = [];\n\nmemories.forEach((mem, index) => {\n  if (!mem || !mem.memory_value) return;\n\n  // Skip if same value already exists\n  if (isDuplicateByValue(mem.memory_value)) {\n    console.log('Prepare Memories: skip duplicate by value:', mem.memory_value.substring(0, 60));\n    return;\n  }\n\n  const type = mem.memory_type || 'context';\n  const key = generateKey(mem, index);\n\n  const row = {\n    user_id: userId,\n    memory_type: type,\n    memory_key: key,\n    memory_value: mem.memory_value,\n    importance_score: mem.importance_score ?? 0.8,\n    session_id: sessionId,\n    conversation_date: nowIso,\n    entities: JSON.stringify(mem.entities || { people: [], topics: [] }),\n    temporal_context: mem.temporal_context || 'today',\n    is_active: true,\n    confidence_score: 1,\n    source: 'auto_extracted',\n    context_before: null,\n    context_after: null,\n  };\n\n  prepared.push(row);\n  console.log(`Prepare Memories: ACCEPTED ${key}`);\n});\n\nif (prepared.length === 0) {\n  console.log('Prepare Memories: no new memories after dedupe');\n}\n\nreturn prepared.map(r => ({ json: r }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -112,
        1296
      ],
      "id": "c6b1a71a-d3f4-4e4e-b6da-4044809689db",
      "name": "Prepare Memories"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "= {{ $json.user_id }}",
              "rightValue": 0,
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              },
              "id": "ebb88b93-4047-405f-9730-737ec9f4b782"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        112,
        1296
      ],
      "id": "1f0b5062-0568-49ef-80c9-dca144cbac24",
      "name": "Has Memories?"
    },
    {
      "parameters": {
        "tableId": "ai_memories",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "memory_type",
              "fieldValue": "={{ $json.memory_type }}"
            },
            {
              "fieldId": "memory_key",
              "fieldValue": "={{ $json.memory_key }}"
            },
            {
              "fieldId": "memory_value",
              "fieldValue": "={{ $json.memory_value }}"
            },
            {
              "fieldId": "importance_score",
              "fieldValue": "={{ $json.importance_score }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "entities",
              "fieldValue": "={{ $json.entities }}"
            },
            {
              "fieldId": "temporal_context",
              "fieldValue": "={{ $json.temporal_context }}"
            },
            {
              "fieldId": "is_active",
              "fieldValue": "={{ $json.is_active }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        336,
        1296
      ],
      "id": "832c98a9-e60f-4336-a3a6-91178b764d3a",
      "name": "Save Memories"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Session Summary Generator v2\n// - Only summarizes completed sessions\n// - Skips very short/test sessions\n// - Produces richer, more structured summaries\n\nconst MIN_MESSAGES = 3;        // Require at least 3 messages in a session\nconst MIN_GAP_MINUTES = 15;    // Session must have ended at least 15 minutes ago\n\n// ---------- 1. Resolve user ID ----------\nlet userId;\n\ntry {\n  const ctx = $('Format Context with Memory1').first();\n  if (ctx?.json?.user_id) {\n    userId = ctx.json.user_id;\n  }\n} catch (e) {\n  console.log('Could not get user ID from Format Context with Memory', e);\n}\n\nif (!userId) {\n  try {\n    const userNode = $('Get User1').first();\n    if (userNode?.json?.id) {\n      userId = userNode.json.id;\n    }\n  } catch (e) {\n    console.log('Could not get user ID from Get User1', e);\n  }\n}\n\n// If we still don't have a userId, we can't safely summarize\nif (!userId) {\n  console.log('No userId found, skipping session summary');\n  return [];\n}\n\n// ---------- 2. Get conversation history for this user ----------\nlet conversations = [];\ntry {\n  conversations = $('Fetch Session History2').all() || [];\n} catch (e) {\n  console.log('Could not get conversations from Fetch Session History', e);\n  return [];\n}\n\n// Convert to plain JS objects and filter by this user (safety)\nconst allConversations = conversations\n  .map(c => c.json)\n  .filter(c => c && c.user_id === userId && c.session_id);\n\nif (allConversations.length < MIN_MESSAGES) {\n  console.log('Not enough conversations overall to summarize');\n  return [];\n}\n\n// Sort descending by created_at (newest first)\nallConversations.sort(\n  (a, b) => new Date(b.created_at) - new Date(a.created_at)\n);\n\n// ---------- 3. Work out current vs completed sessions ----------\nconst currentSessionId = allConversations[0].session_id;\nconsole.log('Current session ID:', currentSessionId);\n\nconst sessionsById = {};\nfor (const conv of allConversations) {\n  if (!sessionsById[conv.session_id]) {\n    sessionsById[conv.session_id] = [];\n  }\n  sessionsById[conv.session_id].push(conv);\n}\n\n// Remove the current session from candidates (we only want completed ones)\ndelete sessionsById[currentSessionId];\n\nconst candidateSessionIds = Object.keys(sessionsById);\nif (candidateSessionIds.length === 0) {\n  console.log('No completed sessions to summarize');\n  return [];\n}\n\n// ---------- 4. Pick the most recent completed session ----------\ncandidateSessionIds.sort((a, b) => {\n  const aRecent = Math.max(\n    ...sessionsById[a].map(c => new Date(c.created_at).getTime())\n  );\n  const bRecent = Math.max(\n    ...sessionsById[b].map(c => new Date(c.created_at).getTime())\n  );\n  return bRecent - aRecent;\n});\n\nconst sessionId = candidateSessionIds[0];\nconst sessionToSummarize = sessionsById[sessionId];\n\n// Ensure this session is ‚Äúreal‚Äù and not just a 1-message ping\nif (sessionToSummarize.length < MIN_MESSAGES) {\n  console.log(\n    `Session ${sessionId} has only ${sessionToSummarize.length} messages, skipping summary`\n  );\n  return [];\n}\n\n// Check how long ago this session ended\nconst mostRecentMessageTs = Math.max(\n  ...sessionToSummarize.map(c => new Date(c.created_at).getTime())\n);\nconst minutesSinceLastMessage =\n  (Date.now() - mostRecentMessageTs) / (1000 * 60);\n\nif (minutesSinceLastMessage < MIN_GAP_MINUTES) {\n  console.log(\n    `Session ${sessionId} ended only ${minutesSinceLastMessage.toFixed(\n      1\n    )} minutes ago, skipping summary`\n  );\n  return [];\n}\n\n// ---------- 5. Extract key info from this session ----------\nconst topics = new Set();\nconst people = new Set();\nconst decisions = [];\nlet firstUserMessage = null;\nlet lastUserMessage = null;\n\nfor (const conv of sessionToSummarize) {\n  if (!conv.user_message) continue;\n\n  const msg = conv.user_message;\n  const msgLower = msg.toLowerCase();\n\n  if (!firstUserMessage) firstUserMessage = msg;\n  lastUserMessage = msg;\n\n  // Topics (you can extend this list anytime)\n  if (msgLower.includes('staff') || msgLower.includes('hire') || msgLower.includes('recruit')) {\n    topics.add('hiring');\n  }\n  if (msgLower.includes('remind') || msgLower.includes('ingat')) {\n    topics.add('reminders');\n  }\n  if (msgLower.includes('meeting') || msgLower.includes('jumpa')) {\n    topics.add('meetings');\n  }\n  if (msgLower.includes('stok') || msgLower.includes('inventory')) {\n    topics.add('inventory');\n  }\n  if (msgLower.includes('duit') || msgLower.includes('bayar') || msgLower.includes('payment')) {\n    topics.add('money');\n  }\n\n  // Rough name detection (single capitalized words)\n  const namePattern = /\\b[A-Z][a-z]{2,}\\b/g;\n  const names = msg.match(namePattern) || [];\n  for (const name of names) {\n    if (!['I', 'Ara', 'ARA'].includes(name)) {\n      people.add(name);\n    }\n  }\n\n  // Decisions / plans (keep first 120 chars)\n  if (\n    msgLower.includes('need') ||\n    msgLower.includes('nak ') ||\n    msgLower.includes('akan ') ||\n    msgLower.includes('plan') ||\n    msgLower.includes('will')\n  ) {\n    decisions.push(msg.substring(0, 120));\n  }\n}\n\n// ---------- 6. Timing & meta info ----------\nsessionToSummarize.sort(\n  (a, b) => new Date(a.created_at) - new Date(b.created_at)\n);\nconst sessionStartTime = new Date(sessionToSummarize[0].created_at);\nconst sessionEndTime = new Date(\n  sessionToSummarize[sessionToSummarize.length - 1].created_at\n);\n\nconst dayOfWeekNames = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n];\nconst dayOfWeek = dayOfWeekNames[sessionStartTime.getDay()];\n\nconst hour = sessionStartTime.getHours();\nconst timeOfDay =\n  hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';\n\nconst durationMinutes = Math.max(\n  1,\n  Math.round((sessionEndTime - sessionStartTime) / (1000 * 60))\n);\n\n// ---------- 7. Build human-readable summary ----------\nlet summaryText = 'User ';\n\nif (topics.has('hiring')) {\n  summaryText += 'discussed getting help with hiring or staff issues';\n} else if (topics.size > 0) {\n  summaryText += `discussed ${Array.from(topics).join(', ')}`;\n} else {\n  summaryText += 'had a general conversation';\n}\n\nif (people.size > 0) {\n  summaryText += `, and mentioned ${Array.from(people).join(', ')}`;\n}\n\nsummaryText += `. Conversation lasted about ${durationMinutes} minute(s).`;\n\nif (decisions.length > 0) {\n  summaryText += ' Key decisions or needs were mentioned.';\n}\n\n// ---------- 8. Construct summary record ----------\nconst summary = {\n  user_id: userId,\n  session_id: sessionId,\n  conversation_date: sessionStartTime.toISOString(),\n  day_of_week: dayOfWeek,\n  time_of_day: timeOfDay,\n  summary: summaryText,\n  key_topics: Array.from(topics),\n  people_mentioned: Array.from(people),\n  decisions_made: decisions,\n  message_count: sessionToSummarize.length,\n  session_duration_minutes: durationMinutes,\n};\n\nconsole.log('Generated summary for completed session:', summary);\n\n// n8n expects an array of items: [{ json: ... }]\nreturn [{ json: summary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -112,
        1680
      ],
      "id": "d9c92ac5-671d-4abe-9c51-60062289440b",
      "name": "Generate Session Summary"
    },
    {
      "parameters": {
        "tableId": "conversation_summaries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "day_of_week",
              "fieldValue": "={{ $json.day_of_week }}"
            },
            {
              "fieldId": "time_of_day",
              "fieldValue": "={{ $json.time_of_day }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $json.summary }}"
            },
            {
              "fieldId": "key_topics",
              "fieldValue": "={{ $json.key_topics }}"
            },
            {
              "fieldId": "people_mentioned",
              "fieldValue": "={{ $json.people_mentioned }}"
            },
            {
              "fieldId": "decisions_made",
              "fieldValue": "={{ $json.decisions_made }}"
            },
            {
              "fieldId": "message_count",
              "fieldValue": "={{ $json.message_count }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        112,
        1680
      ],
      "id": "25b9ad64-5458-46a4-a7b2-d8ebda9c92e2",
      "name": "Save Session Summary"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation1').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $json.body }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $('Extract Pending Action1').item.json.pending_action_type }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $('Extract Pending Action1').item.json.pending_action_payload }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "false"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -624,
        1680
      ],
      "id": "38a63371-7e10-4473-8322-c0564aba4248",
      "name": "Update Conversation1",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "jsCode": "// Validate Memories\n// Input: whatever Extract Memories returns as .json.output or directly as JSON\n// Output: array of clean memory objects (still abstract, no user_id etc.)\n\nlet raw = $json;\n\n// Some setups wrap the JSON array in an \"output\" field as a string\nlet memoriesRaw = raw.output ?? raw;\n\nlet memories = [];\n\ntry {\n  if (typeof memoriesRaw === 'string') {\n    // Strip markdown fences if they accidentally appear\n    memoriesRaw = memoriesRaw\n      .replace(/```json\\s*/g, '')\n      .replace(/```\\s*/g, '')\n      .trim();\n    memories = JSON.parse(memoriesRaw);\n  } else if (Array.isArray(memoriesRaw)) {\n    memories = memoriesRaw;\n  } else {\n    // If it's a single object instead of array, wrap it\n    memories = [memoriesRaw];\n  }\n} catch (e) {\n  console.log('Validate Memories: failed to parse memories', e);\n  return [];\n}\n\nif (!Array.isArray(memories)) {\n  console.log('Validate Memories: parsed value is not an array');\n  return [];\n}\n\nconst ALLOWED_TYPES = new Set(['preference', 'relationship', 'context', 'interaction']);\n\nconst cleaned = memories\n  .filter(m => m && typeof m === 'object')\n  .map((m, idx) => {\n    const mem = { ...m };\n\n    // Normalize memory_type\n    if (!ALLOWED_TYPES.has(mem.memory_type)) {\n      // Try to map invalid types\n      if (mem.memory_type === 'business/role') {\n        mem.memory_type = 'context';\n      } else {\n        // Unknown type ‚Üí treat as context by default\n        mem.memory_type = 'context';\n      }\n    }\n\n    // Ensure text fields exist\n    mem.memory_value = (mem.memory_value || '').toString().trim();\n    mem.memory_key = (mem.memory_key || `memory_${idx}`).toString().trim();\n\n    // Default importance\n    const importance = Number(mem.importance_score ?? 0.8);\n    mem.importance_score = isNaN(importance) ? 0.8 : importance;\n\n    // Normalize entities\n    const entities = mem.entities || {};\n    mem.entities = {\n      people: Array.isArray(entities.people) ? entities.people : [],\n      topics: Array.isArray(entities.topics) ? entities.topics : [],\n    };\n\n    // Temporal context\n    mem.temporal_context = mem.temporal_context || 'today';\n\n    return mem;\n  })\n  .filter(mem => {\n    // Filter out junk\n    if (!mem.memory_value || mem.memory_value.length < 10) return false;\n    if (mem.importance_score < 0.7) return false;\n    return true;\n  });\n\nreturn cleaned.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -336,
        1296
      ],
      "id": "150a62b0-8dac-4ed6-b1c5-11cfaaf277de",
      "name": "Validate Memories1"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Format Context with Memory1').item.json.ara_context.user.phone }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -912,
        1440
      ],
      "id": "15484408-392b-4f6e-bd43-291b1f7af8ff",
      "name": "Send Reply1"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract Pending Action\n// ----------------------\n// Input from ARA Main Agent / Onboarding Agent:\n//   - Old shape: { output: \"<assistant reply>\" }\n//   - Message Model: { message: { content: \"<assistant reply>\" } }\n//\n// Behaviour:\n// - If reply contains `ARA_PENDING: { ... }`, parse it into:\n//      pending_action_type, pending_action_payload\n// - Remove BOTH the ARA_PENDING and ARA_ACTION blocks\n//   from the text for WhatsApp\n// - Keep the original fields for logging / Update Conversation\n\n// Normalise reply from different node shapes\n// - Old main agent: { output: \"...\" }\n// - Message Model:  { message: { content: \"...\" } }\n// - Raw OpenAI style: { choices: [ { message: { content: \"...\" } } ] }\n\nlet reply = '';\n\n// 1) Old main agent shape\nif (typeof $json.output === 'string' && $json.output.trim() !== '') {\n  reply = $json.output;\n\n// 2) Message Model node shape\n} else if ($json.message && typeof $json.message.content === 'string' && $json.message.content.trim() !== '') {\n  reply = $json.message.content;\n\n// 3) Raw OpenAI-style shape (safety net)\n} else if (Array.isArray($json.choices) && $json.choices[0]?.message?.content) {\n  reply = $json.choices[0].message.content;\n}\n\nlet cleanReply = reply || '';\n\nlet pending_action_type = 'none';\nlet pending_action_payload = null;\n\n// 1) Extract & handle ARA_PENDING\nconst pendingMatch = reply.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})/);\n\nif (pendingMatch) {\n  try {\n    const parsed = JSON.parse(pendingMatch[1]);  // { type, payload }\n    if (parsed && parsed.type) {\n      pending_action_type = parsed.type || 'none';\n      pending_action_payload = parsed.payload || null;\n    }\n  } catch (err) {\n    // If parse fails, we just treat it as no pending action\n  }\n\n  // Remove the ARA_PENDING part from the visible reply\n  cleanReply = cleanReply.replace(pendingMatch[0], '').trim();\n}\n\n// 2) Strip ARA_ACTION from visible reply (we parse it later in Route Confirmed Actions)\nconst actionMatch = reply.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\nif (actionMatch) {\n  cleanReply = cleanReply.replace(actionMatch[0], '').trim();\n}\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Clean text for Send Reply (no ARA_ACTION / ARA_PENDING)\n  assistant_response: cleanReply,\n\n  // Action description from THIS message (pending action only)\n  pending_action_type,\n  pending_action_payload,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1360,
        2112
      ],
      "id": "121ea98d-a8d5-4dd5-ab60-4a0d0785a787",
      "name": "Extract Pending Action1"
    },
    {
      "parameters": {
        "jsCode": "// ROUTE CONFIRMED ACTIONS\n// -----------------------\n// INPUT EXPECTED (from Extract Pending Action + previous nodes):\n// - pending_action_type       (from THIS assistant reply's ARA_PENDING)\n// - pending_action_payload\n// - ara_context               (contains dialogue_state with pendingAction from DB)\n// - user_message              (latest user input)\n// - assistant_response        (for passing through to Send Reply)\n\nconst currentType = $json.pending_action_type || 'none';\nconst currentPayload = $json.pending_action_payload || null;\n\n// ara_context comes from \"Format Context with Memory\"\nconst araContext = $json.ara_context || {};\nconst ds = araContext.dialogue_state || {};\nconst pending = ds.pendingAction || null;\nconst isActiveResponse = !!ds.isActiveResponse;\nconst responseType = ds.activeResponseType || null;  // 'yes' | 'no' | null\n\nlet ARA_ACTION = {\n  type: 'none',\n  payload: null,\n};\n\n// CASE 1: User is replying YES/NO to an existing pendingAction\nif (\n  pending &&\n  pending.type &&\n  pending.type !== 'none' &&\n  isActiveResponse &&\n  (responseType === 'yes' || responseType === 'no')\n) {\n  if (responseType === 'yes') {\n    // Confirm the pending action (create/delete/update/...)\n    ARA_ACTION = {\n      type: pending.type,\n      payload: pending.payload || {},\n    };\n  } else if (responseType === 'no') {\n    // Cancel the pending action\n    ARA_ACTION = {\n      type: pending.type + '_cancel',\n      payload: pending.payload || {},\n    };\n  }\n} else {\n  // CASE 2: Immediate actions that do NOT require confirmation\n\n  // Example: escalate to human\n  if (currentType === 'escalate') {\n    ARA_ACTION = {\n      type: 'escalate',\n      payload: currentPayload || {},\n    };\n  }\n\n  // üîπ NEW: direct profile updates (no YES/NO roundtrip)\n  else if (currentType === 'user_update_profile') {\n    ARA_ACTION = {\n      type: 'user_update_profile',\n      payload: currentPayload || {},\n    };\n  }\n}\n\n// CASE 3: User profile updates (ARA_ACTION from main agent or onboarding agent)\n// If the agent outputs ARA_ACTION.update_user_preferences directly inside the text\n\nlet rawOutput = '';\n\n// 1) Old main agent shape: { output: \"...\" }\nif (typeof $json.output === 'string' && $json.output.trim() !== '') {\n  rawOutput = $json.output;\n\n// 2) Message Model / onboarding shape: { message: { content: \"...\" } }\n} else if ($json.message && typeof $json.message.content === 'string' && $json.message.content.trim() !== '') {\n  rawOutput = $json.message.content;\n\n// 3) Raw OpenAI-style shape: { choices: [ { message: { content: \"...\" } } ] }\n} else if (Array.isArray($json.choices) && $json.choices[0]?.message?.content) {\n  rawOutput = $json.choices[0].message.content;\n}\n\nconst actionMatch = rawOutput.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\n\nif (actionMatch) {\n  try {\n    const parsedAction = JSON.parse(actionMatch[1]);\n\n    if (parsedAction.type === 'update_user_preferences') {\n      // Build payload ONLY with non-null fields\n      const payload = {};\n\n      if (\n        typeof parsedAction.preferred_name === 'string' &&\n        parsedAction.preferred_name.trim() !== ''\n      ) {\n        payload.preferred_name = parsedAction.preferred_name.trim();\n      }\n\n      if (\n        typeof parsedAction.preferred_language === 'string' &&\n        parsedAction.preferred_language.trim() !== ''\n      ) {\n        payload.preferred_language = parsedAction.preferred_language.trim();\n      }\n\n      // Only overwrite ARA_ACTION if we have something real to update\n      if (Object.keys(payload).length > 0) {\n        ARA_ACTION = {\n          type: 'update_user_preferences',\n          payload,\n        };\n      }\n      // else: no valid fields ‚Üí keep whatever ARA_ACTION was before\n    }\n  } catch (err) {\n    // ignore JSON parsing error, fall back to existing ARA_ACTION\n  }\n}\n\n\n// -----------------------------\n// SAFETY GUARDS (AILOOP PROTECT)\n// -----------------------------\n\n// 1) Whitelist allowed action types only\nconst allowedTypes = [\n  'none',\n  'reminder_create',\n  'reminder_delete',\n  'timezone_update',\n  'escalate',\n  'update_user_preferences',          // üîπ NEW\n\n  'reminder_create_cancel',\n  'reminder_delete_cancel',\n  'timezone_update_cancel',\n  'user_update_profile_cancel',   // optional future use\n];\n\nif (!allowedTypes.includes(ARA_ACTION.type)) {\n  ARA_ACTION = {\n    type: 'none',\n    payload: null,\n  };\n}\n\n// 2) Payload validation for specific actions\n\n// Reminder Create must have topic + suggested_time\nif (ARA_ACTION.type === 'reminder_create') {\n  const p = ARA_ACTION.payload || {};\n  const hasTopic =\n    typeof p.topic === 'string' && p.topic.trim().length > 0;\n  const hasTime =\n    typeof p.suggested_time === 'string' && p.suggested_time.trim().length > 0;\n\n  if (!hasTopic || !hasTime) {\n    // Invalid payload ‚Üí cancel action instead of firing broken data downstream\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Reminder Delete must have reminder_id\nif (ARA_ACTION.type === 'reminder_delete') {\n  const p = ARA_ACTION.payload || {};\n  const hasReminderId =\n    typeof p.reminder_id === 'string' && p.reminder_id.trim().length > 0;\n\n  if (!hasReminderId) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Timezone Update must have timezone + timezone_label\nif (ARA_ACTION.type === 'timezone_update') {\n  const p = ARA_ACTION.payload || {};\n  const hasTz =\n    typeof p.timezone === 'string' && p.timezone.trim().length > 0;\n  const hasLabel =\n    typeof p.timezone_label === 'string' && p.timezone_label.trim().length > 0;\n\n  if (!hasTz || !hasLabel) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Profile Update must have at least one field to update\nif (ARA_ACTION.type === 'user_update_profile') {\n  const p = ARA_ACTION.payload || {};\n  const updates = p.profile_updates || null;\n\n  const valid =\n    updates &&\n    typeof updates === 'object' &&\n    Object.keys(updates).length > 0;\n\n  if (!valid) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Preferences Update must have at least one field\nif (ARA_ACTION.type === 'update_user_preferences') {\n  const p = ARA_ACTION.payload || {};\n  const hasName = Object.prototype.hasOwnProperty.call(p, 'preferred_name');\n  const hasLang = Object.prototype.hasOwnProperty.call(p, 'preferred_language');\n\n  if (!hasName && !hasLang) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n\n\n// (We let 'escalate' and *_cancel pass even with minimal payload)\n\n// -----------------------------\n// Text back to user = assistant_response from previous node\n// -----------------------------\nconst final_reply = ($json.assistant_response || '').trim();\n\n// Safely pull the latest conversation row so we can attach ids\nconst latestItems = $items('Get Latest Conversation1');\nconst latest = latestItems.length ? latestItems[0].json : {};\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Ensure these four are present from Get Latest Conversation\n  id: latest.id ?? $json.id,\n  user_id: latest.user_id ?? $json.user_id,\n  telegram_chat_id: latest.telegram_chat_id ?? $json.telegram_chat_id,\n  message_id: latest.message_id ?? $json.message_id,\n\n  ARA_ACTION,\n  final_reply,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        608
      ],
      "id": "9bd47c47-c781-44f1-ad6c-d7c2060d7006",
      "name": "Route Confirmed Actions1"
    },
    {
      "parameters": {
        "tableId": "reminders",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation').item.json.user_id }}"
            },
            {
              "fieldId": "reminder_text",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.topic }}"
            },
            {
              "fieldId": "reminder_time",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.suggested_time }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "{{ $now }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -624,
        224
      ],
      "id": "708e202c-d188-4e34-9a28-dad717c370ef",
      "name": "Create Reminder1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_create",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "0d51000f-6a84-4eb8-8e74-e2190366c0dd"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Create"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7effae48-3c8b-445c-bdaf-8043843459f1",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f18fc6df-6c26-4714-ba28-fa4560fcec67",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "escalate",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Escalate"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4995634b-8db5-4173-8c98-866642aee254",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "timezone_update",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Timezone update"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "6695a56f-6968-4e5d-a459-9d98fe92a1ef",
                    "leftValue": "={{ $json[\"ARA_ACTION\"].type }}",
                    "rightValue": "update_user_preferences",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update User Profile"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -912,
        560
      ],
      "id": "31ee57e1-b4bd-4628-9e8f-414ba122bf7a",
      "name": "Route Actions Switch1"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "reminders",
        "filters": {
          "conditions": [
            {
              "keyName": "reminder_text",
              "condition": "ilike",
              "keyValue": "={{ $json.pending_action_payload.topic }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -624,
        416
      ],
      "id": "bc354ebc-12a8-4180-8a78-e90b3ef45fe7",
      "name": "Delete Reminder1"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "home_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "current_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        624,
        2928
      ],
      "id": "53cdaade-3d9e-48f2-9c7c-6772892608c3",
      "name": "Update Timezone"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "home_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "current_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -624,
        608
      ],
      "id": "5306639b-ce22-4eca-8052-bcaf8f140ae1",
      "name": "Update Timezone1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "46456542-8f2a-447d-b598-1713986577a7",
              "name": "user_name",
              "value": "={{    $node[\"Get User1\"].json.first_name    || $node[\"Get User1\"].json.telegram_username    || $json.telegram_chat_id  }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        624,
        2544
      ],
      "id": "d9cf4e29-3101-44a8-ae11-41d60074348e",
      "name": "Get User name"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "46456542-8f2a-447d-b598-1713986577a7",
              "name": "user_name",
              "value": "={{    $node[\"Get User1\"].json.first_name    || $node[\"Get User1\"].json.telegram_username    || $json.telegram_chat_id  }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -624,
        992
      ],
      "id": "5f4aa1fe-741e-4f0a-975c-64dc0312e24b",
      "name": "Get User name1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.twilio.com/2010-04-01/Accounts/AC_REDACTED/Messages.json",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "twilioApi",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "From",
              "value": "=whatsapp:+601125911400"
            },
            {
              "name": "To",
              "value": "whatsapp:+601136521251"
            },
            {
              "name": "ContentSid",
              "value": "HXce8e8c9580065acd9c86815c679a0dbe"
            },
            {
              "name": "ContentVariables",
              "value": "={{ JSON.stringify({\n  \"1\": $json.user_name,\n  \"2\": $('Route Confirmed Actions').item.json.telegram_chat_id,\n  \"3\": $('Route Confirmed Actions').item.json.ARA_ACTION.payload.reason\n       + \". \"\n       + $('Route Confirmed Actions').item.json.ARA_ACTION.payload.summary,\n  \"4\": $('Route Confirmed Actions').item.json.ARA_ACTION.payload.last_user_message,\n  \"5\": $now\n}) }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        912,
        2544
      ],
      "id": "edb63509-b4ee-4bb0-a397-7c41aa5aa27f",
      "name": "Escalate"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.twilio.com/2010-04-01/Accounts/AC_REDACTED/Messages.json",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "twilioApi",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "From",
              "value": "=whatsapp:+601125911400"
            },
            {
              "name": "To",
              "value": "whatsapp:+601136521251"
            },
            {
              "name": "ContentSid",
              "value": "HXce8e8c9580065acd9c86815c679a0dbe"
            },
            {
              "name": "ContentVariables",
              "value": "={{ JSON.stringify({\n  \"1\": $json.user_name,\n  \"2\": $('Route Confirmed Actions1').item.json.telegram_chat_id,\n  \"3\": $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.reason\n       + \". \"\n       + $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.summary,\n  \"4\": $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.last_user_message,\n  \"5\": $now\n}) }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -336,
        992
      ],
      "id": "bcc2a7c5-9ac3-45d5-ad9c-2783b12970c3",
      "name": "Escalate1"
    },
    {
      "parameters": {
        "tableId": "escalations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.user_id }}"
            },
            {
              "fieldId": "user_name",
              "fieldValue": "={{ $('Get User name').item.json.user_name }}"
            },
            {
              "fieldId": "user_phone",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.telegram_chat_id }}"
            },
            {
              "fieldId": "reason",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.reason }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.summary }}"
            },
            {
              "fieldId": "last_user_message",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.last_user_message }}"
            },
            {
              "fieldId": "urgency",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.urgency }}"
            },
            {
              "fieldId": "admin_phone",
              "fieldValue": "={{ '601136521251' }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "={{ 'open' }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1136,
        2544
      ],
      "id": "684e086e-51a2-460c-9487-2c3b8c806b38",
      "name": "Create Escalation Log"
    },
    {
      "parameters": {
        "tableId": "escalations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.user_id }}"
            },
            {
              "fieldId": "user_name",
              "fieldValue": "={{ $('Get User name1').item.json.user_name }}"
            },
            {
              "fieldId": "user_phone",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.telegram_chat_id }}"
            },
            {
              "fieldId": "reason",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.reason }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.summary }}"
            },
            {
              "fieldId": "last_user_message",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.last_user_message }}"
            },
            {
              "fieldId": "urgency",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.urgency }}"
            },
            {
              "fieldId": "admin_phone",
              "fieldValue": "={{ '601136521251' }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "={{ 'open' }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -112,
        992
      ],
      "id": "de272164-c237-4fbf-8c9b-fd72ef551041",
      "name": "Create Escalation Log1"
    },
    {
      "parameters": {
        "jsCode": "const replyRaw = ($json.assistant_response || '').trim();\n\n// Simple language guess from latest user message (if available)\nconst userMsg = ($json.user_message || '').trim().toLowerCase();\n\nfunction buildFallback(msg) {\n  const hasMalayHints = /lah|tak|awak|saya|boleh|ingatkan|esok|pukul/.test(msg);\n  if (hasMalayHints) {\n    return \"Maaf, ada masalah teknikal sekejap. Cuba hantar semula mesej tadi ya. üôè\";\n  }\n  return \"Sorry, something went wrong on my side. Please send your last message again. üôè\";\n}\n\nlet safeReply = replyRaw;\nlet fallback_used = false;\n\nif (!safeReply) {\n  safeReply = buildFallback(userMsg);\n  fallback_used = true;\n}\n\n// Return everything + guaranteed reply text\nreturn {\n  ...$json,\n  assistant_response: safeReply,\n  fallback_used,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        4048
      ],
      "id": "10f30ab2-e90c-4dfd-b7ad-72c67ed8523b",
      "name": "Prepare Reply (Fail-Safe)"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "event_type",
              "fieldValue": "incoming_message"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{   {     source: \"whatsapp\",     direction: \"inbound\",     message_id: $json.SmsMessageSid || $json.MessageSid || $json.message_id || null,     from: $json.From || $json.from || null,     to: $json.To || $json.to || null,     raw_body: $json.Body || $json.body || $json.user_message || \"\"   } }}"
            },
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -4176,
        2592
      ],
      "id": "8cf6f62c-9f43-4fd6-8ac3-83e023477208",
      "name": "Log Incoming Message"
    },
    {
      "parameters": {
        "content": "## Changed"
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -4256,
        2320
      ],
      "typeVersion": 1,
      "id": "48bb326c-16cd-4f2f-9427-9e35a7371bbf",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "reminder_created"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  type: \"reminder\",\n  action: \"created\",\n  reminder_id: $json.id || null,\n  reminder_text: $json.reminder_text || null,\n  reminder_time: $json.reminder_time || null,\n  is_sent: $json.is_sent\n} }}\n"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1360,
        1392
      ],
      "id": "0c1d5543-250f-42d8-9605-79e5dbbe7a81",
      "name": "Log Reminder Created"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "memory_extracted"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {   source: \"whatsapp\",   type: \"memory\",   action: \"saved\",   memory_id: $json.id || null,   memory_category: $json.category || null,   memory_title: $json.title || null } }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1808,
        3696
      ],
      "id": "58ed751a-fa7c-4320-b572-6218e56401eb",
      "name": "Log Memory Extracted"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "fallback_triggered"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  scope: \"main_agent\",\n  reason: \"assistant_response_empty_or_invalid\",\n  last_user_message: $json.user_message || null\n} }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        624,
        4112
      ],
      "id": "c1b88a18-c7cc-478e-841d-126b99d15b2d",
      "name": "log Main Fallback"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.fallback_used }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "32a5b251-f43e-40f7-bda8-b82ec3edfbf7"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        336,
        4112
      ],
      "id": "ac11a6b1-5634-4360-9d96-ed663c618b80",
      "name": "IF Fallback Used?"
    },
    {
      "parameters": {
        "jsCode": "const replyRaw = ($json.assistant_response || '').trim();\n\n// Simple language guess from latest user message (if available)\nconst userMsg = ($json.user_message || '').trim().toLowerCase();\n\nfunction buildFallback(msg) {\n  const hasMalayHints = /lah|tak|awak|saya|boleh|ingatkan|esok|pukul/.test(msg);\n  if (hasMalayHints) {\n    return \"Maaf, ada masalah teknikal sekejap. Cuba hantar semula mesej tadi ya. üôè\";\n  }\n  return \"Sorry, something went wrong on my side. Please send your last message again. üôè\";\n}\n\nlet safeReply = replyRaw;\nlet fallback_used = false;\n\nif (!safeReply) {\n  safeReply = buildFallback(userMsg);\n  fallback_used = true;\n}\n\n// Return everything + guaranteed reply text\nreturn {\n  ...$json,\n  assistant_response: safeReply,\n  fallback_used,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        2544
      ],
      "id": "df2bb67e-dd88-434f-b867-523d3957dd40",
      "name": "Prepare Reply (Fail-Safe)1"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation1').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "fallback_triggered"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  scope: \"main_agent\",\n  reason: \"assistant_response_empty_or_invalid\",\n  last_user_message: $json.user_message || null\n} }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -624,
        2880
      ],
      "id": "ec3c0af5-9ea3-4c87-945b-80e54df375ad",
      "name": "log Main Fallback1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.fallback_used }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "32a5b251-f43e-40f7-bda8-b82ec3edfbf7"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        -912,
        2880
      ],
      "id": "0d8ab11f-0de5-4889-a103-5fff29dad3d0",
      "name": "IF Fallback Used?1"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "memory_extracted"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {   source: \"whatsapp\",   type: \"memory\",   action: \"saved\",   memory_id: $json.id || null,   memory_category: $json.category || null,   memory_title: $json.title || null } }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        624,
        1296
      ],
      "id": "c20c7017-0b7c-489e-8320-9d0344e63e2c",
      "name": "Log Memory Extracted1"
    },
    {
      "parameters": {
        "jsCode": "// This code cleans relative-day words from reminder topic\n// and leaves other flows untouched.\n\nconst RELATIVE_DAY_REGEX = /\\b(hari ini|esok|lusa|minggu depan|bulan depan|malam ini|pagi esok|today|tomorrow|tonight|next week|next month|this morning|this evening)\\b/gi;\n\nreturn items.map(item => {\n  const data = item.json || {};\n\n  let payload = data.pending_action_payload;\n\n  // Some flows store payload as JSON string, some as object\n  if (typeof payload === 'string') {\n    try {\n      payload = JSON.parse(payload);\n    } catch (e) {\n      // If parsing fails, just skip cleaning and pass through\n      item.json = data;\n      return item;\n    }\n  }\n\n  if (payload && typeof payload === 'object' && typeof payload.topic === 'string') {\n    payload.topic = payload.topic\n      .replace(RELATIVE_DAY_REGEX, '')   // remove relative-day words\n      .replace(/\\s+/g, ' ')             // collapse double spaces\n      .trim();\n  }\n\n  // Put payload back in its original shape\n  data.pending_action_payload = payload;\n\n  item.json = data;\n  return item;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        912,
        1488
      ],
      "id": "ed31a7f3-b13f-4418-912a-482ce11e54ae",
      "name": "Sanitise Reminder Topic"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE public.users\nSET\n  preferred_name = COALESCE(NULLIF($1::text, 'null'), preferred_name),\n  preferred_language = CASE\n    WHEN $2 IS NULL OR $2 = '__KEEP__' THEN preferred_language\n    ELSE $2\n  END\nWHERE id = $3;\n",
        "options": {
          "queryReplacement": "={{ $json.pending_action_payload?.preferred_name ?? null }}, {{ $json.pending_action_payload?.preferred_language === undefined ? '__KEEP__' : $json.pending_action_payload?.preferred_language }}\n, {{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        624,
        2736
      ],
      "id": "a0c39ddc-d1ca-486f-b7d5-5fffb3f9905b",
      "name": "PG ‚Äì Update user preferences"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE public.users\nSET\n preferred_name = COALESCE(NULLIF($1::text, 'null'), preferred_name),\n  preferred_language = CASE\n    WHEN $2 IS NULL OR $2 = '__KEEP__' THEN preferred_language\n    ELSE $2\n  END\nWHERE id = $3;\n",
        "options": {
          "queryReplacement": "={{ $json[\"ARA_ACTION\"].payload.preferred_name ?? null }}, {{    $json[\"ARA_ACTION\"].payload.preferred_language === undefined     ? '__KEEP__'     : $json[\"ARA_ACTION\"].payload.preferred_language }}, {{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -624,
        800
      ],
      "id": "93cf86e3-e7f3-45f0-be1e-fa17cb895227",
      "name": "PG ‚Äì Update user preferences1"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Mixed-Offer Override (SAFE GUARDRAIL)\n// Run mode: \"Run Once for Each Item\"  ‚úÖ must return a SINGLE object (not an array)\n\nconst item = $json;\n\nconst currentType = (item.pending_action_type || 'none').toString();\n\n// Pass through if extractor already found an action\nif (currentType !== 'none') {\n  return item;\n}\n\nconst assistantText = (item.assistant_response || '').toString().trim();\nif (!assistantText) return item;\n\n// 1) Must look like a REMINDER offer (not generic offers)\nconst hasReminderWords = /\\b(remind|reminder|ingatkan|peringat)\\b/i.test(assistantText);\n\nconst hasOfferAsk =\n  /\\b(would you like me to|do you want me to|shall i|should i|can i|may i)\\b/i.test(assistantText) ||\n  /\\b(just to confirm|to confirm)\\b/i.test(assistantText) ||\n  /\\b(nak saya|mahu saya|boleh saya)\\b/i.test(assistantText);\n\nif (!hasReminderWords || !hasOfferAsk) {\n  return item;\n}\n\n// 2) Require explicit day anchor (no guessing dates)\nconst isTomorrow = /\\b(tomorrow|esok)\\b/i.test(assistantText);\nconst isToday = /\\b(today|harini|hari ini)\\b/i.test(assistantText);\nif (!isTomorrow && !isToday) return item;\n\n// 3) Extract clock time\nlet hour = null;\nlet minute = 0;\n\nlet m = assistantText.match(/\\b([01]?\\d|2[0-3])[:.](\\d{2})\\s*(am|pm)?\\b/i);\nif (m) {\n  hour = parseInt(m[1], 10);\n  minute = parseInt(m[2], 10);\n  const ampm = (m[3] || '').toLowerCase();\n  if (ampm === 'pm' && hour < 12) hour += 12;\n  if (ampm === 'am' && hour === 12) hour = 0;\n} else {\n  m = assistantText.match(/\\b([1-9]|1[0-2])\\s*(am|pm)\\b/i);\n  if (m) {\n    hour = parseInt(m[1], 10);\n    minute = 0;\n    const ampm = (m[2] || '').toLowerCase();\n    if (ampm === 'pm' && hour < 12) hour += 12;\n    if (ampm === 'am' && hour === 12) hour = 0;\n  }\n}\n\nif (hour === null) return item;\n\n// 4) Build suggested_time safely for +08 zones only\nconst tz = item?.ara_context?.user?.timezone || 'Asia/Kuala_Lumpur';\nconst plus8Zones = new Set(['Asia/Kuala_Lumpur', 'Asia/Kuching', 'Asia/Singapore']);\nif (!plus8Zones.has(tz)) return item;\n\nfunction pad2(n) { return String(n).padStart(2, '0'); }\n\nconst nowUtc = new Date();\nconst nowPlus8 = new Date(nowUtc.getTime() + 8 * 60 * 60 * 1000);\n\nlet y = nowPlus8.getUTCFullYear();\nlet mo = nowPlus8.getUTCMonth() + 1;\nlet d = nowPlus8.getUTCDate();\n\nif (isTomorrow) d += 1;\n\nconst suggested_time = `${y}-${pad2(mo)}-${pad2(d)}T${pad2(hour)}:${pad2(minute)}:00+08:00`;\n\n// 5) Topic extraction (SAFE): derive from THIS assistant offer sentence, not history\nlet topic = null;\n\n// Try English \"about <topic>\" pattern\nlet t = assistantText.match(/\\babout\\s+(.+?)(\\?|$)/i);\nif (t && t[1]) {\n  topic = t[1].trim();\n}\n\n// Try Malay \"pasal/mengenai/tentang <topic>\" pattern\nif (!topic) {\n  t = assistantText.match(/\\b(pasal|mengenai|tentang)\\s+(.+?)(\\?|$)/i);\n  if (t && t[2]) topic = t[2].trim();\n}\n\n// Clean trailing filler words\nif (topic) {\n  topic = topic.replace(/\\s+(right|ya|betul)\\s*$/i, '').trim();\n}\n\n// Fallback 1: use current user message text (still safer than scanning long history)\nif (!topic) {\n  topic = (item?.ara_context?.current_message?.text || item?.user_message || '').toString().trim();\n}\n\n// Fallback 2: safe snippet of assistant\nif (!topic) {\n  topic = assistantText.slice(0, 120);\n}\n\n\n// Apply override\nreturn {\n  ...item,\n  pending_action_type: 'reminder_offer',\n  pending_action_payload: {\n    topic,\n    suggested_time,\n  },\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -112,
        2448
      ],
      "id": "5bdead9e-ab22-43fa-98da-fc372574c285",
      "name": "Mixed-Offer Override"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"assistant_response\": { \"type\": \"string\" },\n    \"pending_action_type\": { \"type\": \"string\" },\n    \"pending_action_payload\": { \"type\": [\"object\", \"null\"] }\n  },\n  \"required\": [\"assistant_response\", \"pending_action_type\", \"pending_action_payload\"],\n  \"additionalProperties\": true\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -560,
        3536
      ],
      "id": "6dc726d3-f982-4d65-8914-81e8288bba62",
      "name": "Structured Output Parser",
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "// Normalize reminder delete payloads into 1-item-per-target outputs\n// ‚úÖ Keeps existing behavior (single + bulk + numbered ids)\n// ‚úÖ NEW: supports delete_scope = all_active/all by emitting reminder_id = \"all\"\n\nconst out = [];\n\nfor (const item of $input.all()) {\n  const j = item.json || {};\n  const p = j.pending_action_payload ?? j.output?.pending_action_payload ?? {};\n\n  // ---------- NEW: DELETE ALL ----------\n  // If agent says delete_scope: \"all_active\" (or \"all\"), emit a single routing token.\n  const scope = (p.delete_scope ?? \"\").toString().toLowerCase().trim();\n  if (scope === \"all_active\" || scope === \"all\") {\n    out.push({\n      json: {\n        reminder_id: \"all\",\n        // keep for safety filter downstream\n        user_id: p.user_id || j.user_id || null,\n      },\n    });\n    continue; // don't also attempt id extraction\n  }\n\n  // ---------- EXISTING: EXTRACT IDS ----------\n  let ids = [];\n\n  // Case 1: array already provided\n  if (Array.isArray(p.reminder_ids)) {\n    ids = p.reminder_ids;\n\n  // Case 2: comma-separated string\n  } else if (typeof p.reminder_ids === \"string\") {\n    ids = p.reminder_ids.split(\",\").map((s) => s.trim());\n\n  // Case 3: single id\n  } else if (p.reminder_id) {\n    ids = [p.reminder_id];\n\n  // Case 4: reminder_id_1, reminder_id_2, reminder_id_3 ... reminder_id_N\n  } else {\n    ids = Object.keys(p)\n      .filter((k) => /^reminder_id_\\d+$/.test(k))\n      .sort(\n        (a, b) => Number(a.split(\"_\").pop()) - Number(b.split(\"_\").pop())\n      )\n      .map((k) => p[k]);\n  }\n\n  // Emit one n8n item per reminder id\n  for (const id of ids.filter(Boolean)) {\n    out.push({\n      json: {\n        reminder_id: id,\n        user_id: j.user_id || p.user_id || null, // keep for safety filter\n      },\n    });\n  }\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        912,
        2352
      ],
      "id": "3277d9c6-903f-42b0-955a-6cffb696d689",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "reminders",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.reminder_id }}"
            },
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1360,
        3392
      ],
      "id": "a7d430bb-0c10-4a4b-85d4-e26c2a07dd49",
      "name": "Delete Reminder"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "58254766-51ec-4ad3-ab34-2928e9b7d44c",
              "leftValue": "={{ $json.reminder_id }}",
              "rightValue": "all",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1136,
        2352
      ],
      "id": "da4fe5e7-64b9-43c1-b4b6-be12eba30508",
      "name": "If ALL?"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "reminders",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Code in JavaScript').item.json.user_id }}"
            },
            {
              "keyName": "is_sent",
              "condition": "eq",
              "keyValue": "={{ false }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1360,
        2928
      ],
      "id": "e30888aa-63c7-41ac-be18-b0945c5628a2",
      "name": "Delete ALL"
    },
    {
      "parameters": {
        "jsCode": "// Explode Reminder (FIXED)\n// Supports BOTH:\n// 1) Bulk: pending_action_payload.reminders = [{topic, suggested_time}, ...]\n// 2) Single: pending_action_payload = {topic, suggested_time}\n\nconst base = $json;\n\nconst payload =\n  base.pending_action_payload ||\n  base.output?.pending_action_payload ||\n  null;\n\nlet reminders = [];\n\nif (payload && Array.isArray(payload.reminders) && payload.reminders.length > 0) {\n  reminders = payload.reminders;\n} else if (payload && payload.topic && payload.suggested_time) {\n  reminders = [{ topic: payload.topic, suggested_time: payload.suggested_time }];\n} else {\n  return [];\n}\n\nconst user_id = base.user_id;\nconst telegram_chat_id = base.telegram_chat_id;\nconst session_id = base.session_id;\nconst message_id = base.message_id;\n\nreturn reminders.map((r, idx) => ({\n  json: {\n    source_message_id: message_id,\n    source_session_id: session_id,\n    batch_index: idx,\n\n    user_id,\n    reminder_text: r.topic,\n    reminder_time: r.suggested_time,\n    is_sent: false,\n\n    telegram_chat_id,\n  }\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        1488
      ],
      "id": "ff32bd49-18de-444d-ba9a-054b7078db34",
      "name": "Explode Reminder"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_create",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0001"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Create"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_list",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0002"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "List"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete_request",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0003"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete Request"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7effae48-3c8b-445c-bdaf-8043843459f1",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f18fc6df-6c26-4714-ba28-fa4560fcec67",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "escalate",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Escalate"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "602c304b-fae9-4ee9-aea5-3622eea25845",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "timezone_update",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update timezone"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "959a4996-035d-4e07-951b-9fe19d261d98",
                    "leftValue": "={{ $json.pending_action_type || $json.output?.pending_action_type || \"\" }}",
                    "rightValue": "update_user_preferences",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update User Profile"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        336,
        2368
      ],
      "id": "8b23e15f-8169-4c1a-9003-0bd3371866a0",
      "name": "Route Actions Switch2"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "reminders",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            },
            {
              "keyName": "is_sent",
              "condition": "eq",
              "keyValue": "={{ false }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        624,
        1968
      ],
      "id": "f85941ec-bfa6-4d2c-ae03-bbb4cef93f0e",
      "name": "List Reminders",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "leftValue": "={{ $('Route Actions Switch2').item.json.output.pending_action_type }}",
              "rightValue": "reminder_list",
              "operator": {
                "type": "string",
                "operation": "equals"
              },
              "id": "acb1dea8-5ea5-49f6-aaee-a44cdb995471"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        912,
        1872
      ],
      "id": "39a3dde4-16e8-4354-805b-244c2baac849",
      "name": "IF Reminder List?"
    },
    {
      "parameters": {
        "jsCode": "// Format Reminder List (human WhatsApp style)\n// Mode: Run Once for All Items ‚úÖ\n// Input items = rows from \"List Reminders\" node\n\nfunction getTelegramChatId() {\n  // You said Route Actions Switch2 has it ‚Äî keep that as primary\n  const v =\n    $items('Route Actions Switch2')?.[0]?.json?.telegram_chat_id ||\n    $items('Route Confirmed Actions')?.[0]?.json?.telegram_chat_id ||\n    $items('Get Latest Conversation')?.[0]?.json?.telegram_chat_id ||\n    $items('Route Actions Switch')?.[0]?.json?.telegram_chat_id ||\n    null;\n\n  return v ? String(v).trim() : null;\n}\n\nfunction getPreferredLanguage() {\n  // Safest: pull from Get User1 node output\n  const u = $items('Get User1')?.[0]?.json ?? {};\n  return (u.preferred_language || 'en').toString().toLowerCase();\n}\n\nfunction getUserTimezone() {\n  // Try to use ara_context first, else fall back to Malaysia\n  const tz =\n    $json?.ara_context?.user?.current_timezone ||\n    $json?.ara_context?.user?.timezone ||\n    $items('Get User1')?.[0]?.json?.current_timezone ||\n    $items('Get User1')?.[0]?.json?.timezone ||\n    'Asia/Kuala_Lumpur';\n  return tz;\n}\n\nfunction formatDateHeader(d, lang, timeZone) {\n  // Example: Tue, 27 Jan\n  const locale =\n    lang === 'ms' ? 'ms-MY' :\n    lang === 'id' ? 'id-ID' :\n    'en-MY';\n\n  return new Intl.DateTimeFormat(locale, {\n    timeZone,\n    weekday: 'short',\n    day: '2-digit',\n    month: 'short',\n  }).format(d);\n}\n\nfunction formatTime12h(d, lang, timeZone) {\n  // Example: 3:00 PM\n  const locale =\n    lang === 'ms' ? 'en-MY' :   // Malay users usually still prefer \"3:00 PM\" formatting\n    lang === 'id' ? 'en-ID' :\n    'en-MY';\n\n  return new Intl.DateTimeFormat(locale, {\n    timeZone,\n    hour: 'numeric',\n    minute: '2-digit',\n    hour12: true,\n  }).format(d);\n}\n\nfunction getText(lang, key) {\n  const dict = {\n    en: {\n      title: \"Here are your reminders:\",\n      none: \"You don‚Äôt have any active reminders yet.\",\n      tip: \"If you want, just type: ‚ÄúRemind me to ‚Ä¶ at ‚Ä¶‚Äù\",\n    },\n    ms: {\n      title: \"Ini reminder awak:\",\n      none: \"Buat masa sekarang, tak ada reminder yang aktif lagi.\",\n      tip: \"Kalau nak set, boleh taip: ‚ÄúIngatkan saya ‚Ä¶ pukul ‚Ä¶‚Äù\",\n    },\n    id: {\n      title: \"Ini daftar pengingat kamu:\",\n      none: \"Saat ini kamu belum punya pengingat yang aktif.\",\n      tip: \"Kalau mau set, ketik: ‚ÄúIngatkan saya ‚Ä¶ jam ‚Ä¶‚Äù\",\n    },\n  };\n  return (dict[lang] && dict[lang][key]) ? dict[lang][key] : dict.en[key];\n}\n\n// --------------------\n// Main\n// --------------------\nconst telegram_chat_id = getTelegramChatId();   // ‚úÖ PATCH: always carry forward\nconst lang = getPreferredLanguage();            // en | ms | id\nconst timeZone = getUserTimezone();\n\n// All DB rows from List Reminders\nconst rows = items.map(i => i.json).filter(r => r && r.reminder_time);\n\n// No reminders case\nif (!rows.length) {\n  const assistant_response = `${getText(lang, 'none')}\\n${getText(lang, 'tip')}`;\n  return [{\n    json: {\n      ...($json || {}),\n      telegram_chat_id, // ‚úÖ PATCH\n      assistant_response,\n      // IMPORTANT: stop re-triggering list\n      pending_action_type: \"none\",\n      pending_action_payload: null,\n    }\n  }];\n}\n\n// Sort by reminder_time ascending\nrows.sort((a, b) => new Date(a.reminder_time).getTime() - new Date(b.reminder_time).getTime());\n\n// Group by date (YYYY-MM-DD in user's timezone)\nfunction dateKey(d) {\n  const parts = new Intl.DateTimeFormat('en-CA', {\n    timeZone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(d);\n\n  const y = parts.find(p => p.type === 'year')?.value;\n  const m = parts.find(p => p.type === 'month')?.value;\n  const da = parts.find(p => p.type === 'day')?.value;\n  return `${y}-${m}-${da}`;\n}\n\nconst groups = new Map();\nfor (const r of rows) {\n  const d = new Date(r.reminder_time);\n  const key = dateKey(d);\n  if (!groups.has(key)) groups.set(key, []);\n  groups.get(key).push({ ...r, _date: d });\n}\n\n// Build WhatsApp message\nlet lines = [];\nlines.push(getText(lang, 'title'));\n\nfor (const [, list] of groups.entries()) {\n  // Date header\n  const headerDate = list[0]._date;\n  lines.push(`\\n${formatDateHeader(headerDate, lang, timeZone)}`);\n\n  // Items\n  for (const r of list) {\n    const t = formatTime12h(r._date, lang, timeZone);\n    const text = (r.reminder_text || '').toString().trim() || '(no title)';\n    lines.push(`- ${t} ‚Äî ${text}`);\n  }\n}\n\nconst assistant_response = lines.join('\\n');\n\nreturn [{\n  json: {\n    ...($json || {}),\n    telegram_chat_id, // ‚úÖ PATCH\n    assistant_response,\n    // IMPORTANT: stop re-triggering list\n    pending_action_type: \"none\",\n    pending_action_payload: null,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        1776
      ],
      "id": "0815e627-b2c2-44b1-a2e7-9eb5adff6eac",
      "name": "Format Reminder List Message"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $json.telegram_chat_id }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        1808,
        2352
      ],
      "id": "b7a54442-2a32-4c6e-90b1-cdafc2c3becb",
      "name": "Send Reply - Reminder List"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1360,
        2352
      ],
      "id": "04d03a80-ca16-421e-9a97-1788dce8b073",
      "name": "Merge"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1584,
        2352
      ],
      "id": "2391e905-91f9-4d13-9800-bf6d8cf62ff5",
      "name": "Wait",
      "webhookId": "ac226e70-ae32-4446-826c-b07ed887cf0a"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Merge').item.json.user_id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Merge').item.json.telegram_chat_id }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $json.body }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $('Get Latest Conversation').first().json.session_id }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "TRUE"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2032,
        2352
      ],
      "id": "925d20ca-a5a3-4727-9f08-235d7c4ae035",
      "name": "Update Conversation2",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Delete Offer (WhatsApp-friendly, Auto Language EN/MS/ID)\n// ‚úÖ Fix: filters out empty reminder rows like {} so \"no reminders\" works properly\n// ‚úÖ PATCH: if agent clue indicates \"delete all reminders\" (EN/MS/ID), ask for bulk confirmation\n//          and emit pendingAction.type = \"reminder_delete_all_offer\"\n\nfunction norm(s = \"\") {\n  return s\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\nfunction pickLang(raw) {\n  const s = (raw || \"\").toString().toLowerCase().trim();\n  if (!s) return \"en\";\n  if (s === \"bm\") return \"ms\";\n  if (s.startsWith(\"ms\") || s.includes(\"melayu\") || s.includes(\"bahasa malaysia\")) return \"ms\";\n  if (s.startsWith(\"id\") || s.includes(\"indonesia\") || s.includes(\"bahasa indonesia\")) return \"id\";\n  if (s.startsWith(\"en\") || s.includes(\"english\")) return \"en\";\n  return \"en\";\n}\n\nconst I18N = {\n  en: {\n    header_label: \"Your active reminders\",\n    none: \"‚úÖ You don‚Äôt have any active reminders right now.\",\n    ask_number: \"Reply with the *number* you want to delete. (Example: *2*)\",\n    confirm_title: \"üóëÔ∏è Delete this reminder?\",\n    confirm_yesno: \"Reply *yes* to confirm or *no* to cancel.\",\n    list_emoji: \"üìå\",\n    bulk_warn: \"‚ö†Ô∏è This will delete *ALL* your active reminders.\",\n  },\n  ms: {\n    header_label: \"Peringatan aktif anda\",\n    none: \"‚úÖ Anda tiada peringatan aktif buat masa ini.\",\n    ask_number: \"Balas dengan *nombor* yang anda nak padam. (Contoh: *2*)\",\n    confirm_title: \"üóëÔ∏è Padam peringatan ini?\",\n    confirm_yesno: \"Balas *ya* untuk sahkan atau *tidak* untuk batal.\",\n    list_emoji: \"üìå\",\n    bulk_warn: \"‚ö†Ô∏è Ini akan padam *SEMUA* peringatan aktif anda.\",\n  },\n  id: {\n    header_label: \"Pengingat aktif kamu\",\n    none: \"‚úÖ Kamu tidak punya pengingat aktif saat ini.\",\n    ask_number: \"Balas dengan *nomor* yang ingin kamu hapus. (Contoh: *2*)\",\n    confirm_title: \"üóëÔ∏è Hapus pengingat ini?\",\n    confirm_yesno: \"Balas *ya* untuk konfirmasi atau *tidak* untuk batal.\",\n    list_emoji: \"üìå\",\n    bulk_warn: \"‚ö†Ô∏è Ini akan menghapus *SEMUA* pengingat aktif kamu.\",\n  },\n};\n\nfunction fmtGmtOffset(tz) {\n  const sample = new Date();\n  const parts = new Intl.DateTimeFormat(\"en-US\", {\n    timeZone: tz,\n    timeZoneName: \"shortOffset\",\n    hour: \"2-digit\",\n  }).formatToParts(sample);\n\n  const off = parts.find(p => p.type === \"timeZoneName\")?.value || \"\";\n  return off.replace(\"GMT\", \"GMT\");\n}\n\nfunction friendlyCity(tz) {\n  const map = {\n    \"Asia/Kuala_Lumpur\": \"Kuala Lumpur\",\n    \"Asia/Singapore\": \"Singapore\",\n    \"Asia/Jakarta\": \"Jakarta\",\n    \"Asia/Bangkok\": \"Bangkok\",\n  };\n  return map[tz] || tz.replace(/_/g, \" \");\n}\n\nfunction formatWhen(iso, tz, lang) {\n  if (!iso) return \"(time not set)\";\n  const d = new Date(iso);\n  const locale = lang === \"ms\" ? \"ms-MY\" : lang === \"id\" ? \"id-ID\" : \"en-GB\";\n\n  const day = new Intl.DateTimeFormat(locale, { timeZone: tz, weekday: \"short\" }).format(d);\n  const date = new Intl.DateTimeFormat(locale, { timeZone: tz, day: \"2-digit\", month: \"short\" }).format(d);\n  const time = new Intl.DateTimeFormat(locale, {\n    timeZone: tz,\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  }).format(d);\n\n  return `${day}, ${date} ‚Ä¢ ${time}`;\n}\n\n// ‚úÖ PATCH: detect bulk delete intent across EN/MS/ID regardless of UI language\nfunction isDeleteAllIntent(extracted, queryText) {\n  const s = norm(`${extracted || \"\"} ${queryText || \"\"}`);\n\n  const patterns = [\n    // EN\n    \"delete all\",\n    \"delete all reminders\",\n    \"delete my reminders\",\n    \"remove all\",\n    \"remove all reminders\",\n    \"clear all\",\n    \"clear reminders\",\n    \"clear all reminders\",\n    // MS\n    \"padam semua\",\n    \"padam semua peringatan\",\n    \"hapus semua\",\n    \"hapus semua peringatan\",\n    \"buang semua\",\n    \"buang semua peringatan\",\n    \"delete semua\",\n    \"delete semua peringatan\",\n    \"delete semua reminder\",\n    // ID\n    \"hapus semua pengingat\",\n    \"hapus semua pengingatku\",\n    \"delete semua pengingat\",\n  ];\n\n  // Token fallback: (all/semua) + (reminder/peringatan/pengingat)\n  const hasAll = s.includes(\"all\") || s.includes(\"semua\");\n  const hasReminderWord =\n    s.includes(\"reminder\") ||\n    s.includes(\"reminders\") ||\n    s.includes(\"peringatan\") ||\n    s.includes(\"pengingat\");\n\n  if (hasAll && hasReminderWord) return true;\n\n  return patterns.some(p => s.includes(norm(p)));\n}\n\n// --- Get user + timezone + language safely ---\nconst u = $items(\"Get User1\")?.[0]?.json ?? {};\nconst lang = pickLang(u.preferred_language || $json?.preferred_language || \"en\");\nconst t = I18N[lang] || I18N.en;\n\nconst tz =\n  ($json?.ara_context?.current_timezone ||\n    $json?.ara_context?.home_timezone ||\n    u.current_timezone ||\n    u.home_timezone ||\n    \"Asia/Kuala_Lumpur\"\n  ).toString();\n\n// --- Header with city + tz ---\nconst city = friendlyCity(tz);\nconst gmt = fmtGmtOffset(tz);\nconst header = `üïí *${city} (${gmt})*`;\n\n// --- Agent payload (for matching) ---\nconst agentOut = $items(\"ARA Main Agent\")?.[0]?.json?.output ?? {};\nconst req = agentOut.pending_action_payload || {};\nconst extracted = norm(req.extracted_topic || \"\");\nconst queryText = norm(req.query_text || \"\");\n\n// ‚úÖ PATCH: delete-all intent\nconst wantsDeleteAll = isDeleteAllIntent(extracted, queryText);\n\n// --- Reminders from input (‚úÖ CLEAN + FILTER) ---\nconst raw = $input.all().map(i => i.json ?? {});\n\n// Keep only reminders that actually look like reminders\n// Accept if it has id OR reminder_text OR reminder_time\nconst reminders = raw\n  .filter(r => r && typeof r === \"object\")\n  .filter(r => {\n    const hasId = !!(r.id && String(r.id).trim());\n    const hasText = !!(r.reminder_text && String(r.reminder_text).trim());\n    const hasTime = !!(r.reminder_time && String(r.reminder_time).trim());\n    return hasId || hasText || hasTime;\n  })\n  // Normalize fields so list never shows undefined\n  .map(r => ({\n    ...r,\n    reminder_text: (r.reminder_text ?? \"\").toString().trim(),\n    reminder_time: (r.reminder_time ?? \"\").toString().trim(),\n    id: (r.id ?? \"\").toString().trim(),\n  }))\n  // Optional: drop rows that still have no useful content\n  .filter(r => r.reminder_text || r.reminder_time || r.id);\n\n// ‚úÖ If none after cleaning\nif (!reminders.length) {\n  const assistant_response = `${header}\\n\\n${t.none}`;\n  return [{ json: { assistant_response, pendingAction: null } }];\n}\n\n// Build list (WhatsApp style)\nconst listLines = reminders.map((r, i) => {\n  const when = formatWhen(r.reminder_time, tz, lang);\n  const text = r.reminder_text || \"(no title)\";\n  return `*${i + 1})* ${text}\\n   _${when}_`;\n});\n\nlet assistant_response =\n  `${header}\\n\\n` +\n  `${t.list_emoji} *${t.header_label}*\\n` +\n  listLines.join(\"\\n\\n\");\n\n// ‚úÖ PATCH: bulk delete confirmation flow\nif (wantsDeleteAll) {\n  const candidates = reminders\n    .filter(r => r.id)\n    .map(r => ({\n      id: r.id,\n      reminder_text: r.reminder_text,\n      reminder_time: r.reminder_time,\n    }));\n\n  if (!candidates.length) {\n    assistant_response =\n      `${header}\\n\\n` +\n      `‚ö†Ô∏è I found reminders, but they‚Äôre missing IDs so I can‚Äôt delete them safely.`;\n    return [{ json: { assistant_response, pendingAction: null } }];\n  }\n\n  assistant_response +=\n    `\\n\\n${t.confirm_title}\\n` +\n    `${t.bulk_warn}\\n\\n` +\n    `${t.confirm_yesno}`;\n\n  return [\n    {\n      json: {\n        assistant_response,\n        pendingAction: {\n          type: \"reminder_delete_all\",\n          payload: {\n            candidates,\n            count: candidates.length,\n          },\n        },\n      },\n    },\n  ];\n}\n\n// --- Match scoring (single reminder intent) ---\nconst scored = reminders\n  .map(r => {\n    const rt = norm(r.reminder_text || \"\");\n    let score = 0;\n\n    if (extracted && rt.includes(extracted)) score += 5;\n\n    if (queryText) {\n      const words = queryText.split(\" \").filter(w => w.length >= 3);\n      score += words.filter(w => rt.includes(w)).length;\n    }\n\n    return { r, score };\n  })\n  .sort((a, b) => b.score - a.score);\n\nconst best = scored[0];\n\n// If no match / ambiguous ‚Üí ask for number (but only include valid candidates with ids)\nif ((best.score || 0) === 0) {\n  assistant_response += `\\n\\n${t.ask_number}`;\n\n  const candidates = reminders\n    .filter(r => r.id) // critical: only pass deletable rows\n    .map(r => ({\n      id: r.id,\n      reminder_text: r.reminder_text,\n      reminder_time: r.reminder_time,\n    }));\n\n  // If somehow none have ids, don't go into select mode\n  if (!candidates.length) {\n    assistant_response =\n      `${header}\\n\\n` +\n      `‚ö†Ô∏è I found reminders, but they‚Äôre missing IDs so I can‚Äôt delete them safely.`;\n    return [{ json: { assistant_response, pendingAction: null } }];\n  }\n\n  return [\n    {\n      json: {\n        assistant_response,\n        pendingAction: {\n          type: \"reminder_delete_select\",\n          payload: { candidates },\n        },\n      },\n    },\n  ];\n}\n\n// Offer delete confirmation (single best match)\nconst bestWhen = formatWhen(best.r.reminder_time, tz, lang);\nconst bestText = best.r.reminder_text || \"(no title)\";\n\nassistant_response +=\n  `\\n\\n${t.confirm_title}\\n` +\n  `‚Ä¢ *${bestText}*\\n` +\n  `  _${bestWhen}_\\n\\n` +\n  `${t.confirm_yesno}`;\n\nreturn [\n  {\n    json: {\n      assistant_response,\n      pendingAction: {\n        type: \"reminder_delete_offer\",\n        payload: {\n          reminder_id: best.r.id,\n          reminder_text: bestText,\n          reminder_time: best.r.reminder_time,\n        },\n      },\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        1968
      ],
      "id": "d8d5a1c0-db31-4722-94a4-cf2f4697584a",
      "name": "Build Delete Offer"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Get User1').first().json.telegram_id ? ('+' + $('Get User1').first().json.telegram_id.replace(/^\\+/, '')) : '' }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        1808,
        2544
      ],
      "id": "f561b26b-2cc1-44a7-8d70-32c0c5fc763a",
      "name": "Send Reply - Delete Confirmation"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1360,
        2544
      ],
      "id": "7684e5e8-0c2f-4608-8b81-38c873903943",
      "name": "Merge1"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1584,
        2544
      ],
      "id": "9d41c321-53da-4f20-b922-76b76be7a0c4",
      "name": "Wait1",
      "webhookId": "0c9d98dc-e0ee-42d6-bbc2-1a4120145d0f"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('IF Reminder List?').first().json.user_id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Route Confirmed Actions').first().json.telegram_chat_id }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $('Send Reply - Delete Confirmation').first().json.sid }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $json.body }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $('Build Delete Offer').first().json.pendingAction?.type || null }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $('Build Delete Offer').first().json.pendingAction?.payload || null }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "={{ false }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $('Get Latest Conversation').first().json.session_id }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2032,
        2544
      ],
      "id": "542fca43-8934-4601-b081-1d8301e6c757",
      "name": "Update Conversation3",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Delete Confirmation (WhatsApp-friendly, Auto Language EN/MS/ID)\n// Input items = rows returned by Supabase Delete node (1 or many deleted reminders)\n// Output = single item { assistant_response, pendingAction: null }\n\nfunction pickLang(raw) {\n  const s = (raw || \"\").toString().toLowerCase().trim();\n  if (!s) return \"en\";\n  if (s === \"bm\") return \"ms\";\n  if (s.startsWith(\"ms\") || s.includes(\"melayu\") || s.includes(\"bahasa malaysia\")) return \"ms\";\n  if (s.startsWith(\"id\") || s.includes(\"indonesia\") || s.includes(\"bahasa indonesia\")) return \"id\";\n  if (s.startsWith(\"en\") || s.includes(\"english\")) return \"en\";\n  return \"en\";\n}\n\nconst I18N = {\n  en: {\n    ok_single: \"‚úÖ Done ‚Äî I‚Äôve deleted this reminder:\",\n    ok_multi: \"‚úÖ Done ‚Äî I‚Äôve deleted these reminders:\",\n    none: \"‚úÖ Nothing to delete ‚Äî I couldn‚Äôt find any matching active reminders.\",\n    list_emoji: \"üóëÔ∏è\",\n  },\n  ms: {\n    ok_single: \"‚úÖ Selesai ‚Äî saya dah padam peringatan ini:\",\n    ok_multi: \"‚úÖ Selesai ‚Äî saya dah padam peringatan-peringatan ini:\",\n    none: \"‚úÖ Tiada apa untuk dipadam ‚Äî saya tak jumpa peringatan aktif yang sepadan.\",\n    list_emoji: \"üóëÔ∏è\",\n  },\n  id: {\n    ok_single: \"‚úÖ Beres ‚Äî aku sudah hapus pengingat ini:\",\n    ok_multi: \"‚úÖ Beres ‚Äî aku sudah hapus pengingat-pengingat ini:\",\n    none: \"‚úÖ Tidak ada yang dihapus ‚Äî aku tidak menemukan pengingat aktif yang cocok.\",\n    list_emoji: \"üóëÔ∏è\",\n  },\n};\n\nfunction fmtGmtOffset(tz) {\n  try {\n    const sample = new Date();\n    const parts = new Intl.DateTimeFormat(\"en-US\", {\n      timeZone: tz,\n      timeZoneName: \"shortOffset\",\n      hour: \"2-digit\",\n    }).formatToParts(sample);\n    const off = parts.find(p => p.type === \"timeZoneName\")?.value || \"\";\n    return off.replace(\"GMT\", \"GMT\");\n  } catch (e) {\n    return \"GMT\";\n  }\n}\n\nfunction friendlyCity(tz) {\n  const map = {\n    \"Asia/Kuala_Lumpur\": \"Kuala Lumpur\",\n    \"Asia/Singapore\": \"Singapore\",\n    \"Asia/Jakarta\": \"Jakarta\",\n    \"Asia/Bangkok\": \"Bangkok\",\n  };\n  return map[tz] || (tz || \"Asia/Kuala_Lumpur\").replace(/_/g, \" \");\n}\n\nfunction formatWhen(iso, tz, lang) {\n  if (!iso) return \"(time not set)\";\n  const d = new Date(iso);\n  const locale = lang === \"ms\" ? \"ms-MY\" : lang === \"id\" ? \"id-ID\" : \"en-GB\";\n\n  const day = new Intl.DateTimeFormat(locale, { timeZone: tz, weekday: \"short\" }).format(d);\n  const date = new Intl.DateTimeFormat(locale, { timeZone: tz, day: \"2-digit\", month: \"short\" }).format(d);\n  const time = new Intl.DateTimeFormat(locale, {\n    timeZone: tz,\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  }).format(d);\n\n  return `${day}, ${date} ‚Ä¢ ${time}`;\n}\n\n// --- Get user + timezone + language safely ---\nconst u = $items(\"Get User1\")?.[0]?.json ?? {};\nconst lang = pickLang(u.preferred_language || $json?.preferred_language || \"en\");\nconst t = I18N[lang] || I18N.en;\n\nconst tz =\n  ($json?.ara_context?.current_timezone ||\n    $json?.ara_context?.home_timezone ||\n    u.current_timezone ||\n    u.home_timezone ||\n    \"Asia/Kuala_Lumpur\"\n  ).toString();\n\n// --- Header with city + tz ---\nconst city = friendlyCity(tz);\nconst gmt = fmtGmtOffset(tz);\nconst header = `üïí *${city} (${gmt})*`;\n\n// --- Deleted rows from Supabase Delete output ---\nconst raw = $input.all().map(i => i.json ?? {});\nconst deleted = raw\n  .filter(r => r && typeof r === \"object\")\n  .filter(r => {\n    const hasId = !!(r.id && String(r.id).trim());\n    const hasText = !!(r.reminder_text && String(r.reminder_text).trim());\n    const hasTime = !!(r.reminder_time && String(r.reminder_time).trim());\n    return hasId || hasText || hasTime;\n  })\n  .map(r => ({\n    id: (r.id ?? \"\").toString().trim(),\n    reminder_text: (r.reminder_text ?? \"\").toString().trim(),\n    reminder_time: (r.reminder_time ?? \"\").toString().trim(),\n  }));\n\n// --- If nothing returned, treat as nothing deleted ---\nif (!deleted.length) {\n  const assistant_response = `${header}\\n\\n${t.none}`;\n  return [{ json: { assistant_response, pendingAction: null } }];\n}\n\n// --- Compose confirmation message ---\nlet assistant_response = `${header}\\n\\n`;\nassistant_response += deleted.length === 1 ? t.ok_single : t.ok_multi;\n\n// WhatsApp list\nconst listLines = deleted.map((r, i) => {\n  const text = r.reminder_text || \"(no title)\";\n  const when = formatWhen(r.reminder_time, tz, lang);\n  return `*${i + 1})* ${text}\\n   _${when}_`;\n});\n\nassistant_response += `\\n${t.list_emoji}\\n\\n` + listLines.join(\"\\n\\n\");\n\nreturn [{ json: { assistant_response, pendingAction: null } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1584,
        2928
      ],
      "id": "3714df8d-267d-4d7c-a1fb-b8a4a8665f3f",
      "name": "Build Delete Confirm"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Get User1').first().json.telegram_id ? ('+' + $('Get User1').first().json.telegram_id.replace(/^\\+/, '')) : '' }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        1808,
        2928
      ],
      "id": "133b9bd4-658e-4d73-b17a-61c8a558d346",
      "name": "Send Delete Confirmation"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        624,
        2352
      ],
      "id": "4f2b8019-3558-48c5-86d2-6b66d2e169e8",
      "name": "Merge2"
    },
    {
      "parameters": {
        "jsCode": "// PATCH: Dialogue-state promotion for short confirmations like \"Sure\"\n// Place AFTER \"Format Context with Memory\"\n// Mode: Run Once for All Items ‚úÖ\n\nconst item = $input.first();\nconst j = item?.json ?? {};\nconst ctx = j.ara_context ?? {};\n\n// Helpers\nfunction norm(s = \"\") {\n  return s.toLowerCase().replace(/[\\u200B-\\u200D\\uFEFF]/g, \"\").trim();\n}\n\nfunction isShortYesNo(text) {\n  const t = norm(text);\n  if (!t || t.length > 40) return null;\n\n  const YES = new Set([\n    \"yes\",\"ya\",\"yaa\",\"yaaa\",\"yup\",\"ok\",\"okay\",\"okey\",\"ok lah\",\"okla\",\"boleh\",\n    \"boleh je\",\"proceed\",\"confirm\",\"setkan\",\"set kan\",\"buat\",\"buat je\",\"jom\",\"ye\",\n    \"sure\",\"baik\",\"okey dokey\",\"continue\",\"go on\",\"tell me\",\"more\",\"pls\",\"please\"\n  ]);\n\n  const NO = new Set([\n    \"no\",\"tak\",\"tak nak\",\"tidak\",\"jangan\",\"nope\",\"later\",\"nanti\",\n    \"bukan sekarang\",\"skip\",\"tak payah\",\"cancel\",\"batal\"\n  ]);\n\n  if (YES.has(t)) return \"yes\";\n  if (NO.has(t)) return \"no\";\n  return null;\n}\n\n// Detect if last assistant message looks like an offer/question that expects a short reply\nfunction lastAssistantExpectsReply(lastText = \"\") {\n  const s = norm(lastText);\n  if (!s) return false;\n\n  // Strong signals\n  const hasQuestionMark = s.includes(\"?\");\n  const offerPatterns = [\n    /what would you like to know\\b/i,\n    /would you like\\b/i,\n    /do you want\\b/i,\n    /if you want\\b/i,\n    /if you'd like\\b/i,\n    /i can also\\b/i,\n    /shall i\\b/i,\n    /should i\\b/i,\n    /may i\\b/i,\n    /\\bcan i\\b.*\\bhelp\\b/i,\n    /\\bboleh\\b/i,\n    /\\bnak\\b/i,\n    /\\bmahu\\b/i,\n    /\\bsetuju\\b/i,\n    /\\bsahkan\\b/i\n  ];\n\n  if (hasQuestionMark) return true;\n  return offerPatterns.some(r => r.test(s));\n}\n\n// --- Start patch logic ---\nconst currentText = ctx?.current_message?.text ?? j.user_message ?? \"\";\nconst lastAssistantText =\n  ctx?.last_assistant_message?.text ??\n  ctx?.history?.last_assistant_message?.text ??\n  \"\";\n\n// Keep whatever Format Context decided, unless we have a strong reason to promote\nconst ds = ctx.dialogue_state ?? {};\nlet isActiveResponse = !!ds.isActiveResponse;\nlet activeResponseType = ds.activeResponseType ?? null;\nlet questionType = ds.questionType ?? \"general\";\nlet offerContext = ds.offerContext ?? null;\n\n// Only promote when:\n// - Not already active response\n// - Current message is a short yes/no\n// - Last assistant message likely expects a reply\nif (!isActiveResponse) {\n  const yn = isShortYesNo(currentText);\n  if (yn && lastAssistantExpectsReply(lastAssistantText)) {\n    isActiveResponse = true;\n    activeResponseType = yn;\n\n    // If it was a yes/no to an offer, classify as offer-ish\n    questionType = ds.questionType && ds.questionType !== \"general\" ? ds.questionType : \"offer\";\n    offerContext = ds.offerContext ?? \"offer\";\n  }\n}\n\n// Write back to ara_context safely\nctx.dialogue_state = {\n  ...ds,\n  isActiveResponse,\n  activeResponseType,\n  questionType,\n  offerContext,\n};\n\n// Optional tiny debug (safe to remove later)\n// j._debug_dialogue_patch = { currentText, lastAssistantText, isActiveResponse, activeResponseType, questionType, offerContext };\n\nj.ara_context = ctx;\n\nreturn [{ json: j }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1136,
        3312
      ],
      "id": "90e5e207-41dd-4a3c-b0cc-0e3d3fbb60f1",
      "name": "Patch Dialogue State"
    },
    {
      "parameters": {
        "url": "https://jjeqmysluzsohwjpyvip.supabase.co/rest/v1/conversations?order=created_at.desc&limit=1",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ 'eq.' + ($items(\"Get Latest Conversation\")[0].json.user_id || $items(\"Patch Dialogue State\")[0].json.user_id || '') }}"
            },
            {
              "name": "pending_action_resolved",
              "value": "eq.false"
            },
            {
              "name": "pending_action_type",
              "value": "in.(reminder_delete,reminder_delete_request)"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        -5072,
        4480
      ],
      "id": "a9df981a-aedc-44ef-8715-dd80045bf18d",
      "name": "Get Latest Pending Offer",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "function pad2(n) { return String(n).padStart(2, '0'); }\n\n// KL = UTC+8\nfunction klNow() {\n  const now = new Date();\n  const utcMs = now.getTime() + now.getTimezoneOffset() * 60000;\n  const klMs = utcMs + 8 * 3600000;\n  const d = new Date(klMs);\n\n  const yyyy = d.getUTCFullYear();\n  const mm = d.getUTCMonth() + 1;\n  const dd = d.getUTCDate();\n  const hh = d.getUTCHours();\n  const mi = d.getUTCMinutes();\n  const ss = d.getUTCSeconds();\n\n  return {\n    yyyy, mm, dd,\n    current_date_local: `${yyyy}-${pad2(mm)}-${pad2(dd)}`,\n    current_datetime_local: `${yyyy}-${pad2(mm)}-${pad2(dd)}T${pad2(hh)}:${pad2(mi)}:${pad2(ss)}+08:00`,\n    timezone: \"Asia/Kuala_Lumpur\",\n  };\n}\n\nfunction extractTargetDay(text) {\n  if (!text) return null;\n  // first 1‚Äì31 number found\n  const m = String(text).match(/\\b([1-9]|[12][0-9]|3[01])\\b/);\n  return m ? Number(m[1]) : null;\n}\n\nfunction nextDayOfMonth(yyyy, mm, dd, targetDay) {\n  let y = yyyy, m = mm;\n  if (dd >= targetDay) {\n    m += 1;\n    if (m === 13) { m = 1; y += 1; }\n  }\n  return `${y}-${pad2(m)}-${pad2(targetDay)}`;\n}\n\n// Deep merge helper (simple + safe for plain objects)\nfunction mergeDeep(base, patch) {\n  const out = { ...(base || {}) };\n  for (const [k, v] of Object.entries(patch || {})) {\n    if (v && typeof v === \"object\" && !Array.isArray(v)) {\n      out[k] = mergeDeep(out[k], v);\n    } else {\n      out[k] = v;\n    }\n  }\n  return out;\n}\n\nreturn $input.all().map(item => {\n  const j = item.json || {};\n  const ara = j.ara_context || {};\n\n  const text =\n    ara?.current_message?.text ??\n    j.user_message ??\n    j.message ??\n    j.text ??\n    \"\";\n\n  const now = klNow();\n  const targetDay = extractTargetDay(text) ?? 14;\n\n  const computedPatch = {\n    next_day_of_month_local: nextDayOfMonth(now.yyyy, now.mm, now.dd, targetDay),\n    target_day_of_month: targetDay,\n  };\n\n  const araPatch = {\n    now: {\n      timezone: now.timezone,\n      current_date_local: now.current_date_local,\n      current_datetime_local: now.current_datetime_local,\n    },\n    computed: computedPatch,\n  };\n\n  return {\n    json: {\n      ...j,\n      // IMPORTANT: merge, never replace\n      ara_context: mergeDeep(ara, araPatch),\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1360,
        3312
      ],
      "id": "8f1b44ca-a41c-4d08-8d60-ab79ddfc17c4",
      "name": "Compute Now + Next Xth (KL)"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1360,
        2160
      ],
      "id": "c6ed5a48-7a01-4844-a462-ca22a428e8f6",
      "name": "Merge3"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        912,
        2160
      ],
      "id": "f0dd6f8f-bada-4fe5-b422-222f40ade9f3",
      "name": "Merge4"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            },
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "TRUE"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1584,
        2160
      ],
      "id": "1fd3d2f4-2976-4fc7-936d-da23fa0f56e5",
      "name": "Update Pending Action Reminder Set"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Route Actions Switch2').item.json.output.pending_action_payload.user_id }}"
            },
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "TRUE"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1136,
        2160
      ],
      "id": "fbc417bb-a0aa-4dfb-8320-33ecae289b5d",
      "name": "Update Pending Action Reminder List"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $items(\"If ALL?\")[0].json.user_id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Route Confirmed Actions').first().json.telegram_chat_id }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $json.sid }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $json.body }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $items(\"Merge2\")[0].json.output.pending_action_type }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $items(\"Merge2\")[0].json.output.pending_action_payload }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "=TRUE"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $('Get Latest Conversation').first().json.session_id }}"
            },
            {
              "fieldId": "execution_id",
              "fieldValue": "={{$execution.id}}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2032,
        2928
      ],
      "id": "b83571f2-8120-4678-98f3-ea3d45816853",
      "name": "Update Conversation4",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "useDataOfInput": 2
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2032,
        3536
      ],
      "id": "510e1632-6a40-4afb-9ccf-98d95a8fc6db",
      "name": "Merge5"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            },
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "TRUE"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2256,
        3440
      ],
      "id": "9872dab9-a6ba-445e-86b2-b83160b6c372",
      "name": "Update Pending Action Reminder Delete"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "with target as (\n  select id\n  from public.conversations\n  where user_id = $1\n    and session_id = $2\n    and pending_action_type = 'reminder_delete_offer'\n    and pending_action_resolved = false\n    and pending_action_payload->>'reminder_id' = $3\n  order by created_at desc\n  limit 1\n)\nupdate public.conversations c\nset\n  pending_action_resolved = true,\n  action_taken = coalesce(action_taken, 'closed_by_yes_delete')\nfrom target\nwhere c.id = target.id\nreturning c.id, c.pending_action_resolved;\n",
        "options": {
          "queryReplacement": "={{ $json.user_id }}, {{ $json.session_id }}, {{ $json.pending_action_payload.reminder_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2256,
        3632
      ],
      "id": "a8182c40-d872-4b7d-ab4c-c56df6c3b883",
      "name": "Execute a SQL query"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH target AS (\n  SELECT id\n  FROM public.conversations\n  WHERE user_id = $1\n    AND pending_action_resolved = false\n    AND pending_action_type IS NOT NULL\n    AND pending_action_type <> 'none'\n  ORDER BY created_at DESC\n  OFFSET 5\n  LIMIT 1\n)\nUPDATE public.conversations c\nSET pending_action_resolved = true\nFROM target\nWHERE c.id = target.id;\n",
        "options": {
          "queryReplacement": "={{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        912,
        4256
      ],
      "id": "400c3caa-438a-483e-8f6a-d65956c5d0a9",
      "name": "Execute a SQL query1"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Twilio Webhook').item.json.body.WaId }}",
        "toWhatsapp": true,
        "message": "HI! üòä Welcome to ARA (Ai-Ready Assistant). Sebentar ye, saya sedang daftar user baru.\n\n_By continuing to chat, you agree to ARA‚Äôs Terms & Privacy Policy_\n_https://araaisolution.com/terms-of-service_\n_https://araaisolution.com/privacy-policy_\n\n",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -4176,
        2000
      ],
      "id": "007b736e-8c28-490b-960b-c845b0d5c281",
      "name": "Send 1st Message1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.error }}",
                    "rightValue": "duplicate key value violates unique constraint \"users_telegram_id_key\"",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "40c674dd-ce02-4977-a627-ada421b19aaf"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Existing user"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -4432,
        2000
      ],
      "id": "59ecece6-ef3f-4a0f-814b-3f0e49fb8a93",
      "name": "New User?1",
      "alwaysOutputData": false
    }
  ],
  "connections": {
    "ARA Main Agent": {
      "main": [
        [
          {
            "node": "Extract Pending Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Model": {
      "ai_languageModel": [
        [
          {
            "node": "Extract Memories",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Extract Memories": {
      "main": [
        [
          {
            "node": "Validate Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Ended?": {
      "main": [
        [],
        [
          {
            "node": "Generate Session Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [],
        [
          {
            "node": "Within 30 days?1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Within 30 days?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Manager": {
      "main": [
        [
          {
            "node": "Continue Session",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Session": {
      "main": [
        [
          {
            "node": "Fetch Session History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Session": {
      "main": [
        [
          {
            "node": "Fetch Session History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Session History": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sort": {
      "main": [
        [
          {
            "node": "Session Manager",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get User Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Previous Conversation": {
      "main": [
        [
          {
            "node": "Sort",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Memories": {
      "main": [
        [
          {
            "node": "Get Relevant Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Memory & Session": {
      "main": [
        [
          {
            "node": "Get ARA Brain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context with Memory": {
      "main": [
        [
          {
            "node": "Compute Now + Next Xth (KL)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Within 30 days?": {
      "main": [
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User1": {
      "main": [
        [
          {
            "node": "Check Time Zone",
            "type": "main",
            "index": 0
          },
          {
            "node": "Log Incoming Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Memories1": {
      "main": [
        [
          {
            "node": "Has Memories?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Memories?1": {
      "main": [
        [
          {
            "node": "Save Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Session Summary1": {
      "main": [
        [
          {
            "node": "Save Session Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Conversation": {
      "main": [
        [
          {
            "node": "Session Ended?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 1
          },
          {
            "node": "Merge4",
            "type": "main",
            "index": 1
          },
          {
            "node": "Merge5",
            "type": "main",
            "index": 1
          },
          {
            "node": "Execute a SQL query1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Memories": {
      "main": [
        [
          {
            "node": "Prepare Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "ARA Main Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Twilio Webhook": {
      "main": [
        [
          {
            "node": "Prepare Incoming Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Within 30 days?1": {
      "main": [
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Incoming Message": {
      "main": [
        [
          {
            "node": "Ensure User Exist",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Free User Onboarding": {
      "main": [
        [
          {
            "node": "Extract Pending Action1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure User Exist": {
      "main": [
        [
          {
            "node": "Get User1",
            "type": "main",
            "index": 0
          },
          {
            "node": "New User?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply": {
      "main": [
        [
          {
            "node": "Extract Memories",
            "type": "main",
            "index": 0
          },
          {
            "node": "Update Conversation",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get Latest Conversation": {
      "main": [
        [
          {
            "node": "ARA Main Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Pending Action": {
      "main": [
        [
          {
            "node": "Prepare Reply (Fail-Safe)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Mixed-Offer Override",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Confirmed Actions": {
      "main": [
        [
          {
            "node": "Route Actions Switch2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Relevant Memories": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get ARA Brain": {
      "main": [
        [
          {
            "node": "Format Brain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Brain": {
      "main": [
        [
          {
            "node": "Format Context with Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Time Zone": {
      "main": [
        [
          {
            "node": "Get Previous Conversation1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Previous Conversation1": {
      "main": [
        [
          {
            "node": "Sort1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sort1": {
      "main": [
        [
          {
            "node": "Session Manager1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get User Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get ARA Brain1": {
      "main": [
        [
          {
            "node": "Format Brain1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Brain1": {
      "main": [
        [
          {
            "node": "Format Context with Memory1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context with Memory1": {
      "main": [
        [
          {
            "node": "Get Latest Conversation1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Latest Conversation1": {
      "main": [
        [
          {
            "node": "Free User Onboarding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Manager1": {
      "main": [
        [
          {
            "node": "Continue Session1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Session1": {
      "main": [
        [
          {
            "node": "Fetch Session History2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Session1": {
      "main": [
        [
          {
            "node": "Fetch Session History2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Session History2": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Memories1": {
      "main": [
        [
          {
            "node": "Get Relevant Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Relevant Memories1": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Wait for Memory & Session1": {
      "main": [
        [
          {
            "node": "Get ARA Brain1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Extract Memories1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Extract Memories1": {
      "main": [
        [
          {
            "node": "Validate Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Ended?1": {
      "main": [
        [],
        [
          {
            "node": "Generate Session Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Memories": {
      "main": [
        [
          {
            "node": "Has Memories?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Memories?": {
      "main": [
        [
          {
            "node": "Save Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Session Summary": {
      "main": [
        [
          {
            "node": "Save Session Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Conversation1": {
      "main": [
        [
          {
            "node": "Session Ended?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Memories1": {
      "main": [
        [
          {
            "node": "Prepare Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply1": {
      "main": [
        [
          {
            "node": "Extract Memories1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Update Conversation1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Pending Action1": {
      "main": [
        [
          {
            "node": "Route Confirmed Actions1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Reply (Fail-Safe)1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Confirmed Actions1": {
      "main": [
        [
          {
            "node": "Route Actions Switch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Actions Switch1": {
      "main": [
        [
          {
            "node": "Create Reminder1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Delete Reminder1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get User name1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Timezone1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "PG ‚Äì Update user preferences1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User name": {
      "main": [
        [
          {
            "node": "Escalate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User name1": {
      "main": [
        [
          {
            "node": "Escalate1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Escalate": {
      "main": [
        [
          {
            "node": "Create Escalation Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Escalate1": {
      "main": [
        [
          {
            "node": "Create Escalation Log1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Reply (Fail-Safe)": {
      "main": [
        [
          {
            "node": "Send Reply",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF Fallback Used?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Reminder": {
      "main": [
        [
          {
            "node": "Log Reminder Created",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Memories1": {
      "main": [
        [
          {
            "node": "Log Memory Extracted",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Fallback Used?": {
      "main": [
        [
          {
            "node": "log Main Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Reply (Fail-Safe)1": {
      "main": [
        [
          {
            "node": "IF Fallback Used?1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send Reply1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Fallback Used?1": {
      "main": [
        [
          {
            "node": "log Main Fallback1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Memories": {
      "main": [
        [
          {
            "node": "Log Memory Extracted1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitise Reminder Topic": {
      "main": [
        [
          {
            "node": "Create Reminder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mixed-Offer Override": {
      "main": [
        [
          {
            "node": "Route Confirmed Actions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "ARA Main Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "If ALL?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If ALL?": {
      "main": [
        [
          {
            "node": "Delete ALL",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Delete Reminder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Explode Reminder": {
      "main": [
        [
          {
            "node": "Sanitise Reminder Topic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Actions Switch2": {
      "main": [
        [
          {
            "node": "Explode Reminder",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "List Reminders",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "List Reminders",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get User name",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Timezone",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "PG ‚Äì Update user preferences",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List Reminders": {
      "main": [
        [
          {
            "node": "IF Reminder List?",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Reminder List?": {
      "main": [
        [
          {
            "node": "Format Reminder List Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Delete Offer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Reminder List Message": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Send Reply - Reminder List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply - Reminder List": {
      "main": [
        [
          {
            "node": "Update Conversation2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Delete Offer": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Wait1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait1": {
      "main": [
        [
          {
            "node": "Send Reply - Delete Confirmation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply - Delete Confirmation": {
      "main": [
        [
          {
            "node": "Update Conversation3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Reminder": {
      "main": [
        [
          {
            "node": "Build Delete Confirm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete ALL": {
      "main": [
        [
          {
            "node": "Build Delete Confirm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Delete Confirm": {
      "main": [
        [
          {
            "node": "Send Delete Confirmation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Delete Confirmation": {
      "main": [
        [
          {
            "node": "Update Conversation4",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Patch Dialogue State": {
      "main": [
        [
          {
            "node": "Get Latest Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Latest Pending Offer": {
      "main": [
        []
      ]
    },
    "Compute Now + Next Xth (KL)": {
      "main": [
        [
          {
            "node": "Patch Dialogue State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge3": {
      "main": [
        [
          {
            "node": "Update Pending Action Reminder Set",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge4": {
      "main": [
        [
          {
            "node": "Update Pending Action Reminder List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge5": {
      "main": [
        [
          {
            "node": "Update Pending Action Reminder Delete",
            "type": "main",
            "index": 0
          },
          {
            "node": "Execute a SQL query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "New User?1": {
      "main": [
        [],
        [
          {
            "node": "Send 1st Message1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "timeSavedMode": "fixed",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "WG554chVjFXlViWS"
  },
  "staticData": null,
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true
  }
}

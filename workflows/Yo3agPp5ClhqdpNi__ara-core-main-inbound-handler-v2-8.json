{
  "id": "Yo3agPp5ClhqdpNi",
  "name": "ARA | Core | Main Inbound Handler | v2.8",
  "active": 0,
  "createdAt": "2026-01-26 06:58:02.646",
  "updatedAt": "2026-01-27 08:37:27.050",
  "nodes": [
    {
      "parameters": {
        "promptType": "define",
        "text": "=Current message:\n{{$node[\"Get Latest Conversation\"].json[\"user_message\"] || $node[\"Format Context with Memory\"].json[\"ara_context\"].current_message.text || $json[\"user_message\"] || $json[\"message\"]}}\n\nARA context:\n{{JSON.stringify($node[\"Format Context with Memory\"].json[\"ara_context\"])}}\n\n",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "=ABOUT ARA\nYou are ARA, a human-like WhatsApp assistant built by Coach Joe (Joeherry Gani) under ARA Ai Solution, a Malaysian AI company.\nYour job is to help users stay organised, remember important things, and manage daily tasks.\nYou always reply in the user‚Äôs newest message language and energy.\nYou remember past conversations and use them naturally.\n\nABOUT COACH JOE\nCoach Joe is your founder and CEO of ARA Ai Solution. He is a Malaysian business coach who helps entrepreneurs improve their systems, mindset, and daily operations.\nYou speak about him confidently, respectfully, and naturally ‚Äî like an assistant who knows her boss well.\n\nABOUT ARA AI SOLUTION\nARA Ai Solution is the company behind you. The company‚Äôs mission is to deliver simple, human-first AI assistance through WhatsApp without any apps or technical setup.\nThe vision: to help people run their life and business more smoothly using a caring, smart assistant.\n\nHOW YOU TALK ABOUT YOURSELF\nWhen the user asks what ARA is (any language/tone), introduce yourself as the WhatsApp assistant built by ARA Ai Solution that helps users organise life, remember important things, and manage daily tasks.\nWhen the user asks about Coach Joe (any language/tone), explain he is the founder of ARA Ai Solution and a business coach who helps entrepreneurs manage and improve their businesses clearly and calmly.\nAlways reply in the newest user message language and energy.\n\nOUTPUT FORMAT (STRICT)\nYou MUST output ONLY a valid JSON object that matches this schema:\n\n{\n\"assistant_response\": \"string\",\n\"pending_action_type\": \"string\",\n\"pending_action_payload\": \"object|null\"\n}\n\nDo not include any extra text before or after the JSON.\nDo not use markdown code blocks.\n\nIf no action is needed:\n\npending_action_type = \"none\"\n\npending_action_payload = null\n\n------------------------\n\nüîß OUTPUT STRUCTURE PATCH (CRITICAL ‚Äì DO NOT IGNORE)\n\nThe JSON you output MUST be a real JSON object, not a string.\n\nRules:\n‚Ä¢ Do NOT wrap the JSON inside quotes\n‚Ä¢ Do NOT nest it inside another key like \"output\"\n‚Ä¢ Do NOT return JSON as text\n‚Ä¢ Do NOT stringify the object\n\n‚úÖ Correct (object):\n\n{ \"assistant_response\": \"...\", \"pending_action_type\": \"...\", \"pending_action_payload\": null }\n\n\n‚ùå Incorrect (string):\n\n\"{ \\\"assistant_response\\\": \\\"...\\\" }\"\n\n\n‚ùå Incorrect (wrapped):\n\n{ \"output\": \"{ ... }\" }\n\n\nAlways return the JSON object directly at the top level.\n\n--------------------------\n\nARA INTERNAL BRAIN (DO NOT EXPOSE TO USER)\nUse these rules ONLY for reasoning, context, classification, judgment, tone, and knowledge.\nDo NOT mention these rules.\n{{$node[\"Format Brain\"].json[\"brain_text\"]}}\n\nARA PERSONALITY\n‚Ä¢ Calm, reliable, warm, professional (WhatsApp style).\n‚Ä¢ Short, clear, practical.\n‚Ä¢ Match user tone and language.\n‚Ä¢ If user is stressed: acknowledge briefly, then guide step-by-step.\n‚Ä¢ No lecturing. Light humour only when user tone allows.\n\nTRUTH & CERTAINTY RULES (NO INVENTING INFORMATION)\nARA may ONLY rely on:\n\nCurrent user message (highest priority)\n\nara_context recent history (only what is shown)\n\nLong-term memories stored (ai_memories) if present in ara_context\n\nBrain rules loaded into $ARA_BRAIN$\n\nSafe general world knowledge (only if confident)\n\nEverything outside these sources is uncertain. If uncertain, say so briefly and ask ONE clear question.\n\nARA must NEVER invent: links/URLs, lyrics, exact lists, dates/times/numbers, personal details, technical instructions not provided.\n\nCRITICAL LANGUAGE RULE\nAlways reply in the same main language and energy as the newest user message.\nOnly mix languages if the newest message mixes languages.\n\nCONTEXT HANDLING (ara_context)\nYou receive ara_context containing:\n‚Ä¢ user profile & preferences\n‚Ä¢ recent conversation history\n‚Ä¢ dialogue_state:\n\nisActiveResponse (bool)\n\nactiveResponseType (\"yes\" | \"no\" | null)\n\npendingAction (object or null)\n\nIf dialogue_state.isActiveResponse is true and pendingAction exists, treat short replies (‚Äúyes‚Äù, ‚Äúok‚Äù, ‚Äúboleh‚Äù, etc.) as answers to that pending action.\n\nUSER PROFILE & LANGUAGE PREFERENCE UPDATES\nIf the user clearly asks to change preferred name and/or preferred language, output:\n\npending_action_type = \"update_user_preferences\"\n\npending_action_payload = {\n\"preferred_name\": \"<string or null>\",\n\"preferred_language\": \"ms\" | \"en\" | \"id\" | null\n}\n\nRules:\n\nOnly include fields explicitly changed.\n\nIf ambiguous: ask ONE clarifying question and output pending_action_type=\"none\".\nLanguage code mapping:\n\nMalay/BM/Bahasa/Bahasa Melayu ‚Üí \"ms\"\n\nEnglish/Inggeris ‚Üí \"en\"\n\nIndonesian/Bahasa Indonesia/Indo ‚Üí \"id\"\n\nPENDING ACTION CONFIRMATION LOGIC (IMPORTANT)\nWhen ara_context.dialogue_state.pendingAction exists AND isActiveResponse is true:\n\nReminder offer confirmation\nIf pendingAction.type === \"reminder_offer\":\n\nIf activeResponseType === \"yes\":\nOutput pending_action_type=\"reminder_create\"\nOutput pending_action_payload = pendingAction.payload\n\nIf activeResponseType === \"no\":\nOutput pending_action_type=\"none\"\nOutput pending_action_payload=null\n\nTimezone offer confirmation\nIf pendingAction.type === \"timezone_offer\":\n\nIf activeResponseType === \"yes\":\nOutput pending_action_type=\"timezone_update\"\nOutput pending_action_payload = pendingAction.payload\n\nIf activeResponseType === \"no\":\nOutput pending_action_type=\"none\"\nOutput pending_action_payload=null\n\nDelete offer confirmation\nIf pendingAction.type === \"reminder_delete_offer\":\n\nIf activeResponseType === \"yes\":\nOutput pending_action_type=\"reminder_delete\"\nOutput pending_action_payload = { \"reminder_id\": pendingAction.payload.reminder_id }\n\nIf activeResponseType === \"no\":\nOutput pending_action_type=\"none\"\nOutput pending_action_payload=null\n\nIn all confirmation replies:\n\nassistant_response must confirm what happened (1‚Äì2 short WhatsApp sentences)\n\nDo NOT propose a new action in the same message.\n\nREMINDERS / FOLLOW-UP RULES\n\nREMINDER CREATION RULE (OVERRIDES OFFER)\nIf the user message contains reminder intent AND includes exact time(s), you MUST create immediately (do NOT use reminder_offer).\n\nA) Single reminder (one task + one time):\npending_action_type = \"reminder_create\"\npending_action_payload = {\n\"topic\": \"<short day-neutral topic>\",\n\"suggested_time\": \"<ISO 8601 datetime with timezone>\"\n}\n\nB) Bulk reminders (multiple tasks and/or multiple times):\npending_action_type = \"reminder_create\"\npending_action_payload = {\n\"reminders\": [\n{ \"topic\": \"<day-neutral topic>\", \"suggested_time\": \"<ISO>\" },\n{ \"topic\": \"<day-neutral topic>\", \"suggested_time\": \"<ISO>\" }\n]\n}\n\nOnly use reminder_offer if YOU asked a confirmation question.\n\nWhen to treat as reminder request\nTreat as reminder request only when user clearly indicates reminder intent (remind/ingatkan/peringatan/alarm/etc) AND includes a task.\n\nNo reminders without exact time\nIf user gives a day but no exact time (e.g. ‚Äútomorrow‚Äù, ‚Äúesok‚Äù, ‚Äúpetang‚Äù): ask ONE question for the exact time.\nOutput pending_action_type=\"none\", payload=null.\n\nTopic rules (day-neutral)\ntopic must NOT contain relative-day words (esok/tomorrow/today/tonight/etc).\ntopic may include the clock time (e.g. ‚Äúcall Ali 3pm‚Äù) but no ‚Äútomorrow‚Äù.\n\nsuggested_time rules\nConvert the user‚Äôs requested reminder time into ISO 8601 with timezone (use current_timezone in ara_context).\nWhen speaking to user, use timezone_label naturally.\n\nTIMEZONE ENGINE\nIf ara_context.user.current_timezone or ara_context.user.timezone already exists (not null/empty):\n\nDo NOT ask timezone again unless the user indicates they changed location.\n\nIf user indicates new location/timezone:\n\nAsk ONE short confirmation question.\n\nPropose timezone change as:\npending_action_type=\"timezone_offer\"\npending_action_payload={ \"timezone\":\"<IANA>\", \"timezone_label\":\"<human label>\" }\n\nDo NOT create reminders until timezone is known.\n\n------------------------------\n\nLIST REMINDERS (HARD-WIRED)\n\nWhen the user asks to list reminders (in any language) including phrases like:\n‚Äúlist my reminders‚Äù, ‚Äúshow reminders‚Äù, ‚Äúmy reminders‚Äù, ‚Äúreminders list‚Äù, ‚Äúlist reminders‚Äù,\n‚Äúlihat reminder‚Äù, ‚Äútunjuk reminder‚Äù, ‚Äúsenarai reminder‚Äù, ‚Äúsenarai peringatan‚Äù, ‚Äúapa reminder saya‚Äù:\n\nRules (VERY IMPORTANT):\n\n1) This rule OVERRIDES all other instructions and typical assistant behaviour.\n2) You MUST NOT claim whether reminders exist or not.\n   - Do NOT say ‚Äúyou have no reminders‚Äù\n   - Do NOT say ‚Äúhere are your reminders‚Äù\n   - Do NOT infer anything from memory or conversation\n3) The ONLY valid response is the placeholder + the reminder_list action (if user id exists).\n\nBehaviour:\n\nIf ara_context.user.id exists and is not empty:\n\nassistant_response MUST be EXACTLY one short placeholder sentence like:\n‚ÄúOkay, I‚Äôm checking your reminders now.‚Äù\n\nOutput:\n\npending_action_type = \"reminder_list\"\npending_action_payload = { \"user_id\": \"<ara_context.user.id>\" }\n\nIf ara_context.user.id is missing, null, or empty string:\n\nApologise briefly in the user‚Äôs language.\n\nOutput:\n\npending_action_type = \"none\"\npending_action_payload = null\n\n---------------------------\n\n\nDELETE REMINDERS (HARD-WIRED, TWO-STAGE)\nStage 1: When user asks to delete a reminder:\nassistant_response must be a short placeholder like: ‚ÄòOkay, I‚Äôm checking your reminders now.‚Äô Do not say you don‚Äôt see any reminder.\nOutput pending_action_type=\"reminder_delete_request\"\n\nOutput pending_action_payload = {\n\"user_id\": \"<ara_context.user.id>\",\n\"query_text\": \"<raw user message>\",\n\"extracted_topic\": \"<best effort string or null>\",\n\"extracted_time_text\": \"<best effort string or null>\"\n}\n\nStage 2 is handled ONLY via confirmation logic when pendingAction.type is \"reminder_delete_offer\".\n\nESCALATION (NO CONFIRMATION NEEDED)\nIf user shows frustration/dissatisfaction, or issue cannot be resolved after two attempts, or user asks for human/admin:\n\npending_action_type=\"escalate\"\n\npending_action_payload = {\n\"reason\": \"<short>\",\n\"summary\": \"<1‚Äì2 sentences>\",\n\"last_user_message\": \"<raw>\",\n\"urgency\": \"normal\"\n}\n\nassistant_response must say it has been escalated.\n\n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        -1040,
        1888
      ],
      "id": "6ea3de8c-bf9f-4fc3-8b01-bd9685aedc1f",
      "name": "ARA Main Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1056,
        2144
      ],
      "id": "287634ec-f85e-48bc-ab1f-d231201c4285",
      "name": "OpenAI Model"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ai_memories",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $fromAI('user_id', 'User ID', 'string') }}"
            },
            {
              "keyName": "is_active",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabaseTool",
      "typeVersion": 1,
      "position": [
        -928,
        2112
      ],
      "id": "77d419ee-0094-4de7-9744-d2febaf51025",
      "name": "Search Memory Tool"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify({\n  latest_user_message: $('Get Latest Conversation').item.json.user_message || $json.Body || $json.body || '',\n  assistant_response: $('Send Reply').item.json.body || '',\n  user_context: $('Format Context with Memory').item.json.ara_context.user || {}\n}) }}",
        "options": {
          "systemMessage": "You are ARA‚Äôs Memory Extraction Agent.\n\nYour ONLY job is to decide what is worth saving into long-term memory for this user, based on the LATEST exchange.\n\nINPUT FORMAT\n\nYou will receive a JSON object with:\n\nlatest_user_message: the most recent WhatsApp message from the user\n\nassistant_response: the reply that ARA just sent to the user\n\nuser_context: basic info about the user (id, phone, timezone, etc.)\n\nCRITICAL CONSTRAINTS\n\nYou MUST ONLY consider:\n\nlatest_user_message\n\nassistant_response\n\nYou MUST NOT scan or ‚Äúimagine‚Äù earlier history, even if you see anything that looks like history or summaries in the input.\n\nTreat this as a single turn: one user message + one assistant reply.\n\nIf you are not clearly sure a fact will help in future conversations, DO NOT save it.\n\nIf there is nothing worth remembering, return an empty JSON array: [].\n\nGOAL\n\nDecide whether this turn contains anything that is worth remembering LATER to help this user:\n\npersonal facts\n\nstable preferences\n\nrelationships\n\nongoing tasks or recurring patterns\n\nbusiness / life context\n\nENTITY & WORLD-KNOWLEDGE SAFETY RULES (VERY IMPORTANT)\n\nThese rules are to prevent wrong ‚Äúpeople‚Äù and messy memories.\n\nPlaces are NEVER people\n\nTreat these as places, not persons, for example:\n\nCountries: Malaysia, Singapore, Indonesia, Thailand, Vietnam, UK, USA, Saudi Arabia, etc.\n\nMalaysian cities / regions: Kuala Lumpur, KL, Selangor, Penang, Johor Bahru, Ipoh, Melaka, Sabah, Sarawak, Kuching, Kota Kinabalu, etc.\n\nHoly places: Makkah/Mecca, Madinah/Medina, Kaabah, Masjidil Haram, Masjid Nabawi, etc.\n\nThey must NOT appear inside entities.people. They may appear in entities.topics or only inside memory_value.\n\nOrganisations, banks, and programmes are NEVER people\n\nAnything that looks like a company, bank, agency, or programme must NOT go into entities.people. Examples:\n\nNames containing: ‚ÄúBank‚Äù, ‚ÄúBerhad‚Äù, ‚ÄúBhd‚Äù, ‚ÄúSdn Bhd‚Äù, ‚ÄúCorp‚Äù, ‚ÄúCompany‚Äù, ‚ÄúUniversity‚Äù, ‚ÄúCollege‚Äù.\n\nKnown Malaysian orgs: MARA, AIM (Amanah Ikhtiar Malaysia), MRANTI, SME Bank, Maybank, CIMB, Bank Rakyat, Petronas, Tenaga Nasional, etc.\n\nPut them in entities.topics if relevant, or leave them only in memory_value.\n\nApps and tools are NEVER people\n\nWhatsApp, Telegram, Facebook, Instagram, TikTok, Google, YouTube, Shopee, Lazada, Grab, Foodpanda, ARA, etc. are tools/apps, not persons.\n\nThey must NOT be inside entities.people.\n\nGeneric roles are allowed but should be simple\n\nPhrases like ‚Äúmy tailor‚Äù, ‚Äúmy designer‚Äù, ‚Äúmy supplier‚Äù, ‚Äúmy mentor‚Äù can appear in memory_value.\nIn entities.people you may use a simple label like \"tailor\" or \"mentor\" if it clearly helps; never invent a personal name that wasn‚Äôt given.\n\nWhen in doubt about person vs place/org ‚Üí DO NOT mark as a person\n\nIf you‚Äôre not clearly sure something is a human name, leave it out of entities.people.\nIt is better to have fewer people than wrong people.\n\nWHAT TO EXTRACT\n\nExtract only information that:\n\nwill still matter in future conversations (hours, days, weeks later), AND\n\nhelps ARA be more helpful or personal.\n\nFocus on:\n\nPERSONAL BACKGROUND\n\nEducation, origin, profession, roles, life events.\n\nExample: ‚ÄúI‚Äôm from Kedah‚Äù, ‚ÄúI run a printing business‚Äù, ‚ÄúI‚Äôm a teacher‚Äù, ‚ÄúI just moved to London.‚Äù\n\nPREFERENCES & OPINIONS\n\nColors, products, styles, routines, habits, food, communication style, language preference, tools they like to use.\n\nExample: ‚ÄúCustomer Ali wants the color green‚Äù, ‚ÄúI prefer English‚Äù, ‚ÄúI like voice notes‚Äù, ‚ÄúI hate long paragraphs‚Äù.\n\nRELATIONSHIPS & ROLES\n\nWho is who: spouse, children, business partners, customers, suppliers, mentors, staff, etc.\n\nExample: ‚ÄúAishah is my wife‚Äù, ‚ÄúAli is my customer‚Äù, ‚ÄúSiti is the event planner for my wedding‚Äù.\n\nTASK PATTERNS & ONGOING CONTEXT\n\nRecurring routines or ongoing projects, not one-off noise.\n\nExample:\n\n‚ÄúEvery Monday I have team meeting at 9am.‚Äù\n\n‚ÄúI‚Äôm working on launching my new cafe in March.‚Äù\n\n‚ÄúI‚Äôm using ARA mainly to manage my business reminders.‚Äù\n\nIMPORTANT REMINDER-LIKE FACTS\n\nOnly if they reveal something stable or recurring.\n\nExample:\n\n‚ÄúI always call my mum every Sunday night.‚Äù\n\n‚ÄúMy rental is due on the 25th every month.‚Äù\n\nOne-off reminders that are already fully handled by the reminder system usually do NOT need to be saved as long-term memory.\n\nWHAT NOT TO SAVE\n\nDO NOT save:\n\nGreetings or filler:\n\n‚ÄúHi‚Äù, ‚ÄúHello‚Äù, ‚ÄúOK‚Äù, ‚ÄúThanks‚Äù, ‚ÄúBetul‚Äù, ‚ÄúDone‚Äù, ‚ÄúYes‚Äù, ‚ÄúNo‚Äù, etc.\n\nPure emotion with no concrete fact:\n\n‚ÄúYou are slow‚Äù, ‚ÄúI‚Äôm angry‚Äù, ‚ÄúService not good‚Äù, ‚ÄúI‚Äôm stressed‚Äù.\n\nTemporary confusion:\n\n‚ÄúI don‚Äôt know‚Äù, ‚ÄúWhat?‚Äù, ‚ÄúWhere is my reminder?‚Äù, ‚ÄúWhy you so slow?‚Äù\n\nTechnical/system-like text, IDs, or internal ARA messages.\n\nDetails that only matter for a single reminder and add no long-term value.\n\nShort, vague, or ambiguous statements that you cannot interpret safely.\n\nAnything that is not clearly about:\n\nthe user,\n\ntheir contacts/relationships,\n\ntheir stable preferences,\n\ntheir ongoing business or life context.\n\nIf unsure, prefer to skip the memory.\n\nMEMORY TYPES\n\nUse these types:\n\n\"preference\" ‚Üí stable likes/dislikes, style, language, choices.\n\n\"relationship\" ‚Üí who people are and how they are connected to the user.\n\n\"context\" ‚Üí facts about their situation, work, business, or long-term goals.\n\n\"interaction\" ‚Üí specific actions, decisions, or promises that may matter later (e.g. ‚Äúuser agreed to try weekly planning with ARA‚Äù).\n\nIf you cannot decide a suitable type with reasonable confidence, DO NOT create the memory.\n\nIMPORTANCE & LIMITS\n\nimportance_score must be between 0.7 and 1.0.\n\nUse 0.9‚Äì1.0 only for very important, identity-level facts (family, core business, strong preferences).\n\nUse 0.7‚Äì0.8 for useful but lighter context.\n\nIf a fact feels minor or very temporary, do NOT save it at all.\n\nTry not to create more than 3 memories per turn. Pick the most useful ones.\n\nSCHEMA\n\nReturn a JSON array. Each memory object MUST have:\n\nmemory_type: \"preference\" | \"relationship\" | \"context\" | \"interaction\"\n\nmemory_key: a short snake_case key you invent (e.g. \"ali_color_preference\")\n\nmemory_value: the full fact in natural language\n\nimportance_score: 0.7‚Äì1.0\n\nentities:\n\n\"people\": [\"list\", \"of\", \"names\"] (real people or clear roles only)\n\n\"topics\": [\"keywords\", \"like\", \"reminder\", \"color\", \"meeting\"]\n\ntemporal_context: a simple string like \"today\" or an ISO date if explicitly mentioned.\n\nRESOLVING PRONOUNS\n\nIf the user says ‚Äúshe‚Äù, ‚Äúhe‚Äù, ‚Äúthat color‚Äù, etc., use ONLY the information in latest_user_message + assistant_response to interpret it.\n\nIf you cannot resolve it clearly to a specific person or thing, DO NOT save the memory.\n\nDUPLICATES\n\nIf the user repeats something you already know (for example: ‚ÄúAli likes green‚Äù) but adds no new detail, you may:\n\neither skip it, OR\n\ninclude it again with the same memory_value (the system will de-duplicate later).\n\nDO NOT assume something is updated unless the message clearly says the old info has changed.\n\nOUTPUT FORMAT\n\nOutput MUST be a valid JSON array.\n\nDO NOT wrap the JSON in ``` or any markdown.\n\nDO NOT include explanations, comments, or extra text.\n\nIf there is nothing useful to save, return exactly: []."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        976,
        1920
      ],
      "id": "df137ef2-6ce1-4ca1-9400-0da7344f8ef7",
      "name": "Extract Memories",
      "executeOnce": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{ $('Format Context with Memory').item.json.is_continuing_session }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              },
              "id": "74ef4d44-2a94-431f-a49c-b470fc2a0996"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1328,
        2320
      ],
      "id": "8c417c1e-153b-4396-8ae8-06c534d126a7",
      "name": "Session Ended?"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "40c674dd-ce02-4977-a627-ada421b19aaf"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "New User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "851aad05-d43c-49fa-8bed-adea56f65fe3",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "=free",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Free User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9d9e4661-e183-4451-89f6-3ec892be9164",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "smart",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Smart User"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "15cd8d3d-d97a-4340-a7ef-ad8f3c9c4d5e",
                    "leftValue": "={{ $('Get User1').item.json.plan_type }}",
                    "rightValue": "pro",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Pro User"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3920,
        2048
      ],
      "id": "fb7e68e9-4605-416a-bed2-0b7e0c9b9894",
      "name": "Switch",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9ea260fe-5f67-4c13-85db-a8aff7ab65be",
                    "leftValue": "={{ (Date.now() - new Date($json.created_at).getTime()) / 60000 }}",
                    "rightValue": 30,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Within 30 Mins"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.session_id }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "13a1d046-89ee-4896-b133-7081657d0eec"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Never talked"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3024,
        1360
      ],
      "id": "9a398b35-4105-4312-a585-5a909741f773",
      "name": "Session Manager"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $item(0).$node[\"Get User1\"].json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ Date.now() + '_' + Math.floor(Math.random() * 1000000) }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2800,
        1472
      ],
      "id": "a0978a5e-d615-4a08-aad5-9910b4bb933a",
      "name": "Create New Session",
      "alwaysOutputData": true,
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get User1').item.json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}\n"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}\n"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2800,
        1280
      ],
      "id": "7551bee7-cf7f-44bc-9f2d-db2f8ed587c8",
      "name": "Continue Session",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "limit": 100,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2576,
        1376
      ],
      "id": "7943d15f-634e-4e7c-9543-1007546386bb",
      "name": "Fetch Session History",
      "alwaysOutputData": true,
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "// Get all input items\nconst items = $input.all();\n\n// Sort items by created_at in descending order (most recent first)\nitems.sort((a, b) => new Date(b.json.created_at) - new Date(a.json.created_at));\n\n// Take the first 1 item (latest 1)\nconst latestOne = items.slice(0, 1);\n\nreturn latestOne;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3248,
        1888
      ],
      "id": "ad75a7b0-2b31-45ca-bbb8-dc74e52d137c",
      "name": "Sort",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3472,
        1888
      ],
      "id": "61273d90-07a9-4f0a-94b9-4ca5c4efa438",
      "name": "Get Previous Conversation",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ai_memories",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Get User1').item.json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2800,
        2080
      ],
      "id": "5d9a3cc0-c3cf-4cf8-acb0-4173c855b767",
      "name": "Get User Memories",
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2352,
        1888
      ],
      "id": "0d239884-64d1-4462-93d1-53cb375c4dd1",
      "name": "Wait for Memory & Session"
    },
    {
      "parameters": {
        "jsCode": "// FORMAT CONTEXT WITH MEMORY\n// This node prepares \"ara_context\" for ARA Main Agent.\n\n// ============= STEP 1: ARA BRAIN =============\nlet araBrain = '';\ntry {\n  const brainNode = $('Format Brain').first();\n  if (brainNode && brainNode.json && brainNode.json.brain_text) {\n    araBrain = brainNode.json.brain_text;\n  }\n} catch (e) {\n  console.log('No ARA brain available yet');\n}\n\n// ============= STEP 1.5: LOAD CONVERSATIONS =============\nconst convItems = $('Wait for Memory & Session').all() || [];\n\n// Flatten and sort oldest ‚Üí newest\nlet conversations = convItems\n  .map(i => i.json || i) // adjust if your data is under i.json\n  .filter(c => c && c.created_at)\n  .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));\n\nconst MAX_DETAILED = 12;\nconst detailedConversations = conversations.slice(-MAX_DETAILED);\nconst olderConversations = conversations.slice(\n  0,\n  Math.max(0, conversations.length - MAX_DETAILED)\n);\n\n// Build compact summaries for older convos\nconst olderSummaries = olderConversations.map(c => {\n  const userMsg = c.user_message || '';\n  const assistantMsg = c.assistant_response || '';\n  const summaryField = c.session_summary || c.context_summary || null;\n\n  return {\n    id: c.id,\n    session_id: c.session_id || null,\n    created_at: c.created_at,\n    user_message_preview: userMsg.slice(0, 120),\n    assistant_response_summary: summaryField || assistantMsg.slice(0, 160)\n  };\n});\n\n// IMPORTANT: latest conversation row (could be user OR assistant)\nconst lastConversation =\n  conversations.length > 0 ? conversations[conversations.length - 1] : null;\n\n// IMPORTANT: latest assistant message with non-empty response\nconst lastAssistant =\n  [...conversations]\n    .reverse()\n    .find(c => (c.assistant_response || '').trim() !== '') || null;\n\n// ============= STEP 2: LOAD USER + MEMORIES =============\nlet userData = {};\ntry {\n  const userNode = $('Get User1').first().json; // adjust node name if needed\n  userData = userNode || {};\n} catch (e) {\n  userData = {};\n}\n\nlet userMemories = [];\ntry {\n  const memNode = $('Get User Memories').first().json;\n  userMemories = memNode.data || memNode.memories || [];\n} catch (e) {\n  userMemories = [];\n}\n\nconst importantMemories = userMemories.filter(m => {\n  const score = typeof m.importance_score === 'number' ? m.importance_score : 1;\n  return score >= 0.7;\n});\n\n// ============= STEP 3: UNDERSTAND CURRENT MESSAGE =============\nconst current = $json || {};\nconst currentText =\n  current.user_message ||\n  current.message ||\n  current.text ||\n  '';\nconst currentLower = (currentText || '').trim().toLowerCase();\n\n// ============= STEP 4: PENDING ACTION & YES/NO DETECTION =============\n\n// Helper: simple yes/no detection for short replies\nfunction isShortYesNo(text) {\n  if (!text) return null;\n  const t = text.trim().toLowerCase();\n  if (t.length === 0 || t.length > 40) return null;\n\n  const YES = [\n    'yes','ya','yaaa','yup','ok','okay','okey','ok lah','okla','boleh',\n    'boleh je','proceed','confirm','set kan','buat','buat je','jom','ye'\n  ];\n  const NO = [\n    'no','tak','tak nak','tidak','jangan','nope','later','nanti',\n    'bukan sekarang','skip','tak payah'\n  ];\n\n  if (YES.includes(t)) return 'yes';\n  if (NO.includes(t)) return 'no';\n  return null;\n}\n\n// Helper: time guard for pending actions\nfunction isWithinHours(dateStr, hours) {\n  if (!dateStr) return false;\n  const then = new Date(dateStr).getTime();\n  const now = Date.now();\n  const diffH = (now - then) / (1000 * 60 * 60);\n  return diffH <= hours;\n}\n\nlet isActiveResponse = false;\nlet activeResponseType = null;   // 'yes' | 'no'\nlet questionType = 'general';\nlet offerContext = null;\nlet pendingAction = null;\n\n// ---- Build pendingAction from DB fields, with ARA_PENDING as fallback ----\nlet lastAssistantText = lastAssistant ? (lastAssistant.assistant_response || '') : '';\n\nif (lastAssistant) {\n  // 1) Prefer structured fields from the conversations table\n  if (\n    lastAssistant.pending_action_type &&\n    lastAssistant.pending_action_type !== 'none'\n  ) {\n    pendingAction = {\n      type: lastAssistant.pending_action_type,\n      payload: lastAssistant.pending_action_payload || null,\n      resolved: !!lastAssistant.pending_action_resolved,\n      created_at: lastAssistant.created_at,\n    };\n  } else if (lastAssistantText) {\n    // 2) Backwards-compatible support for old ARA_PENDING footer\n    const match = lastAssistantText.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})\\s*$/);\n    if (match) {\n      try {\n        const pa = JSON.parse(match[1]);\n        if (pa.type && pa.type !== 'none') {\n          pendingAction = {\n            type: pa.type,\n            payload: pa.payload || null,\n            resolved: false,\n            created_at: lastAssistant.created_at,\n          };\n        }\n      } catch (e) {\n        // ignore parse errors\n      }\n    }\n  }\n}\n\n// YES/NO on current message\nconst shortYesNo = isShortYesNo(currentText);\n\n\n// 1) If we have a pending action and user sends short yes/no recently\nif (\n  pendingAction &&\n  pendingAction.type &&\n  pendingAction.type !== 'none' &&\n  isWithinHours(pendingAction.created_at, 48) &&\n  shortYesNo\n) {\n  isActiveResponse = true;\n  activeResponseType = shortYesNo;\n  questionType = 'offer';\n  offerContext = pendingAction.type;\n}\n\n// 2) Fallback: classify last assistant message question type (for general yes/no replies)\nif (!isActiveResponse && lastAssistantText) {\n  const lastText = lastAssistantText.toLowerCase();\n\n  const hasQuestionMark = lastText.includes('?');\n  const hasOfferPattern = /would you like|nak tak|mahu tak|do you want|shall i|should i|may i|can i help|if you‚Äôd like|kalau nak/i.test(lastText);\n  const hasClarificationPattern = /could you clarify|apa yang dimaksud|what do you mean|which one do you mean|yang mana satu/i.test(lastText);\n  const hasConfirmationPattern = /is this correct|is that right|betul tak|setuju tak|confirm/i.test(lastText);\n  const hasChoicePattern = /\\bor\\b|atau\\b/i.test(lastText);\n\n  if (hasOfferPattern) questionType = 'offer';\n  else if (hasClarificationPattern) questionType = 'clarification';\n  else if (hasConfirmationPattern) questionType = 'confirmation';\n  else if (hasChoicePattern) questionType = 'choice';\n  else if (hasQuestionMark) questionType = 'general';\n\n  const yn = shortYesNo;\n  if (yn && (hasOfferPattern || hasConfirmationPattern || hasChoicePattern)) {\n    isActiveResponse = true;\n    activeResponseType = yn;\n\n    if (hasOfferPattern) offerContext = 'offer';\n    else if (hasConfirmationPattern) offerContext = 'confirmation';\n    else if (hasChoicePattern) offerContext = 'choice';\n  }\n}\n\n// ============= STEP 5: BUILD ARA CONTEXT =============\nconst araContext = {\n  user: {\n  id: userData.id || null,\n  name: userData.name || userData.full_name || null,\n  phone: userData.phone || userData.telegram_id || null,\n  preferred_name: userData.preferred_name || null,\n    language_preference: userData.preferred_language || 'auto',\n  features_enabled: userData.features_enabled || null,\n\n  // Main timezone ARA should use\n  timezone:\n    userData.current_timezone ||\n    userData.home_timezone ||\n    userData.timezone ||\n    'Asia/Kuala_Lumpur',\n\n  // Extra fields so the main agent sees both explicitly\n  home_timezone: userData.home_timezone || null,\n  current_timezone: userData.current_timezone || null,\n\n    // ‚úÖ Inject style profile for tone mirroring\n   style_profile: {\n  ...(userData.style_profile || {}),\n  language_mix_cap: 0.3\n}\n\n},\n\n  current_message: {\n    text: currentText,\n    language_hint: null\n  },\n  history: {\n    detailed: detailedConversations.map(c => ({\n      created_at: c.created_at,\n      role: c.role || null,\n      user_message: c.user_message || '',\n      assistant_response: c.assistant_response || '',\n      session_id: c.session_id || null\n    })),\n    older_summaries: olderSummaries\n  },\n  memories: {\n    important: importantMemories,\n    all: userMemories\n  },\n  last_assistant_message: lastAssistant\n    ? {\n        created_at: lastAssistant.created_at,\n        text: lastAssistant.assistant_response || ''\n      }\n    : null,\n  dialogue_state: {\n    isActiveResponse,\n    activeResponseType,\n    questionType,\n    offerContext,\n    pendingAction\n  }\n};\n\nreturn [\n  {\n    json: {\n      ara_context: araContext,\n      // keep original fields\n      ...current\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1680,
        1888
      ],
      "id": "71ce73a4-662a-41b3-81b1-7b9e076b7431",
      "name": "Format Context with Memory"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e13dd0b2-6b72-4cc0-a466-e9677a549c1f",
              "leftValue": "={{ DateTime.fromISO($json.updated_at) < $today.minus({ days: 30 }) }}",
              "rightValue": "=",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3696,
        2224
      ],
      "id": "22bdda84-5e2b-4785-aa26-b368c9a0b393",
      "name": "Within 30 days?"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "telegram_id",
              "condition": "eq",
              "keyValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.WaId }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -4368,
        1456
      ],
      "id": "9acd4fc1-dea9-4fd4-8629-29ef6ebb5e67",
      "name": "Get User1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Prepare Memories v2 - simpler, cleaner, per-turn\n// Input: array of validated memory objects (from Validate Memories)\n// Output: array of rows ready for ai_memories table\n\nconst input = $input.all().map(i => i.json);\nlet memories = input;\n\n// If someone wired it differently and we got a single array\nif (input.length === 1 && Array.isArray(input[0])) {\n  memories = input[0];\n}\n\nif (!memories || memories.length === 0) {\n  console.log('Prepare Memories: no memories to process');\n  return [];\n}\n\n// ===== Get user context =====\nlet userId = null;\ntry {\n  const userNode = $('Get User1').first();\n  if (userNode && userNode.json && userNode.json.id) {\n    userId = userNode.json.id;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get user ID', e);\n}\n\nif (!userId) {\n  console.log('Prepare Memories: missing user_id, aborting');\n  return [];\n}\n\n// ===== Get existing memories for this user =====\nlet existing = [];\ntry {\n  const rows = $('Get User Memories').all() || [];\n  existing = rows\n    .filter(r => r.json && r.json.memory_value)\n    .map(r => r.json);\n} catch (e) {\n  console.log('Prepare Memories: could not get existing memories', e);\n}\n\n// Build quick lookup structures\nconst existingByKey = {};\nconst existingByValue = new Map();\n\nexisting.forEach(mem => {\n  const key = (mem.memory_key || '').toLowerCase();\n  if (key) existingByKey[key] = mem;\n\n  const val = (mem.memory_value || '').toLowerCase().trim();\n  if (val) existingByValue.set(val, mem);\n});\n\n// ===== Helper: normalize base key =====\nconst slugify = (text) => {\n  return text\n    .toString()\n    .toLowerCase()\n    .normalize('NFKD')\n    .replace(/[^a-z0-9]+/g, '_')\n    .replace(/^_+|_+$/g, '');\n};\n\n// ===== Helper: generate unique key with versions =====\nconst versionCache = {}; // baseKey -> highest version\n\n// Initialize versionCache from existing keys\nObject.keys(existingByKey).forEach(k => {\n  const match = k.match(/^(.*)_v(\\d+)$/);\n  if (match) {\n    const base = match[1];\n    const v = parseInt(match[2], 10);\n    if (!versionCache[base] || v > versionCache[base]) {\n      versionCache[base] = v;\n    }\n  }\n});\n\nconst generateKey = (mem, index) => {\n  // Start from provided key if any\n  let base = mem.memory_key\n    ? slugify(mem.memory_key)\n    : slugify(mem.memory_value || `memory_${index}`);\n\n  // Attach first person if available\n  if (mem.entities && mem.entities.people && mem.entities.people.length > 0) {\n    const person = slugify(mem.entities.people[0]);\n    if (person && !base.includes(person)) {\n      base = `${person}_${base}`;\n    }\n  }\n\n  // Strip existing version suffix\n  base = base.replace(/_v\\d+$/, '');\n\n  const type = mem.memory_type || 'context';\n\n  if (type === 'preference' || type === 'context') {\n    // Versioned keys\n    const current = versionCache[base] || 0;\n    const next = current + 1;\n    versionCache[base] = next;\n    return `${base}_v${next}`;\n  }\n\n  if (type === 'relationship') {\n    // Relationship can be stable per session\n    const now = Date.now();\n    return `${base}_rel_${now}`;\n  }\n\n  if (type === 'interaction') {\n    const now = Date.now();\n    return `${base}_int_${now}`;\n  }\n\n  // Fallback\n  const now = Date.now();\n  return `${base}_${type}_${now}`;\n};\n\n// ===== Very simple similarity check (exact / near exact text) =====\nconst isDuplicateByValue = (value) => {\n  if (!value) return false;\n  const valLower = value.toLowerCase().trim();\n  if (existingByValue.has(valLower)) return true;\n  return false;\n};\n\n// ===== Session & timestamps =====\nlet sessionId = null;\ntry {\n  const ctx = $('Format Context with Memory').first();\n  if (ctx && ctx.json && ctx.json.ara_context && ctx.json.ara_context.history) {\n    sessionId = ctx.json.ara_context.history.detailed?.[0]?.session_id || null;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get session_id from context');\n}\n\nif (!sessionId) {\n  // Fallback session id\n  sessionId = `${Date.now()}_${Math.floor(Math.random() * 100000)}`;\n}\n\nconst nowIso = new Date().toISOString();\n\n// ===== Process memories =====\nconst prepared = [];\n\nmemories.forEach((mem, index) => {\n  if (!mem || !mem.memory_value) return;\n\n  // Skip if same value already exists\n  if (isDuplicateByValue(mem.memory_value)) {\n    console.log('Prepare Memories: skip duplicate by value:', mem.memory_value.substring(0, 60));\n    return;\n  }\n\n  const type = mem.memory_type || 'context';\n  const key = generateKey(mem, index);\n\n  const row = {\n    user_id: userId,\n    memory_type: type,\n    memory_key: key,\n    memory_value: mem.memory_value,\n    importance_score: mem.importance_score ?? 0.8,\n    session_id: sessionId,\n    conversation_date: nowIso,\n    entities: JSON.stringify(mem.entities || { people: [], topics: [] }),\n    temporal_context: mem.temporal_context || 'today',\n    is_active: true,\n    confidence_score: 1,\n    source: 'auto_extracted',\n    context_before: null,\n    context_after: null,\n  };\n\n  prepared.push(row);\n  console.log(`Prepare Memories: ACCEPTED ${key}`);\n});\n\nif (prepared.length === 0) {\n  console.log('Prepare Memories: no new memories after dedupe');\n}\n\nreturn prepared.map(r => ({ json: r }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1552,
        2032
      ],
      "id": "cda7956c-202f-424e-bca6-ba5a62f339e1",
      "name": "Prepare Memories1"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "= {{ $json.user_id }}",
              "rightValue": 0,
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              },
              "id": "ebb88b93-4047-405f-9730-737ec9f4b782"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1776,
        2032
      ],
      "id": "a781a5c4-abfa-412b-81d7-78b13a783e19",
      "name": "Has Memories?1"
    },
    {
      "parameters": {
        "tableId": "ai_memories",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "memory_type",
              "fieldValue": "={{ $json.memory_type }}"
            },
            {
              "fieldId": "memory_key",
              "fieldValue": "={{ $json.memory_key }}"
            },
            {
              "fieldId": "memory_value",
              "fieldValue": "={{ $json.memory_value }}"
            },
            {
              "fieldId": "importance_score",
              "fieldValue": "={{ $json.importance_score }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "entities",
              "fieldValue": "={{ $json.entities }}"
            },
            {
              "fieldId": "temporal_context",
              "fieldValue": "={{ $json.temporal_context }}"
            },
            {
              "fieldId": "is_active",
              "fieldValue": "={{ $json.is_active }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2000,
        2032
      ],
      "id": "76c66e36-954e-4d33-86d4-497fdf77b5f2",
      "name": "Save Memories1"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Session Summary Generator v2\n// - Only summarizes completed sessions\n// - Skips very short/test sessions\n// - Produces richer, more structured summaries\n\nconst MIN_MESSAGES = 3;        // Require at least 3 messages in a session\nconst MIN_GAP_MINUTES = 15;    // Session must have ended at least 15 minutes ago\n\n// ---------- 1. Resolve user ID ----------\nlet userId;\n\ntry {\n  const ctx = $('Format Context with Memory').first();\n  if (ctx?.json?.user_id) {\n    userId = ctx.json.user_id;\n  }\n} catch (e) {\n  console.log('Could not get user ID from Format Context with Memory', e);\n}\n\nif (!userId) {\n  try {\n    const userNode = $('Get User1').first();\n    if (userNode?.json?.id) {\n      userId = userNode.json.id;\n    }\n  } catch (e) {\n    console.log('Could not get user ID from Get User1', e);\n  }\n}\n\n// If we still don't have a userId, we can't safely summarize\nif (!userId) {\n  console.log('No userId found, skipping session summary');\n  return [];\n}\n\n// ---------- 2. Get conversation history for this user ----------\nlet conversations = [];\ntry {\n  conversations = $('Fetch Session History').all() || [];\n} catch (e) {\n  console.log('Could not get conversations from Fetch Session History', e);\n  return [];\n}\n\n// Convert to plain JS objects and filter by this user (safety)\nconst allConversations = conversations\n  .map(c => c.json)\n  .filter(c => c && c.user_id === userId && c.session_id);\n\nif (allConversations.length < MIN_MESSAGES) {\n  console.log('Not enough conversations overall to summarize');\n  return [];\n}\n\n// Sort descending by created_at (newest first)\nallConversations.sort(\n  (a, b) => new Date(b.created_at) - new Date(a.created_at)\n);\n\n// ---------- 3. Work out current vs completed sessions ----------\nconst currentSessionId = allConversations[0].session_id;\nconsole.log('Current session ID:', currentSessionId);\n\nconst sessionsById = {};\nfor (const conv of allConversations) {\n  if (!sessionsById[conv.session_id]) {\n    sessionsById[conv.session_id] = [];\n  }\n  sessionsById[conv.session_id].push(conv);\n}\n\n// Remove the current session from candidates (we only want completed ones)\ndelete sessionsById[currentSessionId];\n\nconst candidateSessionIds = Object.keys(sessionsById);\nif (candidateSessionIds.length === 0) {\n  console.log('No completed sessions to summarize');\n  return [];\n}\n\n// ---------- 4. Pick the most recent completed session ----------\ncandidateSessionIds.sort((a, b) => {\n  const aRecent = Math.max(\n    ...sessionsById[a].map(c => new Date(c.created_at).getTime())\n  );\n  const bRecent = Math.max(\n    ...sessionsById[b].map(c => new Date(c.created_at).getTime())\n  );\n  return bRecent - aRecent;\n});\n\nconst sessionId = candidateSessionIds[0];\nconst sessionToSummarize = sessionsById[sessionId];\n\n// Ensure this session is ‚Äúreal‚Äù and not just a 1-message ping\nif (sessionToSummarize.length < MIN_MESSAGES) {\n  console.log(\n    `Session ${sessionId} has only ${sessionToSummarize.length} messages, skipping summary`\n  );\n  return [];\n}\n\n// Check how long ago this session ended\nconst mostRecentMessageTs = Math.max(\n  ...sessionToSummarize.map(c => new Date(c.created_at).getTime())\n);\nconst minutesSinceLastMessage =\n  (Date.now() - mostRecentMessageTs) / (1000 * 60);\n\nif (minutesSinceLastMessage < MIN_GAP_MINUTES) {\n  console.log(\n    `Session ${sessionId} ended only ${minutesSinceLastMessage.toFixed(\n      1\n    )} minutes ago, skipping summary`\n  );\n  return [];\n}\n\n// ---------- 5. Extract key info from this session ----------\nconst topics = new Set();\nconst people = new Set();\nconst decisions = [];\nlet firstUserMessage = null;\nlet lastUserMessage = null;\n\nfor (const conv of sessionToSummarize) {\n  if (!conv.user_message) continue;\n\n  const msg = conv.user_message;\n  const msgLower = msg.toLowerCase();\n\n  if (!firstUserMessage) firstUserMessage = msg;\n  lastUserMessage = msg;\n\n  // Topics (you can extend this list anytime)\n  if (msgLower.includes('staff') || msgLower.includes('hire') || msgLower.includes('recruit')) {\n    topics.add('hiring');\n  }\n  if (msgLower.includes('remind') || msgLower.includes('ingat')) {\n    topics.add('reminders');\n  }\n  if (msgLower.includes('meeting') || msgLower.includes('jumpa')) {\n    topics.add('meetings');\n  }\n  if (msgLower.includes('stok') || msgLower.includes('inventory')) {\n    topics.add('inventory');\n  }\n  if (msgLower.includes('duit') || msgLower.includes('bayar') || msgLower.includes('payment')) {\n    topics.add('money');\n  }\n\n  // Rough name detection (single capitalized words)\n  const namePattern = /\\b[A-Z][a-z]{2,}\\b/g;\n  const names = msg.match(namePattern) || [];\n  for (const name of names) {\n    if (!['I', 'Ara', 'ARA'].includes(name)) {\n      people.add(name);\n    }\n  }\n\n  // Decisions / plans (keep first 120 chars)\n  if (\n    msgLower.includes('need') ||\n    msgLower.includes('nak ') ||\n    msgLower.includes('akan ') ||\n    msgLower.includes('plan') ||\n    msgLower.includes('will')\n  ) {\n    decisions.push(msg.substring(0, 120));\n  }\n}\n\n// ---------- 6. Timing & meta info ----------\nsessionToSummarize.sort(\n  (a, b) => new Date(a.created_at) - new Date(b.created_at)\n);\nconst sessionStartTime = new Date(sessionToSummarize[0].created_at);\nconst sessionEndTime = new Date(\n  sessionToSummarize[sessionToSummarize.length - 1].created_at\n);\n\nconst dayOfWeekNames = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n];\nconst dayOfWeek = dayOfWeekNames[sessionStartTime.getDay()];\n\nconst hour = sessionStartTime.getHours();\nconst timeOfDay =\n  hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';\n\nconst durationMinutes = Math.max(\n  1,\n  Math.round((sessionEndTime - sessionStartTime) / (1000 * 60))\n);\n\n// ---------- 7. Build human-readable summary ----------\nlet summaryText = 'User ';\n\nif (topics.has('hiring')) {\n  summaryText += 'discussed getting help with hiring or staff issues';\n} else if (topics.size > 0) {\n  summaryText += `discussed ${Array.from(topics).join(', ')}`;\n} else {\n  summaryText += 'had a general conversation';\n}\n\nif (people.size > 0) {\n  summaryText += `, and mentioned ${Array.from(people).join(', ')}`;\n}\n\nsummaryText += `. Conversation lasted about ${durationMinutes} minute(s).`;\n\nif (decisions.length > 0) {\n  summaryText += ' Key decisions or needs were mentioned.';\n}\n\n// ---------- 8. Construct summary record ----------\nconst summary = {\n  user_id: userId,\n  session_id: sessionId,\n  conversation_date: sessionStartTime.toISOString(),\n  day_of_week: dayOfWeek,\n  time_of_day: timeOfDay,\n  summary: summaryText,\n  key_topics: Array.from(topics),\n  people_mentioned: Array.from(people),\n  decisions_made: decisions,\n  message_count: sessionToSummarize.length,\n  session_duration_minutes: durationMinutes,\n};\n\nconsole.log('Generated summary for completed session:', summary);\n\n// n8n expects an array of items: [{ json: ... }]\nreturn [{ json: summary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1552,
        2320
      ],
      "id": "a76f881e-f3bf-4694-8d82-2a1b3fe18f5a",
      "name": "Generate Session Summary1",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "tableId": "conversation_summaries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "day_of_week",
              "fieldValue": "={{ $json.day_of_week }}"
            },
            {
              "fieldId": "time_of_day",
              "fieldValue": "={{ $json.time_of_day }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $json.summary }}"
            },
            {
              "fieldId": "key_topics",
              "fieldValue": "={{ $json.key_topics }}"
            },
            {
              "fieldId": "people_mentioned",
              "fieldValue": "={{ $json.people_mentioned }}"
            },
            {
              "fieldId": "decisions_made",
              "fieldValue": "={{ $json.decisions_made }}"
            },
            {
              "fieldId": "message_count",
              "fieldValue": "={{ $json.message_count }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1776,
        2320
      ],
      "id": "d829f4db-3302-4693-8d54-93646cb7e579",
      "name": "Save Session Summary1"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $('Extract Pending Action').item.json.assistant_response }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $('Extract Pending Action').item.json.pending_action_type }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $('Extract Pending Action').item.json.pending_action_payload }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "false"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1040,
        2320
      ],
      "id": "1f1f8081-800a-43e8-a8af-e9d37a889d4f",
      "name": "Update Conversation",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "jsCode": "// Validate Memories (hardened)\n// Input: Whatever Extract Memories returns (can be JSON, string, or error envelope)\n// Output: array of clean memory objects as { json: ... }\n// If anything looks wrong, we just return [] and let the workflow continue safely.\n\nconst raw = $json;\n\n// 0) If upstream node failed and we got an error envelope, bail out safely.\nif (raw.error || raw.errorMessage || raw.errorDescription) {\n  console.log('Validate Memories: upstream error detected, skipping memories.');\n  return [];\n}\n\n// 1) Unwrap \"output\" if present\nlet memoriesRaw = raw.output ?? raw;\n\nlet memories = [];\n\ntry {\n  if (typeof memoriesRaw === 'string') {\n    let txt = memoriesRaw.trim();\n\n    // Strip accidental code fences\n    txt = txt\n      .replace(/^```json\\s*/i, '')\n      .replace(/^```\\s*/i, '')\n      .replace(/```$/i, '')\n      .trim();\n\n    const parsed = JSON.parse(txt);\n\n    if (Array.isArray(parsed)) {\n      memories = parsed;\n    } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.memories)) {\n      // Sometimes wrapped as { memories: [...] }\n      memories = parsed.memories;\n    } else {\n      memories = [parsed];\n    }\n\n  } else if (Array.isArray(memoriesRaw)) {\n    memories = memoriesRaw;\n\n  } else if (memoriesRaw && typeof memoriesRaw === 'object') {\n    // Maybe already { memories: [...] } or a single object\n    if (Array.isArray(memoriesRaw.memories)) {\n      memories = memoriesRaw.memories;\n    } else {\n      memories = [memoriesRaw];\n    }\n\n  } else {\n    console.log('Validate Memories: unsupported input type, skipping.');\n    return [];\n  }\n\n} catch (e) {\n  console.log('Validate Memories: failed to parse memories JSON, skipping.', e);\n  return [];\n}\n\nif (!Array.isArray(memories)) {\n  console.log('Validate Memories: parsed value is not an array, skipping.');\n  return [];\n}\n\nconst ALLOWED_TYPES = new Set(['preference', 'relationship', 'context', 'interaction']);\n\nconst cleaned = memories\n  .filter(m => m && typeof m === 'object')\n  .map((m, idx) => {\n    const mem = { ...m };\n\n    // Normalise memory_type\n    if (!ALLOWED_TYPES.has(mem.memory_type)) {\n      if (mem.memory_type === 'business/role') {\n        mem.memory_type = 'context';\n      } else {\n        mem.memory_type = 'context';\n      }\n    }\n\n    // Ensure text fields exist\n    mem.memory_value = (mem.memory_value || '').toString().trim();\n    mem.memory_key = (mem.memory_key || `memory_${idx}`).toString().trim();\n\n    // Default importance\n    const importance = Number(mem.importance_score ?? 0.8);\n    mem.importance_score = Number.isFinite(importance) ? importance : 0.8;\n\n    // Normalise entities\n    const entities = mem.entities || {};\n    mem.entities = {\n      people: Array.isArray(entities.people) ? entities.people : [],\n      topics: Array.isArray(entities.topics) ? entities.topics : [],\n    };\n\n    // Temporal context\n    mem.temporal_context = mem.temporal_context || 'today';\n\n    return mem;\n  })\n  .filter(mem => {\n    // Filter out junk (same rules as before)\n    if (!mem.memory_value || mem.memory_value.length < 10) return false;\n    if (mem.importance_score < 0.7) return false;\n    return true;\n  });\n\n// n8n expects an array of items: [{ json: ... }, ...]\nreturn cleaned.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1328,
        2032
      ],
      "id": "6a869bab-eca0-4714-82f7-504d36579935",
      "name": "Validate Memories"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {
          "maxTokens": 500,
          "temperature": 0.4
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1104,
        2112
      ],
      "id": "e085ddee-2332-407e-a112-774c4566b949",
      "name": "OpenAI Chat Model"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "73f83fad-e8b2-4191-8e95-cf32b3c0c01b",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -5040,
        1456
      ],
      "id": "66271344-5da0-4062-842e-995199fed65b",
      "name": "Twilio Webhook",
      "webhookId": "73f83fad-e8b2-4191-8e95-cf32b3c0c01b"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e13dd0b2-6b72-4cc0-a466-e9677a549c1f",
              "leftValue": "={{ DateTime.fromISO($json.updated_at) < $today.minus({ days: 30 }) }}",
              "rightValue": "=",
              "operator": {
                "type": "boolean",
                "operation": "false",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3696,
        1568
      ],
      "id": "51f1b98f-891d-4cd9-8374-5df315e001d9",
      "name": "Within 30 days?1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "9ccbba93-3028-4b23-94a5-dc8ec1a53cd5",
              "name": "chatInput",
              "value": "={{ $json.body.Body }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -4816,
        1456
      ],
      "id": "7a16145a-f924-4fef-baef-331228bd4147",
      "name": "Prepare Incoming Message"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "GPT-4.1-MINI-2025-04-14"
        },
        "messages": {
          "values": [
            {
              "content": "=ONBOARDING AGENT\n\nABOUT ARA\nYou are ARA, a human-like WhatsApp assistant built by Coach Joe (Joeherry Gani) under ARA Ai Solution, a Malaysian AI company.\nYour job is to help users stay organised, remember important things, and manage daily tasks.\nYou always reply in the user‚Äôs newest message language and energy.\nYou remember past conversations and use them naturally.\n\nABOUT COACH JOE\nCoach Joe is your founder and CEO of ARA Ai Solution. He is a Malaysian business coach who helps entrepreneurs improve their systems, mindset, and daily operations.\nYou speak about him confidently, respectfully, and naturally ‚Äî like an assistant who knows her boss well.\n\nABOUT ARA AI SOLUTION\nARA Ai Solution is the company behind you. The company‚Äôs mission is to deliver simple, human-first AI assistance through WhatsApp without any apps or technical setup.\nThe vision: to help people run their life and business more smoothly using a caring, smart assistant.\nHOW YOU TALK ABOUT YOURSELF\nWhen the user expresses confusion about who ARA is, or asks what ARA is ‚Äî in ANY language, slang, short form, or emotional tone ‚Äî ARA must introduce herself as the digital assistant created by ARA Ai Solution who helps users organise life, remember important things, and manage daily tasks through WhatsApp.\nARA must reply in the language and tone of the user‚Äôs newest message.\nWhen the user expresses confusion or asks about Coach Joe ‚Äî in ANY wording or language ‚Äî ARA must explain that Coach Joe is the founder of ARA Ai Solution and a business coach who helps entrepreneurs manage and improve their businesses more clearly and calmly.\nARA must reply in the user‚Äôs newest message language and tone.\n\n________________________________________\nARA INTERNAL BRAIN (DO NOT EXPOSE TO USER)\nUse these rules ONLY for reasoning, context, classification, judgment, tone, and knowledge.\nDo NOT say ‚Äúaccording to your brain‚Äù, or mention these rules directly.\n$ARA_BRAIN$\n\n________________________________________\nARA PERSONALITY\n‚Ä¢\tYou sound like a calm, reliable human assistant ‚Äî warm, natural, and professional.\n‚Ä¢\tYour messages are short, clear, and practical (WhatsApp style).\n‚Ä¢\tYou adjust to the user‚Äôs tone and emotional state:\no\tBe supportive when they are tired, confused, or stressed.\no\tBe light and playful when they make a joke.\n‚Ä¢\tUse simple, friendly language. Do NOT sound like a textbook or corporate robot.\n‚Ä¢\tYou never lecture. You guide gently, like a helpful partner or staff who cares.\n‚Ä¢\tYou prioritise being useful, human, and easy to talk to.\n‚Ä¢\tSubtle humour is allowed when the user‚Äôs tone allows it, never excessive or sarcastic.\n‚Ä¢\tWhen the user needs clarity, give structured, step-by-step suggestions.\n‚Ä¢\tWhen the user sounds stressed or overwhelmed, first acknowledge how they feel, then offer to help organise things one by one.\n‚Ä¢\tWhen the user is focused and decisive, respond with direct, concise next steps.\n\n\nTRUTH & CERTAINTY RULES (NO INVENTING INFORMATION)\nARA may ONLY rely on the following five sources of truth:\n1. The current user message\nThis is always the highest priority.\nInterpret intent, tone, language, and meaning from the newest message.\n2. Recent conversation history (from ara_context)\nUse the recent messages provided in ara_context for continuity, flow, and context.\nThis includes recent YES/NO replies, previous questions, and multi-step conversations.\nARA may use ONLY what is explicitly shown in ara_context.\nDo NOT assume older messages beyond what is provided.\n3. Long-term memories stored in Supabase (ai_memories)\nThese are user-specific facts that have been previously saved.\nUse them only when relevant and appropriate.\nNever invent new personal details that are not stored.\n4. Brain rules loaded into $ARA_BRAIN$\nUse these as fixed world-knowledge corrections, mappings, and logic.\nThese rules override model assumptions.\n5. Safe, general world knowledge\nGeneral facts that are widely true and non-specific (e.g., ‚ÄúLondon is in the UK‚Äù, ‚Äúphones need charging‚Äù, ‚ÄúMalaysia uses MYR‚Äù).\nARA must ONLY use general world knowledge when confident it is accurate.\n\n________________________________________\n‚ùóEverything OUTSIDE these five sources must be treated as uncertain.\nWhen ARA is uncertain, she must respond naturally (in the user‚Äôs newest message language and tone) using brief honesty statements such as:\n‚Ä¢\t‚ÄúSaya tak pasti yang tepat‚Ä¶‚Äù\n‚Ä¢\t‚ÄúNot fully sure, but here‚Äôs what I can confirm‚Ä¶‚Äù\n‚Ä¢\t‚ÄúKalau boleh jelaskan sikit, saya boleh bantu lebih tepat.‚Äù\n‚Ä¢\t‚ÄúI might need a bit more detail for this.‚Äù\n\n________________________________________\nüî• ARA must NEVER invent or fabricate:\n‚Ä¢\tURLs or links\n‚Ä¢\tSong lyrics\n‚Ä¢\tExact song lists, book lists, or catalog items\n‚Ä¢\tDates, times, or numbers\n‚Ä¢\tPersonal details about people\n‚Ä¢\tTechnical instructions that were not provided\n‚Ä¢\tAny fact that does not exist in the 5 allowed sources\nNo guessing.\nNo filling in gaps.\nNo confident claims without evidence.\nARA must always choose honesty over guesswork, even if the answer becomes shorter, simpler, or incomplete.\n\n________________________________________\nCRITICAL LANGUAGE RULE\n‚Ä¢\tFor every reply, first detect the language and tone (energy) of the user‚Äôs newest message.\n‚Ä¢\tYou MUST reply in the same main language and with similar energy as that newest message.\n‚Ä¢\tIf the newest user's message is in English ‚Üí reply in English, matching their tone.\n‚Ä¢\tIf the newest user's message is in Malay ‚Üí reply in Malay, matching their tone.\n‚Ä¢\tIf the newest user's message is in another language you understand ‚Üí reply fully in that language, matching their tone.\n‚Ä¢\tOnly mix languages if the user clearly mixes languages in the same newest message.\n‚Ä¢\tIgnore the language used in older messages ‚Äî always follow the newest one.\n\n\nLanguage and Style Behavior:\n- Match the user‚Äôs writing style ‚Äî including slang, emoji usage, message length, and punctuation rhythm ‚Äî but never use more slang, emojis, or code-switching than the user.\n- If the user mixes Malay and English within a sentence (e.g., ‚ÄúJap, I check dulu‚Äù), mirror this same intra-sentence code-mixing ratio.\n- Do not rephrase rojak messages into full English or full Malay unless the user clearly writes in only one language.\n- If ara_context.user.style_profile exists, use it to guide tone, slang, and language ratio ‚Äî including:\n‚Ä¢ Respect language_mix_cap as the maximum allowed code-mix ratio for that user.\n‚Ä¢ Never exceed this ratio even if the newest message has more.\n‚Ä¢ If no style_profile exists, follow the newest message's language and style exactly.\n\n\n________________________________________\nGENERAL BEHAVIOUR\n‚Ä¢\tKeep replies short and practical: 1‚Äì3 short paragraphs or a few bullet points.\n‚Ä¢\tBe friendly, respectful, and professional.\n‚Ä¢\tLight humour is okay when the user‚Äôs tone allows it.\n‚Ä¢\tWhen the user seems stressed or confused, empathise first, then give structure.\n‚Ä¢\tWhen unsure, briefly restate what you think they mean and ask one clear follow-up question.\n\n________________________________________\nCONTEXT HANDLING\nYou receive a JSON object called ara_context. It includes:\n‚Ä¢\tuser profile & preferences\n‚Ä¢\trecent conversation history\n‚Ä¢\tlong-term memories about the user\n‚Ä¢\tthe last question you asked (if any)\n‚Ä¢\twhether the user‚Äôs current message is likely a YES/NO reply\n‚Ä¢\tany pending action you previously proposed\n‚Ä¢\tdialogue_state containing:\no\tisActiveResponse (bool)\no\tactiveResponseType (\"yes\" | \"no\" | null)\no\tpendingAction object (if any)\nUsing context:\n‚Ä¢\tTreat the user‚Äôs current message as the main focus.\n‚Ä¢\tUse ara_context only to interpret meanings, not to override the current message.\n‚Ä¢\tIf dialogue_state.isActiveResponse is true and a pending action exists, treat short replies (‚Äúyes‚Äù, ‚Äúye‚Äù, ‚Äúok‚Äù, ‚Äúboleh‚Äù, etc.) as answers to that pending action.\n‚Ä¢\tIf you are not certain what the user means, ask one clear clarifying question.\n\n\n________________________________________\n\n\nUSER PROFILE & LANGUAGE PREFERENCE UPDATES (ARA_ACTION)\n\nIn addition to ARA_PENDING, you MUST instruct the external system to update the user‚Äôs profile by emitting an ARA_ACTION line.\n\nARA_ACTION is SEPARATE from ARA_PENDING and is always a single JSON object on its own line, for example:\nARA_ACTION: {\"type\":\"none\"}\n\nGENERAL RULE:\n‚Ä¢ In EVERY reply, you MUST output exactly ONE ARA_ACTION line.\n‚Ä¢ If this message does NOT change any name or language preferences, use:\n  ARA_ACTION: {\"type\":\"none\"}\n\nThere is ONE supported action type:\n\n1. update_user_preferences\n\nYou MUST use this action in BOTH of these situations:\n\nA) The user gives a direct instruction, e.g.:\n‚Ä¢ \"Call me Joey\"\n‚Ä¢ \"Just call me Zack\"\n‚Ä¢ \"Panggil saya Mimi\"\n‚Ä¢ \"Nama saya Syafiqah, panggil saya Fiqah\"\n‚Ä¢ \"Change my preferred language to English\"\n‚Ä¢ \"Lepas ni jawab dalam BM ya\"\n‚Ä¢ \"Tukar bahasa kepada Bahasa Indonesia\"\n\nB) The user is clearly answering YOUR question about name or language during onboarding, e.g.:\n‚Ä¢ \"Malay la\"\n‚Ä¢ \"Bahasa ok\"\n‚Ä¢ \"Ok\"\n‚Ä¢ \"Set Bahasa ke melayu ye\"\n‚Ä¢ \"BM je\"\n‚Ä¢ \"English please\"\n‚Ä¢ \"Bahasa Indonesia\"\n‚Ä¢ \"Indo je\"\n‚Ä¢ \"Panggil saya Kak Ana\"\nAny similar short reply that obviously tells you what name or language to use MUST trigger update_user_preferences.\n\nWhen you trigger this action you MUST:\n‚Ä¢ Reply normally to the user in WhatsApp style (main message).\n‚Ä¢ ALSO output an ARA_ACTION JSON with these fields:\n\nARA_ACTION: {\n  \"type\": \"update_user_preferences\",\n  \"preferred_name\": \"<new name or null>\",\n  \"preferred_language\": \"<lang code or null>\"\n}\n\nField rules:\n‚Ä¢ Only fill the field(s) that are actually being changed in this message.\n  - If the user only changes name:\n    - \"preferred_name\": \"<new name>\"\n    - \"preferred_language\": null\n  - If the user only changes language:\n    - \"preferred_name\": null\n    - \"preferred_language\": \"ms\" | \"en\" | \"id\"\n  - If the user clearly changes both, set both fields.\n\nLanguage code mapping:\n‚Ä¢ \"Malay\", \"BM\", \"Bahasa\", \"Bahasa Melayu\", \"Malay la\", \"BM je\", \"Set Bahasa ke Melayu\" ‚Üí \"ms\"\n‚Ä¢ \"English\", \"Inggeris\", \"English please\" ‚Üí \"en\"\n‚Ä¢ \"Bahasa Indonesia\", \"Indonesian\", \"Indo\", \"Indo je\" ‚Üí \"id\"\n\nIf the message is genuinely ambiguous AND it is NOT an obvious direct answer to your own question about name or language:\n‚Ä¢ Do NOT use \"update_user_preferences\".\n‚Ä¢ Ask ONE short clarifying question in the user‚Äôs language.\n‚Ä¢ For that turn, set:\n  ARA_ACTION: {\"type\":\"none\"}\n\n\n\n________________________________________\nPENDING ACTION CONFIRMATION LOGIC (IMPORTANT)\nWhen ara_context.dialogue_state.pendingAction exists, treat it as the source of truth.\nARA never calls tools directly. The external system performs the actual action based on\nyour reply and the ARA_PENDING line.\n1. Reminder Create ‚Üí user replies YES\n(pendingAction.type === \"reminder_offer\" AND activeResponseType === \"yes\")\nYou MUST:\n‚Ä¢\tAssume the system should now create the reminder using pendingAction.payload.\n‚Ä¢\tReply with a short confirmation that their reminder has been set.\n‚Ä¢\tMention the reminder topic and time from pendingAction.payload (do NOT invent a new time).\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\n‚Ä¢\tKeep it 1‚Äì2 short WhatsApp-style sentences.\nAt the very end of your message, on a new line, append exactly:\nARA_PENDING: {\"type\":\"reminder_create\",\"payload\": pendingAction.payload}\nNo more text, emojis, or formatting after this line.\nDo NOT wrap this line in code fences.\n\n________________________________________\n2. Reminder Create ‚Üí user replies NO\n(pendingAction.type === \"reminder_offer\" AND activeResponseType === \"no\")\nYou MUST:\n‚Ä¢\tAssume the system will NOT create the reminder.\n‚Ä¢\tReply with a short, polite confirmation that you will not set that reminder.\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\nThen end the message with exactly:\nARA_PENDING: {\"type\":\"none\"}\nNo more text after this line.\n\n________________________________________\n3. Timezone Update ‚Üí user replies YES\n(pendingAction.type === \"timezone_offer\" AND activeResponseType === \"yes\")\nYou MUST:\n‚Ä¢\tAssume the system should now update the user's timezone using pendingAction.payload.\n‚Ä¢\tReply with a short confirmation that you will use this timezone from now on.\n‚Ä¢\tMention the timezone_label from pendingAction.payload when referring to the time.\n‚Ä¢\tDo NOT assume Malay just because the timezone is in Malaysia.\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\n‚Ä¢\tKeep it 1‚Äì2 short WhatsApp-style sentences.\nThen append exactly:\nARA_PENDING: {\"type\":\"timezone_update\",\"payload\": pendingAction.payload}\nNo more text after this line.\n\n________________________________________\n4. Timezone Update ‚Üí user replies NO\n(pendingAction.type === \"timezone_offer\" AND activeResponseType === \"no\")\nYou MUST:\n‚Ä¢\tAssume the system will keep the existing timezone.\n‚Ä¢\tReply with a short confirmation that you will keep the current timezone.\n‚Ä¢\tReply fully in the language and energy of the user's newest message.\nThen end with:\nARA_PENDING: {\"type\":\"none\"}\nNo more text after this line.\n\n________________________________________\n5. DELETE REMINDERS ‚Äì CONFIRMATION LOGIC\nWhen the user has already seen a delete-offer (‚ÄúDo you want me to delete this reminder?‚Äù) and now replies YES/NO, you will have in ara_context:\n‚Ä¢\tdialogue_state.isActiveResponse\n‚Ä¢\tdialogue_state.activeResponseType\n‚Ä¢\tdialogue_state.pendingAction (may contain a previous reminder_delete_offer)\n5.1 If this is a YES to delete (activeResponseType === \"yes\"):\na) Reuse pending action if possible:\nIf:\n‚Ä¢\tdialoque_state.pendingAction exists\n‚Ä¢\tAND pendingAction.type === \"reminder_delete_offer\"\n‚Ä¢\tAND pendingAction.payload.reminder_id exists\nThen:\n‚Ä¢\tLet reminderId = pendingAction.payload.reminder_id\n‚Ä¢\tLet topic = pendingAction.payload.topic\n‚Ä¢\tLet timeDisplay = pendingAction.payload.time_display\n‚Ä¢\tReply with a brief confirmation that the reminder with this topic and time has been deleted, in the language and energy of the user‚Äôs newest message.\n‚Ä¢\tThen append:\nARA_PENDING: {\"type\":\"reminder_delete\",\"payload\":{\"reminder_id\":\"{{reminderId}}\"}}\nYou MUST NOT use ara_context.user.id as the reminder_id.\nb) If no pendingAction is available or usable:\n‚Ä¢\tCall the List Reminders tool for this user (user_id = ara_context.user.id).\n‚Ä¢\tIdentify the reminder that best matches the topic/time that was previously discussed.\n‚Ä¢\tLet its ID be reminderId.\n‚Ä¢\tReply to the user as in (a), then append:\nARA_PENDING: {\"type\":\"reminder_delete\",\"payload\":{\"reminder_id\":\"{{reminderId}}\"}}\nAgain: reminder_id must be the reminders table ID, not ara_context.user.id.\n5.2 If this is a NO to delete (activeResponseType === \"no\"):\n‚Ä¢\tDo NOT call any tools.\n‚Ä¢\tReply briefly that you will keep the reminder (language + energy of newest user‚Äôs message).\n‚Ä¢\tEnd with:\nARA_PENDING: {\"type\":\"none\"}\n5.3 If the user replies with something else (not a clear yes/no):\n‚Ä¢\tClarify what they want instead of deleting automatically.\n‚Ä¢\tDo NOT output a reminder_delete action in that case.\n\n________________________________________\n6. General rules for pending actions\n‚Ä¢\tNEVER repeat the same confirmation question once the user has already answered.\n‚Ä¢\tA YES must immediately confirm the action in your reply.\n‚Ä¢\tA NO must immediately cancel the action in your reply.\n‚Ä¢\tDo NOT propose a new action in the same message where you are confirming or cancelling a previous pendingAction.\n\n________________________________________\nREMINDERS / FOLLOW-UP RULES\nARA must help the user create and manage reminders safely, clearly, and only when the user truly intends it. ARA should always behave like a careful, smart assistant\n1. WHEN TO TREAT A MESSAGE AS A REMINDER REQUEST\nTreat a message as a reminder request only when:\nA) User expresses clear reminder intent such as:\n‚Ä¢\tMalay intent words for ‚Äúremind‚Äù / ‚Äúingatkan‚Äù / ‚Äúperingatan‚Äù / etc\n‚Ä¢\tEnglish intent words like ‚Äúremind me‚Äù, ‚Äúset a reminder‚Äù, ‚Äúdon‚Äôt let me forget‚Äù etc\n‚Ä¢\tOr any word from any language similar to the meanings of the example words\nAND the message includes a task (follow up, call, meeting, send file, etc.).\nB) If the user mentions a future date/time WITHOUT reminder words:\n‚Ä¢\tDo NOT assume it‚Äôs a reminder.\n‚Ä¢\tAsk whether they want it as a reminder or just a note, using the language and energy of the user‚Äôs newest message.\n‚Ä¢\tOnly proceed to reminder flow if they clearly indicate yes.\nC) If there are no reminder words and no time/date:\n‚Ä¢\tTreat as a note/memory, NOT a reminder.\n\n________________________________________\n2. TIME RULE ‚Äî NO REMINDERS WITHOUT SPECIFIC TIME\n‚Ä¢\tARA must ALWAYS require an exact time (HH:MM).\n‚Ä¢\tIf the user says ‚Äúesok / petang / malam / tomorrow / tonight‚Äù but gives no HH:MM ‚Üí ask for the specific time in the language and energy of the newest user‚Äôs message.\n‚Ä¢\tNo default times are allowed. Never assume (‚Äúmorning = 9am‚Äù, etc.).\n‚Ä¢\tDo not create a reminder until the user provides a clear time.\nTime conversion:\n‚Ä¢\tConvert the interpreted time into ISO 8601 format.\n‚Ä¢\tUse current_timezone as the reference timezone, unless the user explicitly specifies another timezone.\n‚Ä¢\tStore the final ISO datetime in payload.suggested_time.\nSpeaking about time:\n‚Ä¢\tWhen describing times to the user, use timezone_label (e.g. ‚Äúwaktu Kuala Lumpur‚Äù, ‚ÄúLondon time‚Äù), phrased naturally in the user‚Äôs newest message language.\n\n________________________________________\nTIME ENGINE (NATURAL LANGUAGE TIME)\nUse current_time_iso, current_timezone, and timezone_label to interpret phrases like:\n‚Ä¢\t‚Äúesok‚Äù, ‚Äútomorrow‚Äù\n‚Ä¢\t‚Äúnext Friday‚Äù, ‚Äúminggu depan‚Äù\n‚Ä¢\t‚Äúmalam nanti‚Äù\n‚Ä¢\t‚Äúesok 2.30‚Äù, ‚Äútomorrow 3pm‚Äù\nIf only date/day is given but no time, ask for the time as described above.\n\n__________________________________________\nONBOARDING MODE (SPECIAL RULES)\nYou are in ONBOARDING MODE. Your top priorities are:\n1.\tWelcome the user and introduce who you are.\n2.\tMake sure the user is comfortable with the language you are using. Only after you get the user's preferred language, you may proceed to no 3 (set timezone) NEVER ask no 2 and no 3 in the same message\n3.\tHelp the user register or confirm their current timezone using the TIMEZONE ENGINE.\n4.\tAnswer general questions normally, but do NOT create, list, or delete reminders yet.\nThe external system will route future messages to the main ARA agent once the user has a valid home_timezone.\nDuring onboarding:\n‚Ä¢\tYou may talk normally about reminders as a concept.\n‚Ä¢\tBut you must NOT emit any reminder-related ARA_PENDING actions.\n\n________________________________________\nWELCOME LOGIC (FIRST CONTACT VS RETURNING)\nYou will receive a field called assistant_response. Treat it as:\n‚Ä¢\tIf assistant_response is null or empty:\n‚Üí This is the user‚Äôs first interaction.\n‚Üí You MUST perform the WELCOME USER flow.\n‚Ä¢\tIf assistant_response is NOT null and NOT empty:\n‚Üí The user has interacted before.\n‚Üí You MUST skip the full welcome and go straight to TIME ZONE REGISTRATION (if timezone is not yet set) or normal conversation.\nWELCOME USER message structure (first time only):\nGenerate ONE WhatsApp message with short paragraphs separated by blank lines:\n1.\tGreeting (adjust if they likely came from business card):\no\tIf it sounds like they contacted you from Coach Joe‚Äôs business card:\n‚ÄúHi! üòä Terima kasih contact ARA melalui kad bisnes CEO kami, Coach Joe.‚Äù\no\tOtherwise:\n‚ÄúHi! üòä Terima kasih contact ARA.‚Äù\n2.\tIntroduce yourself briefly:\n‚ÄúSaya ARA ‚Äî pembantu AI yang ingat setiap perbualan, faham awak dan bisnes awak, dan bantu ingatkan perkara penting supaya awak tak terlepas peluang.‚Äù\n3.\tConfirm language:\n‚ÄúBy the way, bahasa yang saya guna ni okay tak? Atau awak lebih selesa dalam English atau bahasa lain?‚Äù\nThen proceed naturally toward TIME ZONE REGISTRATION.\n\n________________________________________\nTIME ZONE REGISTRATION (ONBOARDING FOCUS)\nPolitely explain (in the user‚Äôs newest message language) that you need to register their current timezone so that, later, reminders and follow-ups can be accurate.\nAsk for either:\n‚Ä¢\ttheir current city, or\n‚Ä¢\ttheir current timezone.\nExample in Malay:\n‚ÄúUntuk saya bantu urus reminder dengan tepat nanti, saya perlu tahu zone waktu awak sekarang. Awak berada di bandar mana ya (contoh: KL, London, Singapore)?‚Äù\nAfter that, use the TIMEZONE ENGINE rules below.\n\n________________________________________\nTIMEZONE ENGINE\nDetect timezone intent when user says things like:\n‚Ä¢\t‚ÄúI‚Äôm in London‚Äù, ‚ÄúSaya di Singapore‚Äù, ‚ÄúI‚Äôm back in Malaysia‚Äù, ‚ÄúSaya di Sabah‚Äù, etc.\nSteps:\n‚Ä¢\tRecognise that they are telling you a location relevant to timezone.\n‚Ä¢\tAsk ONE short confirmation question in the newest user‚Äôs message language, clearly stating the interpreted city/country/timezone label.\n‚Ä¢\tIf you can map the city to a supported IANA timezone, prepare a timezone proposal.\nSupported mappings (examples):\n‚Ä¢\tLondon ‚Üí Europe/London\n‚Ä¢\tSingapore ‚Üí Asia/Singapore\n‚Ä¢\tTokyo ‚Üí Asia/Tokyo\n‚Ä¢\tJakarta ‚Üí Asia/Jakarta\n‚Ä¢\tSabah/Sarawak ‚Üí Asia/Kuching\n‚Ä¢\tMalaysia/KL, ‚ÄúKL‚Äù, ‚ÄúKuala Lumpur‚Äù ‚Üí Asia/Kuala_Lumpur\nIf you cannot map the city:\n‚Ä¢\tAsk briefly for a clearer city/country name in the user‚Äôs newest message language.\n‚Ä¢\tUse ARA_PENDING: {\"type\":\"none\"} in that turn.\nConfirmation step:\n‚Ä¢\tOnce you propose a timezone, end the message with:\nARA_PENDING: {\"type\":\"timezone_offer\",\"payload\":{\"timezone\":\"<IANA_timezone>\",\"timezone_label\":\"<human_label>\"}}\nActual update only happens if the user later replies YES, handled by the timezone update confirmation logic.\nDo NOT create reminders until timezone is known.\n\n________________________________________\nSMART CONFIRMATION BEFORE CREATING REMINDERS\nARA must behave like a careful assistant: no silent reminder creation.\nA) When user already gave complete details (task + date + exact time):\n‚Ä¢\tSummarise the reminder details back to the user in the newest message language and tone.\n‚Ä¢\tClearly ask for confirmation in the same message.\n‚Ä¢\tAt the end of that message, output:\nARA_PENDING: {\"type\":\"reminder_offer\",\"payload\":{...}}\nThe payload contains the topic and ISO time you interpreted.\nThis records a proposed reminder only; the system will wait for YES/NO.\nB) When user gave incomplete details (missing time):\n‚Ä¢\tAsk exactly ONE clear follow-up question to get the missing detail, in the newest message language.\n‚Ä¢\tDo NOT set any reminder yet.\n‚Ä¢\tDo NOT output reminder_create or reminder_offer payload on this turn.\n‚Ä¢\tUse:\nARA_PENDING: {\"type\":\"none\"}\nWhen the user later provides the missing time, treat it as case (A).\nC) General rules:\n‚Ä¢\tNever create a reminder or imply that it exists before the user clearly confirms.\n‚Ä¢\tAlways summarise what you are about to do before asking for confirmation.\n‚Ä¢\tAlways rely on pendingAction + YES/NO logic; you only talk and emit ARA_PENDING.\n\n________________________________________\nLIST REMINDERS\nWhen user asks to see their reminders (in any language), you MUST:\n1.\tNever ask for technical IDs\no\tDo NOT ask for user_id, UUID, etc.\no\tAlways use ara_context.user.id internally.\no\tIf ara_context.user.id is missing/null, apologise and say you cannot access reminders now, invite them to try again later.\n2.\tUse the List Reminders tool/system\no\tDo NOT guess or invent reminders.\no\tIf the tool errors or returns nothing, say simply (in the newest message language) that no reminders could be retrieved, or that there are no active reminders.\n3.\tPresenting reminders\no\tGroup by day when possible (Today, Tomorrow, specific upcoming dates).\no\tUse a simple bullet-style list in the newest message language.\no\tEach reminder should show:\nÔÇß\tshort topic/label\nÔÇß\ttime, including timezone_label if available (phrased naturally).\n4.\tNo reminders case\no\tIf no reminders exist, say clearly that there are no active reminders.\no\tYou may invite the user to create one.\nARA_PENDING footer:\n‚Ä¢\tIf only listing (no follow-up offer):\nARA_PENDING: {\"type\":\"none\"}\n‚Ä¢\tIf you propose a follow-up action (like asking if they want to delete one), set an appropriate pending action type and payload, as per the delete rules, and encode it via ARA_PENDING.\n\n________________________________________\nDELETE REMINDERS\nWhen the user asks to delete a reminder:\n1.\tDo NOT ask for IDs or detailed technical info.\no\tDo not ask them for exact IDs or database keys.\no\tYour job is to identify the reminder using your tools and context.\n2.\tAlways list internally first\no\tUse the List Reminders tool with ara_context.user.id.\no\tNever invent reminders.\n3.\tFuzzy-match user message to reminders\no\tCompare user‚Äôs message against reminder topics and human-readable times using fuzzy/semantic matching.\n4.\tHandle cases:\n‚Ä¢\tExactly one match\no\tBriefly show which reminder you found (topic + time) in the newest user‚Äôs message language.\no\tAsk if they want that one deleted.\no\tEnd that message with:\nARA_PENDING: {\"type\": \"reminder_delete_offer\",\"payload\":{\"reminder_id\":\"<id>\",\"topic\":\"<topic>\",\"time_display\":\"<readable_time>\"}}\n‚Ä¢\tMultiple matches\no\tShow a short numbered list of the possible matches.\no\tAsk which one they mean.\no\tEnd with:\nARA_PENDING: {\"type\":\"none\"}\no\tWait for user clarification, then handle as the single-match case.\n‚Ä¢\tNo matches\no\tInform the user that you couldn‚Äôt find a relevant reminder.\no\tOptionally ask if they want to see the full list of their reminders.\no\tEnd with:\nARA_PENDING: {\"type\":\"none\"}\n5.\tNever delete without confirmation\no\tOnly proceed to delete logic when the user clearly confirms, using the YES/NO confirmation rules above.\n\n________________________________________\nESCALATION (NO CONFIRMATION NEEDED)\nARA must automatically escalate to a human/admin when:\n‚Ä¢\tThe user expresses dissatisfaction, frustration, or disappointment.\n‚Ä¢\tThe issue cannot be resolved after two attempts.\n‚Ä¢\tThe issue requires human verification or judgement.\n‚Ä¢\tThe user explicitly asks for a human/admin.\nWhen escalating:\n‚Ä¢\tBriefly apologise in the newest user‚Äôs message language.\n‚Ä¢\tInform the user that their issue has been escalated to a human/admin.\n‚Ä¢\tThen output:\nARA_PENDING: {\"type\":\"escalate\",\"payload\":{\"reason\":\"short description of issue\",\"summary\":\"1‚Äì2 sentence summary of what the user needs\",\"last_user_message\":\"<user's latest message>\",\"urgency\":\"normal\"}}\nDo NOT ask for confirmation to escalate.\nAlways tell the user that escalation has already been done.\n\n________________________________________\nNO SILENT ACTIONS\nARA must NOT create, update, or delete reminders unless:\n‚Ä¢\tThe user clearly intends it,\n‚Ä¢\tARA explains what is happening, and\n‚Ä¢\tThe user agrees (if required by the flow).\n\n________________________________________\n________________________________________\nMANDATORY ARA_ACTION & ARA_PENDING RULES\n\nIn EVERY reply, the structure at the end MUST be:\n\n1) One ARA_ACTION line\n2) One ARA_PENDING line (this is ALWAYS the final line)\n\nARA_ACTION RULES:\n‚Ä¢ You MUST always output exactly ONE ARA_ACTION line.\n‚Ä¢ If the current message does NOT change any name or language preferences:\n  ARA_ACTION: {\"type\":\"none\"}\n‚Ä¢ If the message sets or changes name/language, use:\n  ARA_ACTION: {\"type\":\"update_user_preferences\", ...}\n  following the rules in the USER PROFILE & LANGUAGE PREFERENCE UPDATES section.\n‚Ä¢ ARA_ACTION must appear on its own line, right BEFORE ARA_PENDING.\n‚Ä¢ Never explain ARA_ACTION to the user.\n\nARA_PENDING RULES:\n‚Ä¢ After the ARA_ACTION line, you MUST include exactly ONE ARA_PENDING line.\n‚Ä¢ If there is no pending action to propose:\n  ARA_PENDING: {\"type\":\"none\"}\n‚Ä¢ If ARA proposes an action, use one appropriate variant, for example:\n  - ARA_PENDING: {\"type\":\"reminder_create\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"reminder_delete\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"reminder_offer\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"timezone_offer\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"timezone_update\",\"payload\":{...}}\n  - ARA_PENDING: {\"type\":\"escalate\",\"payload\":{...}}\nRules:\n‚Ä¢ ARA_PENDING MUST be the LAST line in the message.\n‚Ä¢ It MUST start with ARA_PENDING:.\n‚Ä¢ It MUST contain valid JSON.\n‚Ä¢ Neither ARA_ACTION nor ARA_PENDING may be wrapped in code fences.\n‚Ä¢ They MUST never be explained to the user.\n\n\n",
              "role": "system"
            },
            {
              "content": "=Current message:\n{{$node[\"Get Latest Conversation1\"].json[\"user_message\"] || $node[\"Format Context with Memory1\"].json[\"ara_context\"].current_message.text || $json[\"user_message\"] || $json[\"message\"]}}\n\nARA context:\n{{JSON.stringify($node[\"Format Context with Memory1\"].json[\"ara_context\"])}}"
            }
          ]
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        -1456,
        560
      ],
      "id": "6fc93b8f-3dbc-401d-9a8c-e49a8f1b076a",
      "name": "Free User Onboarding"
    },
    {
      "parameters": {
        "tableId": "users",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "telegram_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "plan_type",
              "fieldValue": "free"
            },
            {
              "fieldId": "telegram_username",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.ProfileName }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -4592,
        1456
      ],
      "id": "ce661f98-6b15-4a8b-9265-5a151a367a8a",
      "name": "Ensure User Exist",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Format Context with Memory').item.json.ara_context.user.phone }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        688,
        2176
      ],
      "id": "6b6e8e94-3716-4631-b9d8-c073a0ce5299",
      "name": "Send Reply"
    },
    {
      "parameters": {
        "from": "whatsapp:+601125911400",
        "to": "={{ $item(0).$node[\"Get User1\"].json.telegram_chat_id }}\n",
        "toWhatsapp": true,
        "message": "=Maaf ye, anda telah sampai ke penghujung 30 hari penggunaan percuma anda.  Untuk kembali menggunakan ARA:  1. Sila salin mesej ini dan hantar ke admin di [WhatsApp](https://api.whatsapp.com/send?phone=601136521251)   2. Sertakan bukti pembayaran  ARA Smart: RM 39/bln (Promosi. Normal RM 99) ARA Pro: RM 199/bln ARA Biz: RM 299/bln  User name: {{ $json.first_name }} Telegram id: {{ $json.telegram_id }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -3472,
        2080
      ],
      "id": "b2fae5ad-a637-4535-8b9a-238cc863c57f",
      "name": "Send Paid Plan 1"
    },
    {
      "parameters": {
        "from": "whatsapp:+601125911400",
        "to": "={{ $item(0).$node[\"Get User1\"].json.telegram_chat_id }}\n",
        "toWhatsapp": true,
        "message": "=Maaf ye, anda telah sampai ke penghujung 30 hari penggunaan percuma anda.  Untuk kembali menggunakan ARA:  1. Sila salin mesej ini dan hantar ke admin di [WhatsApp](https://api.whatsapp.com/send?phone=601136521251)   2. Sertakan bukti pembayaran  ARA Smart: RM 39/bln (Promosi. Normal RM 99) ARA Pro: RM 199/bln ARA Biz: RM 299/bln  User name: {{ $json.first_name }} Telegram id: {{ $json.telegram_id }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -3472,
        2272
      ],
      "id": "c09284fb-7c19-41ff-b687-678675d8d15a",
      "name": "Send Paid Plan 2"
    },
    {
      "parameters": {
        "url": "https://jjeqmysluzsohwjpyvip.supabase.co/rest/v1/conversations",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ 'eq.' + $json.ara_context.user.id }}"
            },
            {
              "name": "order",
              "value": "created_at.desc"
            },
            {
              "name": "limit",
              "value": "1"
            },
            {
              "name": "select",
              "value": "*"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1392,
        1888
      ],
      "id": "2746df5d-a304-4de7-a6ab-3a1967854520",
      "name": "Get Latest Conversation"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract Pending Action (NEW - for structured output)\n// Input: $json.output is an OBJECT from Structured Output Parser\n\nconst o = $json.output ?? {};\nconst assistant_response = String(o.assistant_response ?? \"\").trim();\n\nreturn {\n  ...$json,\n  assistant_response,\n  pending_action_type: o.pending_action_type ?? \"none\",\n  pending_action_payload: o.pending_action_payload ?? null,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -624,
        1888
      ],
      "id": "5129c76d-edee-4c20-a492-b84836606b5e",
      "name": "Extract Pending Action"
    },
    {
      "parameters": {
        "jsCode": "// ROUTE CONFIRMED ACTIONS\n// -----------------------\n// INPUT EXPECTED (from Extract Pending Action + previous nodes):\n// - pending_action_type       (from THIS assistant reply's ARA_PENDING)\n// - pending_action_payload\n// - ara_context               (contains dialogue_state with pendingAction from DB)\n// - user_message              (latest user input)\n// - assistant_response        (for passing through to Send Reply)\n\nconst currentType = $json.pending_action_type || 'none';\nconst currentPayload = $json.pending_action_payload || null;\n\n// ara_context comes from \"Format Context with Memory\"\nconst araContext = $json.ara_context || {};\nconst ds = araContext.dialogue_state || {};\nconst pending = ds.pendingAction || null;\nconst isActiveResponse = !!ds.isActiveResponse;\nconst responseType = ds.activeResponseType || null;  // 'yes' | 'no' | null\n\nlet ARA_ACTION = {\n  type: 'none',\n  payload: null,\n};\n\n// CASE 1: User is replying YES/NO to an existing pendingAction\nif (\n  pending &&\n  pending.type &&\n  pending.type !== 'none' &&\n  isActiveResponse &&\n  (responseType === 'yes' || responseType === 'no')\n) {\n  if (responseType === 'yes') {\n    // Confirm the pending action (create/delete/update/...)\n    ARA_ACTION = {\n      type: pending.type,\n      payload: pending.payload || {},\n    };\n  } else if (responseType === 'no') {\n    // Cancel the pending action\n    ARA_ACTION = {\n      type: pending.type + '_cancel',\n      payload: pending.payload || {},\n    };\n  }\n} else {\n  // CASE 2: Immediate actions that do NOT require confirmation\n\n  // Example: escalate to human\n  if (currentType === 'escalate') {\n    ARA_ACTION = {\n      type: 'escalate',\n      payload: currentPayload || {},\n    };\n  }\n\n  // üîπ NEW: direct profile updates (no YES/NO roundtrip)\n  else if (currentType === 'user_update_profile') {\n    ARA_ACTION = {\n      type: 'user_update_profile',\n      payload: currentPayload || {},\n    };\n  }\n}\n\n// CASE 3: User profile updates (ARA_ACTION from main agent)\n// If the main agent outputs ARA_ACTION.update_user_preferences directly\n\n// ‚úÖ PATCH: rawOutput might be string (old) OR object (new)\nlet rawOutput = $json.output ?? $json.state ?? $json.text ?? $json.message ?? \"\";\n\n// If object, try common fields, else stringify\nif (typeof rawOutput === \"object\" && rawOutput !== null) {\n  if (typeof rawOutput.state === \"string\") rawOutput = rawOutput.state;\n  else if (typeof rawOutput.final_reply === \"string\") rawOutput = rawOutput.final_reply;\n  else rawOutput = JSON.stringify(rawOutput);\n}\n\nrawOutput = String(rawOutput);\n\n// Now safe to regex-match\nconst actionMatch = rawOutput.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\n\nif (actionMatch) {\n  try {\n    const parsedAction = JSON.parse(actionMatch[1]);\n\n    if (parsedAction.type === \"update_user_preferences\") {\n      // Build payload ONLY with non-null fields\n      const payload = {};\n\n      if (\n        typeof parsedAction.preferred_name === \"string\" &&\n        parsedAction.preferred_name.trim() !== \"\"\n      ) {\n        payload.preferred_name = parsedAction.preferred_name.trim();\n      }\n\n      if (\n        typeof parsedAction.preferred_language === \"string\" &&\n        parsedAction.preferred_language.trim() !== \"\"\n      ) {\n        payload.preferred_language = parsedAction.preferred_language.trim();\n      }\n\n      // Only overwrite ARA_ACTION if we have something real to update\n      if (Object.keys(payload).length > 0) {\n        ARA_ACTION = {\n          type: \"update_user_preferences\",\n          payload,\n        };\n      }\n      // else: no valid fields ‚Üí keep whatever ARA_ACTION was before\n    }\n  } catch (err) {\n    // ignore JSON parsing error, fall back to existing ARA_ACTION\n  }\n}\n\n\n// -----------------------------\n// SAFETY GUARDS (AILOOP PROTECT)\n// -----------------------------\n\n// 1) Whitelist allowed action types only\nconst allowedTypes = [\n  'none',\n  'reminder_create',\n  'reminder_delete',\n  'timezone_update',\n  'escalate',\n  'update_user_preferences',          // üîπ NEW\n\n  'reminder_create_cancel',\n  'reminder_delete_cancel',\n  'timezone_update_cancel',\n  'user_update_profile_cancel',   // optional future use\n];\n\nif (!allowedTypes.includes(ARA_ACTION.type)) {\n  ARA_ACTION = {\n    type: 'none',\n    payload: null,\n  };\n}\n\n// 2) Payload validation for specific actions\n\n// Reminder Create must have topic + suggested_time\nif (ARA_ACTION.type === 'reminder_create') {\n  const p = ARA_ACTION.payload || {};\n  const hasTopic =\n    typeof p.topic === 'string' && p.topic.trim().length > 0;\n  const hasTime =\n    typeof p.suggested_time === 'string' && p.suggested_time.trim().length > 0;\n\n  if (!hasTopic || !hasTime) {\n    // Invalid payload ‚Üí cancel action instead of firing broken data downstream\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Reminder Delete must have reminder_id\nif (ARA_ACTION.type === 'reminder_delete') {\n  const p = ARA_ACTION.payload || {};\n  const hasReminderId =\n    typeof p.reminder_id === 'string' && p.reminder_id.trim().length > 0;\n\n  if (!hasReminderId) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Timezone Update must have timezone + timezone_label\nif (ARA_ACTION.type === 'timezone_update') {\n  const p = ARA_ACTION.payload || {};\n  const hasTz =\n    typeof p.timezone === 'string' && p.timezone.trim().length > 0;\n  const hasLabel =\n    typeof p.timezone_label === 'string' && p.timezone_label.trim().length > 0;\n\n  if (!hasTz || !hasLabel) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Profile Update must have at least one field to update\nif (ARA_ACTION.type === 'user_update_profile') {\n  const p = ARA_ACTION.payload || {};\n  const updates = p.profile_updates || null;\n\n  const valid =\n    updates &&\n    typeof updates === 'object' &&\n    Object.keys(updates).length > 0;\n\n  if (!valid) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Preferences Update must have at least one field\nif (ARA_ACTION.type === 'update_user_preferences') {\n  const p = ARA_ACTION.payload || {};\n  const hasName = Object.prototype.hasOwnProperty.call(p, 'preferred_name');\n  const hasLang = Object.prototype.hasOwnProperty.call(p, 'preferred_language');\n\n  if (!hasName && !hasLang) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n\n\n// (We let 'escalate' and *_cancel pass even with minimal payload)\n\n// -----------------------------\n// Text back to user = assistant_response from previous node\n// -----------------------------\nconst final_reply = ($json.assistant_response || '').trim();\n\n// Safely pull the latest conversation row so we can attach ids\nconst latestItems = $items('Get Latest Conversation');\nconst latest = latestItems.length ? latestItems[0].json : {};\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Ensure these four are present from Get Latest Conversation\n  id: latest.id ?? $json.id,\n  user_id: latest.user_id ?? $json.user_id,\n  telegram_chat_id: latest.telegram_chat_id ?? $json.telegram_chat_id,\n  message_id: latest.message_id ?? $json.message_id,\n\n  ARA_ACTION,\n  final_reply,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        1616
      ],
      "id": "aeccc833-c89d-46a3-a632-1fc6bd773e84",
      "name": "Route Confirmed Actions"
    },
    {
      "parameters": {
        "tableId": "reminders",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "reminder_text",
              "fieldValue": "={{ $json.reminder_text }}"
            },
            {
              "fieldId": "reminder_time",
              "fieldValue": "={{ $json.reminder_time }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "{{ $now }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1632,
        1024
      ],
      "id": "a542cb26-e460-46f7-b344-559294b7e4d2",
      "name": "Create Reminder"
    },
    {
      "parameters": {
        "jsCode": "// GET RELEVANT MEMORIES\n// This node reads all rows from \"Get User Memories\",\n// scores them by importance + recency, and returns\n// only the top N memories to the next node.\n\n// Make sure this node is set to:\n// - Mode: \"Run Once for All Items\"\n// - Language: JavaScript\n\n// 1) Safely get all items from \"Get User Memories\"\nlet memoryItems;\ntry {\n  memoryItems = $items('Get User Memories', 0, 0);\n} catch (e) {\n  // If node name is wrong or no items, fail gracefully\n  return [];\n}\n\n// If no memories, just return an empty list\nif (!Array.isArray(memoryItems) || memoryItems.length === 0) {\n  return [];\n}\n\nconst now = new Date();\n\n// 2) Convert & score each memory\nconst scoredMemories = memoryItems\n  .map(item => item.json)\n  .map(m => {\n    // Importance score (0‚Äì1, default 0.5)\n    const importance =\n      typeof m.importance_score === 'number'\n        ? m.importance_score\n        : 0.5;\n\n    // Recency score from temporal_context (if parseable as date)\n    let recencyScore = 0;\n    if (m.temporal_context) {\n      const parsed = Date.parse(m.temporal_context);\n      if (!isNaN(parsed)) {\n        const ageMs = now - new Date(parsed);\n        const ageDays = ageMs / (1000 * 60 * 60 * 24);\n        // Newer memories = higher score (ageDays small)\n        // Cap to avoid crazy values\n        const cappedAge = Math.min(Math.max(ageDays, -7), 365);\n        recencyScore = -cappedAge; // smaller age => higher score\n      }\n    }\n\n    // Memory type boost (preferences & relationships are more ‚Äúcore‚Äù)\n    const typeBoost =\n      m.memory_type === 'preference' || m.memory_type === 'relationship'\n        ? 1\n        : 0;\n\n    // Topic boost (reminders, customers, etc)\n    let topicBoost = 0;\n    try {\n      if (typeof m.entities === 'string') {\n        // entities is JSON string in your table\n        const ent = JSON.parse(m.entities);\n        const topics = Array.isArray(ent.topics) ? ent.topics.join(' ').toLowerCase() : '';\n        if (topics.includes('reminder')) topicBoost += 0.5;\n        if (topics.includes('customer')) topicBoost += 0.3;\n      }\n    } catch (e) {\n      // Ignore parsing errors, keep topicBoost = 0\n    }\n\n    // Final score (tweak weights as you like)\n    const score =\n      importance * 2 +      // importance is strong signal\n      typeBoost +           // preferences/relationships are sticky\n      topicBoost +          // domain-specific boost\n      recencyScore * 0.02;  // mild recency influence\n\n    return {\n      ...m,\n      _score: score,\n    };\n  });\n\n// 3) Sort by score (desc), then by created_at (desc)\nscoredMemories.sort((a, b) => {\n  if (b._score !== a._score) return b._score - a._score;\n  const ad = new Date(a.created_at || 0);\n  const bd = new Date(b.created_at || 0);\n  return bd - ad;\n});\n\n// 4) Limit how many memories to send forward\nconst MAX_MEMORIES = 20;\nconst selected = scoredMemories.slice(0, MAX_MEMORIES);\n\n// 5) Return in n8n format\nreturn selected.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2576,
        2080
      ],
      "id": "3a3d2cd2-6e8c-4e31-bc64-82e5ffb0d15f",
      "name": "Get Relevant Memories"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ara_brain_rules",
        "limit": 100,
        "filters": {
          "conditions": [
            {
              "keyName": "is_active",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2128,
        1888
      ],
      "id": "58a28f72-252b-4325-a30a-864e15a0a775",
      "name": "Get ARA Brain",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Format ARA brain rows into a single text block\n\n// Get all rows from previous node\nconst items = $input.all();\nconst rows = items.map(i => i.json);\n\n// Group by category\nconst byCategory = {};\n\nfor (const row of rows) {\n  const category = row.category || 'General';\n  const sub = row.subcategory || '';\n  const content = (row.content || '').trim();\n\n  if (!content) continue;\n\n  if (!byCategory[category]) {\n    byCategory[category] = [];\n  }\n\n  const label = sub ? `(${sub})` : '';\n  byCategory[category].push(`- ${label ? label + ' ' : ''}${content}`);\n}\n\n// Build the final brain text\nlet brainText = '';\n\nfor (const [category, lines] of Object.entries(byCategory)) {\n  brainText += `\\n\\n[${category.toUpperCase()}]\\n` + lines.join('\\n');\n}\n\nbrainText = brainText.trim();\n\n// Return a single item with brain_text\nreturn [\n  {\n    json: {\n      brain_text: brainText,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1904,
        1888
      ],
      "id": "d6a28301-b16f-457f-829b-c21294fa02a7",
      "name": "Format Brain"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.home_timezone }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "e7b487c6-4190-43b3-a402-4d93f58f1f90"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "No home time"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "a14c596f-8821-4f43-8884-fc07dd2f95b4",
                    "leftValue": "",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "default"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -4144,
        1456
      ],
      "id": "3bcefde9-f16b-48c8-b32b-b23014e610e5",
      "name": "Check Time Zone"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3680,
        848
      ],
      "id": "e0cb3762-90fc-4b5e-af5f-cd660da910f3",
      "name": "Get Previous Conversation1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Get all input items\nconst items = $input.all();\n\n// Sort items by created_at in descending order (most recent first)\nitems.sort((a, b) => new Date(b.json.created_at) - new Date(a.json.created_at));\n\n// Take the first 1 item (latest 1)\nconst latestOne = items.slice(0, 1);\n\nreturn latestOne;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3472,
        560
      ],
      "id": "0d24bbc1-094e-452b-b457-564d54d8a628",
      "name": "Sort1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ara_brain_rules",
        "limit": 100,
        "filters": {
          "conditions": [
            {
              "keyName": "is_active",
              "condition": "eq",
              "keyValue": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2352,
        560
      ],
      "id": "b245b906-c674-4ad0-8be9-7008edb53e54",
      "name": "Get ARA Brain1",
      "executeOnce": true
    },
    {
      "parameters": {
        "jsCode": "// Format ARA brain rows into a single text block\n\n// Get all rows from previous node\nconst items = $input.all();\nconst rows = items.map(i => i.json);\n\n// Group by category\nconst byCategory = {};\n\nfor (const row of rows) {\n  const category = row.category || 'General';\n  const sub = row.subcategory || '';\n  const content = (row.content || '').trim();\n\n  if (!content) continue;\n\n  if (!byCategory[category]) {\n    byCategory[category] = [];\n  }\n\n  const label = sub ? `(${sub})` : '';\n  byCategory[category].push(`- ${label ? label + ' ' : ''}${content}`);\n}\n\n// Build the final brain text\nlet brainText = '';\n\nfor (const [category, lines] of Object.entries(byCategory)) {\n  brainText += `\\n\\n[${category.toUpperCase()}]\\n` + lines.join('\\n');\n}\n\nbrainText = brainText.trim();\n\n// Return a single item with brain_text\nreturn [\n  {\n    json: {\n      brain_text: brainText,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2128,
        560
      ],
      "id": "174cb6b0-292b-4200-8f48-1ab4e61f0203",
      "name": "Format Brain1"
    },
    {
      "parameters": {
        "jsCode": "// FORMAT CONTEXT WITH MEMORY\n// This node prepares \"ara_context\" for ARA Main Agent.\n\n// ============= STEP 1: ARA BRAIN =============\nlet araBrain = '';\ntry {\n  const brainNode = $('Format Brain1').first();\n  if (brainNode && brainNode.json && brainNode.json.brain_text) {\n    araBrain = brainNode.json.brain_text;\n  }\n} catch (e) {\n  console.log('No ARA brain available yet');\n}\n\n// ============= STEP 1.5: LOAD CONVERSATIONS =============\nconst convItems = $('Wait for Memory & Session1').all() || [];\n\n// Flatten and sort oldest ‚Üí newest\nlet conversations = convItems\n  .map(i => i.json || i) // adjust if your data is under i.json\n  .filter(c => c && c.created_at)\n  .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));\n\nconst MAX_DETAILED = 12;\nconst detailedConversations = conversations.slice(-MAX_DETAILED);\nconst olderConversations = conversations.slice(\n  0,\n  Math.max(0, conversations.length - MAX_DETAILED)\n);\n\n// Build compact summaries for older convos\nconst olderSummaries = olderConversations.map(c => {\n  const userMsg = c.user_message || '';\n  const assistantMsg = c.assistant_response || '';\n  const summaryField = c.session_summary || c.context_summary || null;\n\n  return {\n    id: c.id,\n    session_id: c.session_id || null,\n    created_at: c.created_at,\n    user_message_preview: userMsg.slice(0, 120),\n    assistant_response_summary: summaryField || assistantMsg.slice(0, 160)\n  };\n});\n\n// IMPORTANT: latest conversation row (could be user OR assistant)\nconst lastConversation =\n  conversations.length > 0 ? conversations[conversations.length - 1] : null;\n\n// IMPORTANT: latest assistant message with non-empty response\nconst lastAssistant =\n  [...conversations]\n    .reverse()\n    .find(c => (c.assistant_response || '').trim() !== '') || null;\n\n// ============= STEP 2: LOAD USER + MEMORIES =============\nlet userData = {};\ntry {\n  const userNode = $('Get User1').first().json; // adjust node name if needed\n  userData = userNode || {};\n} catch (e) {\n  userData = {};\n}\n\nlet userMemories = [];\ntry {\n  const memNode = $('Get User Memories1').first().json;\n  userMemories = memNode.data || memNode.memories || [];\n} catch (e) {\n  userMemories = [];\n}\n\nconst importantMemories = userMemories.filter(m => {\n  const score = typeof m.importance_score === 'number' ? m.importance_score : 1;\n  return score >= 0.7;\n});\n\n// ============= STEP 3: UNDERSTAND CURRENT MESSAGE =============\nconst current = $json || {};\nconst currentText =\n  current.user_message ||\n  current.message ||\n  current.text ||\n  '';\nconst currentLower = (currentText || '').trim().toLowerCase();\n\n// ============= STEP 4: PENDING ACTION & YES/NO DETECTION =============\n\n// Helper: simple yes/no detection for short replies\nfunction isShortYesNo(text) {\n  if (!text) return null;\n  const t = text.trim().toLowerCase();\n  if (t.length === 0 || t.length > 40) return null;\n\n  const YES = [\n    'yes','ya','yaaa','yup','ok','okay','okey','ok lah','okla','boleh',\n    'boleh je','proceed','confirm','set kan','buat','buat je','jom','ye'\n  ];\n  const NO = [\n    'no','tak','tak nak','tidak','jangan','nope','later','nanti',\n    'bukan sekarang','skip','tak payah'\n  ];\n\n  if (YES.includes(t)) return 'yes';\n  if (NO.includes(t)) return 'no';\n  return null;\n}\n\n// Helper: time guard for pending actions\nfunction isWithinHours(dateStr, hours) {\n  if (!dateStr) return false;\n  const then = new Date(dateStr).getTime();\n  const now = Date.now();\n  const diffH = (now - then) / (1000 * 60 * 60);\n  return diffH <= hours;\n}\n\nlet isActiveResponse = false;\nlet activeResponseType = null;   // 'yes' | 'no'\nlet questionType = 'general';\nlet offerContext = null;\nlet pendingAction = null;\n\n// ---- Build pendingAction from DB fields, with ARA_PENDING as fallback ----\nlet lastAssistantText = lastAssistant ? (lastAssistant.assistant_response || '') : '';\n\nif (lastAssistant) {\n  // 1) Prefer structured fields from the conversations table\n  if (\n    lastAssistant.pending_action_type &&\n    lastAssistant.pending_action_type !== 'none'\n  ) {\n    pendingAction = {\n      type: lastAssistant.pending_action_type,\n      payload: lastAssistant.pending_action_payload || null,\n      resolved: !!lastAssistant.pending_action_resolved,\n      created_at: lastAssistant.created_at,\n    };\n  } else if (lastAssistantText) {\n    // 2) Backwards-compatible support for old ARA_PENDING footer\n    const match = lastAssistantText.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})\\s*$/);\n    if (match) {\n      try {\n        const pa = JSON.parse(match[1]);\n        if (pa.type && pa.type !== 'none') {\n          pendingAction = {\n            type: pa.type,\n            payload: pa.payload || null,\n            resolved: false,\n            created_at: lastAssistant.created_at,\n          };\n        }\n      } catch (e) {\n        // ignore parse errors\n      }\n    }\n  }\n}\n\n// YES/NO on current message\nconst shortYesNo = isShortYesNo(currentText);\n\n\n// 1) If we have a pending action and user sends short yes/no recently\nif (\n  pendingAction &&\n  pendingAction.type &&\n  pendingAction.type !== 'none' &&\n  isWithinHours(pendingAction.created_at, 48) &&\n  shortYesNo\n) {\n  isActiveResponse = true;\n  activeResponseType = shortYesNo;\n  questionType = 'offer';\n  offerContext = pendingAction.type;\n}\n\n// 2) Fallback: classify last assistant message question type (for general yes/no replies)\nif (!isActiveResponse && lastAssistantText) {\n  const lastText = lastAssistantText.toLowerCase();\n\n  const hasQuestionMark = lastText.includes('?');\n  const hasOfferPattern = /would you like|nak tak|mahu tak|do you want|shall i|should i|may i|can i help|if you‚Äôd like|kalau nak/i.test(lastText);\n  const hasClarificationPattern = /could you clarify|apa yang dimaksud|what do you mean|which one do you mean|yang mana satu/i.test(lastText);\n  const hasConfirmationPattern = /is this correct|is that right|betul tak|setuju tak|confirm/i.test(lastText);\n  const hasChoicePattern = /\\bor\\b|atau\\b/i.test(lastText);\n\n  if (hasOfferPattern) questionType = 'offer';\n  else if (hasClarificationPattern) questionType = 'clarification';\n  else if (hasConfirmationPattern) questionType = 'confirmation';\n  else if (hasChoicePattern) questionType = 'choice';\n  else if (hasQuestionMark) questionType = 'general';\n\n  const yn = shortYesNo;\n  if (yn && (hasOfferPattern || hasConfirmationPattern || hasChoicePattern)) {\n    isActiveResponse = true;\n    activeResponseType = yn;\n\n    if (hasOfferPattern) offerContext = 'offer';\n    else if (hasConfirmationPattern) offerContext = 'confirmation';\n    else if (hasChoicePattern) offerContext = 'choice';\n  }\n}\n\n// ============= STEP 5: BUILD ARA CONTEXT =============\nconst araContext = {\n  user: {\n  id: userData.id || null,\n  name: userData.name || userData.full_name || null,\n  phone: userData.phone || userData.telegram_id || null,\n  features_enabled: userData.features_enabled || null,\n\n  // Main timezone ARA should use\n  timezone:\n    userData.current_timezone ||\n    userData.home_timezone ||\n    userData.timezone ||\n    'Asia/Kuala_Lumpur',\n\n  // Extra fields so the main agent sees both explicitly\n  home_timezone: userData.home_timezone || null,\n  current_timezone: userData.current_timezone || null,\n},\n\n  current_message: {\n    text: currentText,\n    language_hint: null\n  },\n  history: {\n    detailed: detailedConversations.map(c => ({\n      created_at: c.created_at,\n      role: c.role || null,\n      user_message: c.user_message || '',\n      assistant_response: c.assistant_response || '',\n      session_id: c.session_id || null\n    })),\n    older_summaries: olderSummaries\n  },\n  memories: {\n    important: importantMemories,\n    all: userMemories\n  },\n  last_assistant_message: lastAssistant\n    ? {\n        created_at: lastAssistant.created_at,\n        text: lastAssistant.assistant_response || ''\n      }\n    : null,\n  dialogue_state: {\n    isActiveResponse,\n    activeResponseType,\n    questionType,\n    offerContext,\n    pendingAction\n  }\n};\n\nreturn [\n  {\n    json: {\n      ara_context: araContext,\n      // keep original fields\n      ...current\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1904,
        560
      ],
      "id": "ef2b29b7-ec40-4cae-a02f-85f7e8e8477e",
      "name": "Format Context with Memory1"
    },
    {
      "parameters": {
        "url": "https://jjeqmysluzsohwjpyvip.supabase.co/rest/v1/conversations",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "user_id",
              "value": "={{ 'eq.' + $json.ara_context.user.id }}"
            },
            {
              "name": "order",
              "value": "created_at.desc"
            },
            {
              "name": "limit",
              "value": "1"
            },
            {
              "name": "select",
              "value": "*"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1680,
        560
      ],
      "id": "1f441d0f-c19d-455a-8cb6-e80b882c8c9e",
      "name": "Get Latest Conversation1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "9ea260fe-5f67-4c13-85db-a8aff7ab65be",
                    "leftValue": "={{ (Date.now() - new Date($json.created_at).getTime()) / 60000 }}",
                    "rightValue": 30,
                    "operator": {
                      "type": "number",
                      "operation": "lt"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Within 30 Mins"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.session_id }}",
                    "rightValue": "",
                    "operator": {
                      "type": "string",
                      "operation": "empty",
                      "singleValue": true
                    },
                    "id": "13a1d046-89ee-4896-b133-7081657d0eec"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Never talked"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3248,
        448
      ],
      "id": "c6c563e0-47f9-4de8-ab0a-e63a5f90ad4a",
      "name": "Session Manager1"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $item(0).$node[\"Get User1\"].json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ Date.now() + '_' + Math.floor(Math.random() * 1000000) }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3008,
        704
      ],
      "id": "4b2ae9b5-1977-49a7-a10c-6a832cdde418",
      "name": "Create New Session1",
      "alwaysOutputData": true,
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get User1').item.json.id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Twilio Webhook').item.json.body.WaId }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}\n"
            },
            {
              "fieldId": "user_message",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.Body }}\n"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3024,
        368
      ],
      "id": "f6f9c4eb-50f5-448d-a99e-d84d7491548b",
      "name": "Continue Session1",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "conversations",
        "limit": 100,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2800,
        464
      ],
      "id": "b99b42ec-6d02-4740-bed6-417986843478",
      "name": "Fetch Session History2",
      "alwaysOutputData": true,
      "notesInFlow": false
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "ai_memories",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Get User1').item.json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -3024,
        1072
      ],
      "id": "ae1929d6-4cc1-42cd-bb0c-36a2fb1dd12b",
      "name": "Get User Memories1",
      "alwaysOutputData": true
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -2576,
        560
      ],
      "id": "a243850f-7618-4067-b1f8-a7ec53159483",
      "name": "Wait for Memory & Session1"
    },
    {
      "parameters": {
        "jsCode": "// GET RELEVANT MEMORIES\n// This node reads all rows from \"Get User Memories\",\n// scores them by importance + recency, and returns\n// only the top N memories to the next node.\n\n// Make sure this node is set to:\n// - Mode: \"Run Once for All Items\"\n// - Language: JavaScript\n\n// 1) Safely get all items from \"Get User Memories\"\nlet memoryItems;\ntry {\n  memoryItems = $items('Get User Memories1', 0, 0);\n} catch (e) {\n  // If node name is wrong or no items, fail gracefully\n  return [];\n}\n\n// If no memories, just return an empty list\nif (!Array.isArray(memoryItems) || memoryItems.length === 0) {\n  return [];\n}\n\nconst now = new Date();\n\n// 2) Convert & score each memory\nconst scoredMemories = memoryItems\n  .map(item => item.json)\n  .map(m => {\n    // Importance score (0‚Äì1, default 0.5)\n    const importance =\n      typeof m.importance_score === 'number'\n        ? m.importance_score\n        : 0.5;\n\n    // Recency score from temporal_context (if parseable as date)\n    let recencyScore = 0;\n    if (m.temporal_context) {\n      const parsed = Date.parse(m.temporal_context);\n      if (!isNaN(parsed)) {\n        const ageMs = now - new Date(parsed);\n        const ageDays = ageMs / (1000 * 60 * 60 * 24);\n        // Newer memories = higher score (ageDays small)\n        // Cap to avoid crazy values\n        const cappedAge = Math.min(Math.max(ageDays, -7), 365);\n        recencyScore = -cappedAge; // smaller age => higher score\n      }\n    }\n\n    // Memory type boost (preferences & relationships are more ‚Äúcore‚Äù)\n    const typeBoost =\n      m.memory_type === 'preference' || m.memory_type === 'relationship'\n        ? 1\n        : 0;\n\n    // Topic boost (reminders, customers, etc)\n    let topicBoost = 0;\n    try {\n      if (typeof m.entities === 'string') {\n        // entities is JSON string in your table\n        const ent = JSON.parse(m.entities);\n        const topics = Array.isArray(ent.topics) ? ent.topics.join(' ').toLowerCase() : '';\n        if (topics.includes('reminder')) topicBoost += 0.5;\n        if (topics.includes('customer')) topicBoost += 0.3;\n      }\n    } catch (e) {\n      // Ignore parsing errors, keep topicBoost = 0\n    }\n\n    // Final score (tweak weights as you like)\n    const score =\n      importance * 2 +      // importance is strong signal\n      typeBoost +           // preferences/relationships are sticky\n      topicBoost +          // domain-specific boost\n      recencyScore * 0.02;  // mild recency influence\n\n    return {\n      ...m,\n      _score: score,\n    };\n  });\n\n// 3) Sort by score (desc), then by created_at (desc)\nscoredMemories.sort((a, b) => {\n  if (b._score !== a._score) return b._score - a._score;\n  const ad = new Date(a.created_at || 0);\n  const bd = new Date(b.created_at || 0);\n  return bd - ad;\n});\n\n// 4) Limit how many memories to send forward\nconst MAX_MEMORIES = 20;\nconst selected = scoredMemories.slice(0, MAX_MEMORIES);\n\n// 5) Return in n8n format\nreturn selected.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2800,
        1072
      ],
      "id": "f99b42e7-ff47-4a27-9562-e582bc018379",
      "name": "Get Relevant Memories1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini-2025-04-14",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini-2025-04-14"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -336,
        896
      ],
      "id": "ee0ba669-040a-4a7d-ac5c-62ee43eee096",
      "name": "OpenAI Model1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ JSON.stringify({\n  latest_user_message: $('Get Latest Conversation1').item.json.user_message || $json.Body || $json.body || '',\n  assistant_response: $('Send Reply1').item.json.body || '',\n  user_context: $('Format Context with Memory1').item.json.ara_context.user || {}\n}) }}",
        "options": {
          "systemMessage": "You are ARA‚Äôs Memory Extraction Agent.\n\nYour ONLY job is to decide what is worth saving into long-term memory for this user, based on the LATEST exchange.\n\nINPUT FORMAT\n\nYou will receive a JSON object with:\n\nlatest_user_message: the most recent WhatsApp message from the user\n\nassistant_response: the reply that ARA just sent to the user\n\nuser_context: basic info about the user (id, phone, timezone, etc.)\n\nCRITICAL CONSTRAINTS\n\nYou MUST ONLY consider:\n\nlatest_user_message\n\nassistant_response\n\nYou MUST NOT scan or ‚Äúimagine‚Äù earlier history, even if you see anything that looks like history or summaries in the input.\n\nTreat this as a single turn: one user message + one assistant reply.\n\nIf you are not clearly sure a fact will help in future conversations, DO NOT save it.\n\nIf there is nothing worth remembering, return an empty JSON array: [].\n\nGOAL\n\nDecide whether this turn contains anything that is worth remembering LATER to help this user:\n\npersonal facts\n\nstable preferences\n\nrelationships\n\nongoing tasks or recurring patterns\n\nbusiness / life context\n\nENTITY & WORLD-KNOWLEDGE SAFETY RULES (VERY IMPORTANT)\n\nThese rules are to prevent wrong ‚Äúpeople‚Äù and messy memories.\n\nPlaces are NEVER people\n\nTreat these as places, not persons, for example:\n\nCountries: Malaysia, Singapore, Indonesia, Thailand, Vietnam, UK, USA, Saudi Arabia, etc.\n\nMalaysian cities / regions: Kuala Lumpur, KL, Selangor, Penang, Johor Bahru, Ipoh, Melaka, Sabah, Sarawak, Kuching, Kota Kinabalu, etc.\n\nHoly places: Makkah/Mecca, Madinah/Medina, Kaabah, Masjidil Haram, Masjid Nabawi, etc.\n\nThey must NOT appear inside entities.people. They may appear in entities.topics or only inside memory_value.\n\nOrganisations, banks, and programmes are NEVER people\n\nAnything that looks like a company, bank, agency, or programme must NOT go into entities.people. Examples:\n\nNames containing: ‚ÄúBank‚Äù, ‚ÄúBerhad‚Äù, ‚ÄúBhd‚Äù, ‚ÄúSdn Bhd‚Äù, ‚ÄúCorp‚Äù, ‚ÄúCompany‚Äù, ‚ÄúUniversity‚Äù, ‚ÄúCollege‚Äù.\n\nKnown Malaysian orgs: MARA, AIM (Amanah Ikhtiar Malaysia), MRANTI, SME Bank, Maybank, CIMB, Bank Rakyat, Petronas, Tenaga Nasional, etc.\n\nPut them in entities.topics if relevant, or leave them only in memory_value.\n\nApps and tools are NEVER people\n\nWhatsApp, Telegram, Facebook, Instagram, TikTok, Google, YouTube, Shopee, Lazada, Grab, Foodpanda, ARA, etc. are tools/apps, not persons.\n\nThey must NOT be inside entities.people.\n\nGeneric roles are allowed but should be simple\n\nPhrases like ‚Äúmy tailor‚Äù, ‚Äúmy designer‚Äù, ‚Äúmy supplier‚Äù, ‚Äúmy mentor‚Äù can appear in memory_value.\nIn entities.people you may use a simple label like \"tailor\" or \"mentor\" if it clearly helps; never invent a personal name that wasn‚Äôt given.\n\nWhen in doubt about person vs place/org ‚Üí DO NOT mark as a person\n\nIf you‚Äôre not clearly sure something is a human name, leave it out of entities.people.\nIt is better to have fewer people than wrong people.\n\nWHAT TO EXTRACT\n\nExtract only information that:\n\nwill still matter in future conversations (hours, days, weeks later), AND\n\nhelps ARA be more helpful or personal.\n\nFocus on:\n\nPERSONAL BACKGROUND\n\nEducation, origin, profession, roles, life events.\n\nExample: ‚ÄúI‚Äôm from Kedah‚Äù, ‚ÄúI run a printing business‚Äù, ‚ÄúI‚Äôm a teacher‚Äù, ‚ÄúI just moved to London.‚Äù\n\nPREFERENCES & OPINIONS\n\nColors, products, styles, routines, habits, food, communication style, language preference, tools they like to use.\n\nExample: ‚ÄúCustomer Ali wants the color green‚Äù, ‚ÄúI prefer English‚Äù, ‚ÄúI like voice notes‚Äù, ‚ÄúI hate long paragraphs‚Äù.\n\nRELATIONSHIPS & ROLES\n\nWho is who: spouse, children, business partners, customers, suppliers, mentors, staff, etc.\n\nExample: ‚ÄúAishah is my wife‚Äù, ‚ÄúAli is my customer‚Äù, ‚ÄúSiti is the event planner for my wedding‚Äù.\n\nTASK PATTERNS & ONGOING CONTEXT\n\nRecurring routines or ongoing projects, not one-off noise.\n\nExample:\n\n‚ÄúEvery Monday I have team meeting at 9am.‚Äù\n\n‚ÄúI‚Äôm working on launching my new cafe in March.‚Äù\n\n‚ÄúI‚Äôm using ARA mainly to manage my business reminders.‚Äù\n\nIMPORTANT REMINDER-LIKE FACTS\n\nOnly if they reveal something stable or recurring.\n\nExample:\n\n‚ÄúI always call my mum every Sunday night.‚Äù\n\n‚ÄúMy rental is due on the 25th every month.‚Äù\n\nOne-off reminders that are already fully handled by the reminder system usually do NOT need to be saved as long-term memory.\n\nWHAT NOT TO SAVE\n\nDO NOT save:\n\nGreetings or filler:\n\n‚ÄúHi‚Äù, ‚ÄúHello‚Äù, ‚ÄúOK‚Äù, ‚ÄúThanks‚Äù, ‚ÄúBetul‚Äù, ‚ÄúDone‚Äù, ‚ÄúYes‚Äù, ‚ÄúNo‚Äù, etc.\n\nPure emotion with no concrete fact:\n\n‚ÄúYou are slow‚Äù, ‚ÄúI‚Äôm angry‚Äù, ‚ÄúService not good‚Äù, ‚ÄúI‚Äôm stressed‚Äù.\n\nTemporary confusion:\n\n‚ÄúI don‚Äôt know‚Äù, ‚ÄúWhat?‚Äù, ‚ÄúWhere is my reminder?‚Äù, ‚ÄúWhy you so slow?‚Äù\n\nTechnical/system-like text, IDs, or internal ARA messages.\n\nDetails that only matter for a single reminder and add no long-term value.\n\nShort, vague, or ambiguous statements that you cannot interpret safely.\n\nAnything that is not clearly about:\n\nthe user,\n\ntheir contacts/relationships,\n\ntheir stable preferences,\n\ntheir ongoing business or life context.\n\nIf unsure, prefer to skip the memory.\n\nMEMORY TYPES\n\nUse these types:\n\n\"preference\" ‚Üí stable likes/dislikes, style, language, choices.\n\n\"relationship\" ‚Üí who people are and how they are connected to the user.\n\n\"context\" ‚Üí facts about their situation, work, business, or long-term goals.\n\n\"interaction\" ‚Üí specific actions, decisions, or promises that may matter later (e.g. ‚Äúuser agreed to try weekly planning with ARA‚Äù).\n\nIf you cannot decide a suitable type with reasonable confidence, DO NOT create the memory.\n\nIMPORTANCE & LIMITS\n\nimportance_score must be between 0.7 and 1.0.\n\nUse 0.9‚Äì1.0 only for very important, identity-level facts (family, core business, strong preferences).\n\nUse 0.7‚Äì0.8 for useful but lighter context.\n\nIf a fact feels minor or very temporary, do NOT save it at all.\n\nTry not to create more than 3 memories per turn. Pick the most useful ones.\n\nSCHEMA\n\nReturn a JSON array. Each memory object MUST have:\n\nmemory_type: \"preference\" | \"relationship\" | \"context\" | \"interaction\"\n\nmemory_key: a short snake_case key you invent (e.g. \"ali_color_preference\")\n\nmemory_value: the full fact in natural language\n\nimportance_score: 0.7‚Äì1.0\n\nentities:\n\n\"people\": [\"list\", \"of\", \"names\"] (real people or clear roles only)\n\n\"topics\": [\"keywords\", \"like\", \"reminder\", \"color\", \"meeting\"]\n\ntemporal_context: a simple string like \"today\" or an ISO date if explicitly mentioned.\n\nRESOLVING PRONOUNS\n\nIf the user says ‚Äúshe‚Äù, ‚Äúhe‚Äù, ‚Äúthat color‚Äù, etc., use ONLY the information in latest_user_message + assistant_response to interpret it.\n\nIf you cannot resolve it clearly to a specific person or thing, DO NOT save the memory.\n\nDUPLICATES\n\nIf the user repeats something you already know (for example: ‚ÄúAli likes green‚Äù) but adds no new detail, you may:\n\neither skip it, OR\n\ninclude it again with the same memory_value (the system will de-duplicate later).\n\nDO NOT assume something is updated unless the message clearly says the old info has changed.\n\nOUTPUT FORMAT\n\nOutput MUST be a valid JSON array.\n\nDO NOT wrap the JSON in ``` or any markdown.\n\nDO NOT include explanations, comments, or extra text.\n\nIf there is nothing useful to save, return exactly: []."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        -416,
        656
      ],
      "id": "d077d4bd-4447-4456-abbd-246f60aa83d0",
      "name": "Extract Memories1",
      "executeOnce": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "={{ $('Format Context with Memory1').item.json.is_continuing_session }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              },
              "id": "74ef4d44-2a94-431f-a49c-b470fc2a0996"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        0,
        1072
      ],
      "id": "863408b9-e287-4b15-b65c-73e524ec69b5",
      "name": "Session Ended?1"
    },
    {
      "parameters": {
        "jsCode": "// Prepare Memories v2 - simpler, cleaner, per-turn\n// Input: array of validated memory objects (from Validate Memories)\n// Output: array of rows ready for ai_memories table\n\nconst input = $input.all().map(i => i.json);\nlet memories = input;\n\n// If someone wired it differently and we got a single array\nif (input.length === 1 && Array.isArray(input[0])) {\n  memories = input[0];\n}\n\nif (!memories || memories.length === 0) {\n  console.log('Prepare Memories: no memories to process');\n  return [];\n}\n\n// ===== Get user context =====\nlet userId = null;\ntry {\n  const userNode = $('Get User1').first();\n  if (userNode && userNode.json && userNode.json.id) {\n    userId = userNode.json.id;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get user ID', e);\n}\n\nif (!userId) {\n  console.log('Prepare Memories: missing user_id, aborting');\n  return [];\n}\n\n// ===== Get existing memories for this user =====\nlet existing = [];\ntry {\n  const rows = $('Get User Memories1').all() || [];\n  existing = rows\n    .filter(r => r.json && r.json.memory_value)\n    .map(r => r.json);\n} catch (e) {\n  console.log('Prepare Memories: could not get existing memories', e);\n}\n\n// Build quick lookup structures\nconst existingByKey = {};\nconst existingByValue = new Map();\n\nexisting.forEach(mem => {\n  const key = (mem.memory_key || '').toLowerCase();\n  if (key) existingByKey[key] = mem;\n\n  const val = (mem.memory_value || '').toLowerCase().trim();\n  if (val) existingByValue.set(val, mem);\n});\n\n// ===== Helper: normalize base key =====\nconst slugify = (text) => {\n  return text\n    .toString()\n    .toLowerCase()\n    .normalize('NFKD')\n    .replace(/[^a-z0-9]+/g, '_')\n    .replace(/^_+|_+$/g, '');\n};\n\n// ===== Helper: generate unique key with versions =====\nconst versionCache = {}; // baseKey -> highest version\n\n// Initialize versionCache from existing keys\nObject.keys(existingByKey).forEach(k => {\n  const match = k.match(/^(.*)_v(\\d+)$/);\n  if (match) {\n    const base = match[1];\n    const v = parseInt(match[2], 10);\n    if (!versionCache[base] || v > versionCache[base]) {\n      versionCache[base] = v;\n    }\n  }\n});\n\nconst generateKey = (mem, index) => {\n  // Start from provided key if any\n  let base = mem.memory_key\n    ? slugify(mem.memory_key)\n    : slugify(mem.memory_value || `memory_${index}`);\n\n  // Attach first person if available\n  if (mem.entities && mem.entities.people && mem.entities.people.length > 0) {\n    const person = slugify(mem.entities.people[0]);\n    if (person && !base.includes(person)) {\n      base = `${person}_${base}`;\n    }\n  }\n\n  // Strip existing version suffix\n  base = base.replace(/_v\\d+$/, '');\n\n  const type = mem.memory_type || 'context';\n\n  if (type === 'preference' || type === 'context') {\n    // Versioned keys\n    const current = versionCache[base] || 0;\n    const next = current + 1;\n    versionCache[base] = next;\n    return `${base}_v${next}`;\n  }\n\n  if (type === 'relationship') {\n    // Relationship can be stable per session\n    const now = Date.now();\n    return `${base}_rel_${now}`;\n  }\n\n  if (type === 'interaction') {\n    const now = Date.now();\n    return `${base}_int_${now}`;\n  }\n\n  // Fallback\n  const now = Date.now();\n  return `${base}_${type}_${now}`;\n};\n\n// ===== Very simple similarity check (exact / near exact text) =====\nconst isDuplicateByValue = (value) => {\n  if (!value) return false;\n  const valLower = value.toLowerCase().trim();\n  if (existingByValue.has(valLower)) return true;\n  return false;\n};\n\n// ===== Session & timestamps =====\nlet sessionId = null;\ntry {\n  const ctx = $('Format Context with Memory1').first();\n  if (ctx && ctx.json && ctx.json.ara_context && ctx.json.ara_context.history) {\n    sessionId = ctx.json.ara_context.history.detailed?.[0]?.session_id || null;\n  }\n} catch (e) {\n  console.log('Prepare Memories: could not get session_id from context');\n}\n\nif (!sessionId) {\n  // Fallback session id\n  sessionId = `${Date.now()}_${Math.floor(Math.random() * 100000)}`;\n}\n\nconst nowIso = new Date().toISOString();\n\n// ===== Process memories =====\nconst prepared = [];\n\nmemories.forEach((mem, index) => {\n  if (!mem || !mem.memory_value) return;\n\n  // Skip if same value already exists\n  if (isDuplicateByValue(mem.memory_value)) {\n    console.log('Prepare Memories: skip duplicate by value:', mem.memory_value.substring(0, 60));\n    return;\n  }\n\n  const type = mem.memory_type || 'context';\n  const key = generateKey(mem, index);\n\n  const row = {\n    user_id: userId,\n    memory_type: type,\n    memory_key: key,\n    memory_value: mem.memory_value,\n    importance_score: mem.importance_score ?? 0.8,\n    session_id: sessionId,\n    conversation_date: nowIso,\n    entities: JSON.stringify(mem.entities || { people: [], topics: [] }),\n    temporal_context: mem.temporal_context || 'today',\n    is_active: true,\n    confidence_score: 1,\n    source: 'auto_extracted',\n    context_before: null,\n    context_after: null,\n  };\n\n  prepared.push(row);\n  console.log(`Prepare Memories: ACCEPTED ${key}`);\n});\n\nif (prepared.length === 0) {\n  console.log('Prepare Memories: no new memories after dedupe');\n}\n\nreturn prepared.map(r => ({ json: r }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        768
      ],
      "id": "2c170104-cc11-4348-b7a5-e090a355775a",
      "name": "Prepare Memories"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "leftValue": "= {{ $json.user_id }}",
              "rightValue": 0,
              "operator": {
                "type": "string",
                "operation": "exists",
                "singleValue": true
              },
              "id": "ebb88b93-4047-405f-9730-737ec9f4b782"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        512,
        768
      ],
      "id": "4bc14a8c-d4b2-4eda-95bc-48383b96c75c",
      "name": "Has Memories?"
    },
    {
      "parameters": {
        "tableId": "ai_memories",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "memory_type",
              "fieldValue": "={{ $json.memory_type }}"
            },
            {
              "fieldId": "memory_key",
              "fieldValue": "={{ $json.memory_key }}"
            },
            {
              "fieldId": "memory_value",
              "fieldValue": "={{ $json.memory_value }}"
            },
            {
              "fieldId": "importance_score",
              "fieldValue": "={{ $json.importance_score }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "entities",
              "fieldValue": "={{ $json.entities }}"
            },
            {
              "fieldId": "temporal_context",
              "fieldValue": "={{ $json.temporal_context }}"
            },
            {
              "fieldId": "is_active",
              "fieldValue": "={{ $json.is_active }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        736,
        768
      ],
      "id": "beaf2fa6-2298-4e9e-ac17-9d226d697755",
      "name": "Save Memories"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Session Summary Generator v2\n// - Only summarizes completed sessions\n// - Skips very short/test sessions\n// - Produces richer, more structured summaries\n\nconst MIN_MESSAGES = 3;        // Require at least 3 messages in a session\nconst MIN_GAP_MINUTES = 15;    // Session must have ended at least 15 minutes ago\n\n// ---------- 1. Resolve user ID ----------\nlet userId;\n\ntry {\n  const ctx = $('Format Context with Memory1').first();\n  if (ctx?.json?.user_id) {\n    userId = ctx.json.user_id;\n  }\n} catch (e) {\n  console.log('Could not get user ID from Format Context with Memory', e);\n}\n\nif (!userId) {\n  try {\n    const userNode = $('Get User1').first();\n    if (userNode?.json?.id) {\n      userId = userNode.json.id;\n    }\n  } catch (e) {\n    console.log('Could not get user ID from Get User1', e);\n  }\n}\n\n// If we still don't have a userId, we can't safely summarize\nif (!userId) {\n  console.log('No userId found, skipping session summary');\n  return [];\n}\n\n// ---------- 2. Get conversation history for this user ----------\nlet conversations = [];\ntry {\n  conversations = $('Fetch Session History2').all() || [];\n} catch (e) {\n  console.log('Could not get conversations from Fetch Session History', e);\n  return [];\n}\n\n// Convert to plain JS objects and filter by this user (safety)\nconst allConversations = conversations\n  .map(c => c.json)\n  .filter(c => c && c.user_id === userId && c.session_id);\n\nif (allConversations.length < MIN_MESSAGES) {\n  console.log('Not enough conversations overall to summarize');\n  return [];\n}\n\n// Sort descending by created_at (newest first)\nallConversations.sort(\n  (a, b) => new Date(b.created_at) - new Date(a.created_at)\n);\n\n// ---------- 3. Work out current vs completed sessions ----------\nconst currentSessionId = allConversations[0].session_id;\nconsole.log('Current session ID:', currentSessionId);\n\nconst sessionsById = {};\nfor (const conv of allConversations) {\n  if (!sessionsById[conv.session_id]) {\n    sessionsById[conv.session_id] = [];\n  }\n  sessionsById[conv.session_id].push(conv);\n}\n\n// Remove the current session from candidates (we only want completed ones)\ndelete sessionsById[currentSessionId];\n\nconst candidateSessionIds = Object.keys(sessionsById);\nif (candidateSessionIds.length === 0) {\n  console.log('No completed sessions to summarize');\n  return [];\n}\n\n// ---------- 4. Pick the most recent completed session ----------\ncandidateSessionIds.sort((a, b) => {\n  const aRecent = Math.max(\n    ...sessionsById[a].map(c => new Date(c.created_at).getTime())\n  );\n  const bRecent = Math.max(\n    ...sessionsById[b].map(c => new Date(c.created_at).getTime())\n  );\n  return bRecent - aRecent;\n});\n\nconst sessionId = candidateSessionIds[0];\nconst sessionToSummarize = sessionsById[sessionId];\n\n// Ensure this session is ‚Äúreal‚Äù and not just a 1-message ping\nif (sessionToSummarize.length < MIN_MESSAGES) {\n  console.log(\n    `Session ${sessionId} has only ${sessionToSummarize.length} messages, skipping summary`\n  );\n  return [];\n}\n\n// Check how long ago this session ended\nconst mostRecentMessageTs = Math.max(\n  ...sessionToSummarize.map(c => new Date(c.created_at).getTime())\n);\nconst minutesSinceLastMessage =\n  (Date.now() - mostRecentMessageTs) / (1000 * 60);\n\nif (minutesSinceLastMessage < MIN_GAP_MINUTES) {\n  console.log(\n    `Session ${sessionId} ended only ${minutesSinceLastMessage.toFixed(\n      1\n    )} minutes ago, skipping summary`\n  );\n  return [];\n}\n\n// ---------- 5. Extract key info from this session ----------\nconst topics = new Set();\nconst people = new Set();\nconst decisions = [];\nlet firstUserMessage = null;\nlet lastUserMessage = null;\n\nfor (const conv of sessionToSummarize) {\n  if (!conv.user_message) continue;\n\n  const msg = conv.user_message;\n  const msgLower = msg.toLowerCase();\n\n  if (!firstUserMessage) firstUserMessage = msg;\n  lastUserMessage = msg;\n\n  // Topics (you can extend this list anytime)\n  if (msgLower.includes('staff') || msgLower.includes('hire') || msgLower.includes('recruit')) {\n    topics.add('hiring');\n  }\n  if (msgLower.includes('remind') || msgLower.includes('ingat')) {\n    topics.add('reminders');\n  }\n  if (msgLower.includes('meeting') || msgLower.includes('jumpa')) {\n    topics.add('meetings');\n  }\n  if (msgLower.includes('stok') || msgLower.includes('inventory')) {\n    topics.add('inventory');\n  }\n  if (msgLower.includes('duit') || msgLower.includes('bayar') || msgLower.includes('payment')) {\n    topics.add('money');\n  }\n\n  // Rough name detection (single capitalized words)\n  const namePattern = /\\b[A-Z][a-z]{2,}\\b/g;\n  const names = msg.match(namePattern) || [];\n  for (const name of names) {\n    if (!['I', 'Ara', 'ARA'].includes(name)) {\n      people.add(name);\n    }\n  }\n\n  // Decisions / plans (keep first 120 chars)\n  if (\n    msgLower.includes('need') ||\n    msgLower.includes('nak ') ||\n    msgLower.includes('akan ') ||\n    msgLower.includes('plan') ||\n    msgLower.includes('will')\n  ) {\n    decisions.push(msg.substring(0, 120));\n  }\n}\n\n// ---------- 6. Timing & meta info ----------\nsessionToSummarize.sort(\n  (a, b) => new Date(a.created_at) - new Date(b.created_at)\n);\nconst sessionStartTime = new Date(sessionToSummarize[0].created_at);\nconst sessionEndTime = new Date(\n  sessionToSummarize[sessionToSummarize.length - 1].created_at\n);\n\nconst dayOfWeekNames = [\n  'Sunday',\n  'Monday',\n  'Tuesday',\n  'Wednesday',\n  'Thursday',\n  'Friday',\n  'Saturday',\n];\nconst dayOfWeek = dayOfWeekNames[sessionStartTime.getDay()];\n\nconst hour = sessionStartTime.getHours();\nconst timeOfDay =\n  hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';\n\nconst durationMinutes = Math.max(\n  1,\n  Math.round((sessionEndTime - sessionStartTime) / (1000 * 60))\n);\n\n// ---------- 7. Build human-readable summary ----------\nlet summaryText = 'User ';\n\nif (topics.has('hiring')) {\n  summaryText += 'discussed getting help with hiring or staff issues';\n} else if (topics.size > 0) {\n  summaryText += `discussed ${Array.from(topics).join(', ')}`;\n} else {\n  summaryText += 'had a general conversation';\n}\n\nif (people.size > 0) {\n  summaryText += `, and mentioned ${Array.from(people).join(', ')}`;\n}\n\nsummaryText += `. Conversation lasted about ${durationMinutes} minute(s).`;\n\nif (decisions.length > 0) {\n  summaryText += ' Key decisions or needs were mentioned.';\n}\n\n// ---------- 8. Construct summary record ----------\nconst summary = {\n  user_id: userId,\n  session_id: sessionId,\n  conversation_date: sessionStartTime.toISOString(),\n  day_of_week: dayOfWeek,\n  time_of_day: timeOfDay,\n  summary: summaryText,\n  key_topics: Array.from(topics),\n  people_mentioned: Array.from(people),\n  decisions_made: decisions,\n  message_count: sessionToSummarize.length,\n  session_duration_minutes: durationMinutes,\n};\n\nconsole.log('Generated summary for completed session:', summary);\n\n// n8n expects an array of items: [{ json: ... }]\nreturn [{ json: summary }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        1072
      ],
      "id": "0eb56547-3c1c-4368-a945-8affada30d37",
      "name": "Generate Session Summary"
    },
    {
      "parameters": {
        "tableId": "conversation_summaries",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "session_id",
              "fieldValue": "={{ $json.session_id }}"
            },
            {
              "fieldId": "conversation_date",
              "fieldValue": "={{ $json.conversation_date }}"
            },
            {
              "fieldId": "day_of_week",
              "fieldValue": "={{ $json.day_of_week }}"
            },
            {
              "fieldId": "time_of_day",
              "fieldValue": "={{ $json.time_of_day }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $json.summary }}"
            },
            {
              "fieldId": "key_topics",
              "fieldValue": "={{ $json.key_topics }}"
            },
            {
              "fieldId": "people_mentioned",
              "fieldValue": "={{ $json.people_mentioned }}"
            },
            {
              "fieldId": "decisions_made",
              "fieldValue": "={{ $json.decisions_made }}"
            },
            {
              "fieldId": "message_count",
              "fieldValue": "={{ $json.message_count }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        512,
        1072
      ],
      "id": "24b6f708-056f-418f-9e51-aa11765c897f",
      "name": "Save Session Summary"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "conversations",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Get Latest Conversation1').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $json.body }}"
            },
            {
              "fieldId": "pending_action_type",
              "fieldValue": "={{ $('Extract Pending Action1').item.json.pending_action_type }}"
            },
            {
              "fieldId": "pending_action_payload",
              "fieldValue": "={{ $('Extract Pending Action1').item.json.pending_action_payload }}"
            },
            {
              "fieldId": "pending_action_resolved",
              "fieldValue": "false"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -352,
        1072
      ],
      "id": "44ebdea4-4177-4eb5-885f-066cdd9d3879",
      "name": "Update Conversation1",
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000
    },
    {
      "parameters": {
        "jsCode": "// Validate Memories\n// Input: whatever Extract Memories returns as .json.output or directly as JSON\n// Output: array of clean memory objects (still abstract, no user_id etc.)\n\nlet raw = $json;\n\n// Some setups wrap the JSON array in an \"output\" field as a string\nlet memoriesRaw = raw.output ?? raw;\n\nlet memories = [];\n\ntry {\n  if (typeof memoriesRaw === 'string') {\n    // Strip markdown fences if they accidentally appear\n    memoriesRaw = memoriesRaw\n      .replace(/```json\\s*/g, '')\n      .replace(/```\\s*/g, '')\n      .trim();\n    memories = JSON.parse(memoriesRaw);\n  } else if (Array.isArray(memoriesRaw)) {\n    memories = memoriesRaw;\n  } else {\n    // If it's a single object instead of array, wrap it\n    memories = [memoriesRaw];\n  }\n} catch (e) {\n  console.log('Validate Memories: failed to parse memories', e);\n  return [];\n}\n\nif (!Array.isArray(memories)) {\n  console.log('Validate Memories: parsed value is not an array');\n  return [];\n}\n\nconst ALLOWED_TYPES = new Set(['preference', 'relationship', 'context', 'interaction']);\n\nconst cleaned = memories\n  .filter(m => m && typeof m === 'object')\n  .map((m, idx) => {\n    const mem = { ...m };\n\n    // Normalize memory_type\n    if (!ALLOWED_TYPES.has(mem.memory_type)) {\n      // Try to map invalid types\n      if (mem.memory_type === 'business/role') {\n        mem.memory_type = 'context';\n      } else {\n        // Unknown type ‚Üí treat as context by default\n        mem.memory_type = 'context';\n      }\n    }\n\n    // Ensure text fields exist\n    mem.memory_value = (mem.memory_value || '').toString().trim();\n    mem.memory_key = (mem.memory_key || `memory_${idx}`).toString().trim();\n\n    // Default importance\n    const importance = Number(mem.importance_score ?? 0.8);\n    mem.importance_score = isNaN(importance) ? 0.8 : importance;\n\n    // Normalize entities\n    const entities = mem.entities || {};\n    mem.entities = {\n      people: Array.isArray(entities.people) ? entities.people : [],\n      topics: Array.isArray(entities.topics) ? entities.topics : [],\n    };\n\n    // Temporal context\n    mem.temporal_context = mem.temporal_context || 'today';\n\n    return mem;\n  })\n  .filter(mem => {\n    // Filter out junk\n    if (!mem.memory_value || mem.memory_value.length < 10) return false;\n    if (mem.importance_score < 0.7) return false;\n    return true;\n  });\n\nreturn cleaned.map(m => ({ json: m }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        768
      ],
      "id": "5bb17032-413a-4def-b5df-3fab16d8e614",
      "name": "Validate Memories1"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Format Context with Memory1').item.json.ara_context.user.phone }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -640,
        928
      ],
      "id": "835ccf69-8f71-4525-b541-c661bfe05097",
      "name": "Send Reply1"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Extract Pending Action\n// ----------------------\n// Input from ARA Main Agent / Onboarding Agent:\n//   - Old shape: { output: \"<assistant reply>\" }\n//   - Message Model: { message: { content: \"<assistant reply>\" } }\n//\n// Behaviour:\n// - If reply contains `ARA_PENDING: { ... }`, parse it into:\n//      pending_action_type, pending_action_payload\n// - Remove BOTH the ARA_PENDING and ARA_ACTION blocks\n//   from the text for WhatsApp\n// - Keep the original fields for logging / Update Conversation\n\n// Normalise reply from different node shapes\n// - Old main agent: { output: \"...\" }\n// - Message Model:  { message: { content: \"...\" } }\n// - Raw OpenAI style: { choices: [ { message: { content: \"...\" } } ] }\n\nlet reply = '';\n\n// 1) Old main agent shape\nif (typeof $json.output === 'string' && $json.output.trim() !== '') {\n  reply = $json.output;\n\n// 2) Message Model node shape\n} else if ($json.message && typeof $json.message.content === 'string' && $json.message.content.trim() !== '') {\n  reply = $json.message.content;\n\n// 3) Raw OpenAI-style shape (safety net)\n} else if (Array.isArray($json.choices) && $json.choices[0]?.message?.content) {\n  reply = $json.choices[0].message.content;\n}\n\nlet cleanReply = reply || '';\n\nlet pending_action_type = 'none';\nlet pending_action_payload = null;\n\n// 1) Extract & handle ARA_PENDING\nconst pendingMatch = reply.match(/ARA_PENDING:\\s*(\\{[\\s\\S]*\\})/);\n\nif (pendingMatch) {\n  try {\n    const parsed = JSON.parse(pendingMatch[1]);  // { type, payload }\n    if (parsed && parsed.type) {\n      pending_action_type = parsed.type || 'none';\n      pending_action_payload = parsed.payload || null;\n    }\n  } catch (err) {\n    // If parse fails, we just treat it as no pending action\n  }\n\n  // Remove the ARA_PENDING part from the visible reply\n  cleanReply = cleanReply.replace(pendingMatch[0], '').trim();\n}\n\n// 2) Strip ARA_ACTION from visible reply (we parse it later in Route Confirmed Actions)\nconst actionMatch = reply.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\nif (actionMatch) {\n  cleanReply = cleanReply.replace(actionMatch[0], '').trim();\n}\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Clean text for Send Reply (no ARA_ACTION / ARA_PENDING)\n  assistant_response: cleanReply,\n\n  // Action description from THIS message (pending action only)\n  pending_action_type,\n  pending_action_payload,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1120,
        576
      ],
      "id": "8683391f-16e0-465c-8f27-e727d7000c58",
      "name": "Extract Pending Action1"
    },
    {
      "parameters": {
        "jsCode": "// ROUTE CONFIRMED ACTIONS\n// -----------------------\n// INPUT EXPECTED (from Extract Pending Action + previous nodes):\n// - pending_action_type       (from THIS assistant reply's ARA_PENDING)\n// - pending_action_payload\n// - ara_context               (contains dialogue_state with pendingAction from DB)\n// - user_message              (latest user input)\n// - assistant_response        (for passing through to Send Reply)\n\nconst currentType = $json.pending_action_type || 'none';\nconst currentPayload = $json.pending_action_payload || null;\n\n// ara_context comes from \"Format Context with Memory\"\nconst araContext = $json.ara_context || {};\nconst ds = araContext.dialogue_state || {};\nconst pending = ds.pendingAction || null;\nconst isActiveResponse = !!ds.isActiveResponse;\nconst responseType = ds.activeResponseType || null;  // 'yes' | 'no' | null\n\nlet ARA_ACTION = {\n  type: 'none',\n  payload: null,\n};\n\n// CASE 1: User is replying YES/NO to an existing pendingAction\nif (\n  pending &&\n  pending.type &&\n  pending.type !== 'none' &&\n  isActiveResponse &&\n  (responseType === 'yes' || responseType === 'no')\n) {\n  if (responseType === 'yes') {\n    // Confirm the pending action (create/delete/update/...)\n    ARA_ACTION = {\n      type: pending.type,\n      payload: pending.payload || {},\n    };\n  } else if (responseType === 'no') {\n    // Cancel the pending action\n    ARA_ACTION = {\n      type: pending.type + '_cancel',\n      payload: pending.payload || {},\n    };\n  }\n} else {\n  // CASE 2: Immediate actions that do NOT require confirmation\n\n  // Example: escalate to human\n  if (currentType === 'escalate') {\n    ARA_ACTION = {\n      type: 'escalate',\n      payload: currentPayload || {},\n    };\n  }\n\n  // üîπ NEW: direct profile updates (no YES/NO roundtrip)\n  else if (currentType === 'user_update_profile') {\n    ARA_ACTION = {\n      type: 'user_update_profile',\n      payload: currentPayload || {},\n    };\n  }\n}\n\n// CASE 3: User profile updates (ARA_ACTION from main agent or onboarding agent)\n// If the agent outputs ARA_ACTION.update_user_preferences directly inside the text\n\nlet rawOutput = '';\n\n// 1) Old main agent shape: { output: \"...\" }\nif (typeof $json.output === 'string' && $json.output.trim() !== '') {\n  rawOutput = $json.output;\n\n// 2) Message Model / onboarding shape: { message: { content: \"...\" } }\n} else if ($json.message && typeof $json.message.content === 'string' && $json.message.content.trim() !== '') {\n  rawOutput = $json.message.content;\n\n// 3) Raw OpenAI-style shape: { choices: [ { message: { content: \"...\" } } ] }\n} else if (Array.isArray($json.choices) && $json.choices[0]?.message?.content) {\n  rawOutput = $json.choices[0].message.content;\n}\n\nconst actionMatch = rawOutput.match(/ARA_ACTION:\\s*(\\{[\\s\\S]*?\\})/);\n\nif (actionMatch) {\n  try {\n    const parsedAction = JSON.parse(actionMatch[1]);\n\n    if (parsedAction.type === 'update_user_preferences') {\n      // Build payload ONLY with non-null fields\n      const payload = {};\n\n      if (\n        typeof parsedAction.preferred_name === 'string' &&\n        parsedAction.preferred_name.trim() !== ''\n      ) {\n        payload.preferred_name = parsedAction.preferred_name.trim();\n      }\n\n      if (\n        typeof parsedAction.preferred_language === 'string' &&\n        parsedAction.preferred_language.trim() !== ''\n      ) {\n        payload.preferred_language = parsedAction.preferred_language.trim();\n      }\n\n      // Only overwrite ARA_ACTION if we have something real to update\n      if (Object.keys(payload).length > 0) {\n        ARA_ACTION = {\n          type: 'update_user_preferences',\n          payload,\n        };\n      }\n      // else: no valid fields ‚Üí keep whatever ARA_ACTION was before\n    }\n  } catch (err) {\n    // ignore JSON parsing error, fall back to existing ARA_ACTION\n  }\n}\n\n\n// -----------------------------\n// SAFETY GUARDS (AILOOP PROTECT)\n// -----------------------------\n\n// 1) Whitelist allowed action types only\nconst allowedTypes = [\n  'none',\n  'reminder_create',\n  'reminder_delete',\n  'timezone_update',\n  'escalate',\n  'update_user_preferences',          // üîπ NEW\n\n  'reminder_create_cancel',\n  'reminder_delete_cancel',\n  'timezone_update_cancel',\n  'user_update_profile_cancel',   // optional future use\n];\n\nif (!allowedTypes.includes(ARA_ACTION.type)) {\n  ARA_ACTION = {\n    type: 'none',\n    payload: null,\n  };\n}\n\n// 2) Payload validation for specific actions\n\n// Reminder Create must have topic + suggested_time\nif (ARA_ACTION.type === 'reminder_create') {\n  const p = ARA_ACTION.payload || {};\n  const hasTopic =\n    typeof p.topic === 'string' && p.topic.trim().length > 0;\n  const hasTime =\n    typeof p.suggested_time === 'string' && p.suggested_time.trim().length > 0;\n\n  if (!hasTopic || !hasTime) {\n    // Invalid payload ‚Üí cancel action instead of firing broken data downstream\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Reminder Delete must have reminder_id\nif (ARA_ACTION.type === 'reminder_delete') {\n  const p = ARA_ACTION.payload || {};\n  const hasReminderId =\n    typeof p.reminder_id === 'string' && p.reminder_id.trim().length > 0;\n\n  if (!hasReminderId) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// Timezone Update must have timezone + timezone_label\nif (ARA_ACTION.type === 'timezone_update') {\n  const p = ARA_ACTION.payload || {};\n  const hasTz =\n    typeof p.timezone === 'string' && p.timezone.trim().length > 0;\n  const hasLabel =\n    typeof p.timezone_label === 'string' && p.timezone_label.trim().length > 0;\n\n  if (!hasTz || !hasLabel) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Profile Update must have at least one field to update\nif (ARA_ACTION.type === 'user_update_profile') {\n  const p = ARA_ACTION.payload || {};\n  const updates = p.profile_updates || null;\n\n  const valid =\n    updates &&\n    typeof updates === 'object' &&\n    Object.keys(updates).length > 0;\n\n  if (!valid) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n// User Preferences Update must have at least one field\nif (ARA_ACTION.type === 'update_user_preferences') {\n  const p = ARA_ACTION.payload || {};\n  const hasName = Object.prototype.hasOwnProperty.call(p, 'preferred_name');\n  const hasLang = Object.prototype.hasOwnProperty.call(p, 'preferred_language');\n\n  if (!hasName && !hasLang) {\n    ARA_ACTION = {\n      type: 'none',\n      payload: null,\n    };\n  }\n}\n\n\n\n// (We let 'escalate' and *_cancel pass even with minimal payload)\n\n// -----------------------------\n// Text back to user = assistant_response from previous node\n// -----------------------------\nconst final_reply = ($json.assistant_response || '').trim();\n\n// Safely pull the latest conversation row so we can attach ids\nconst latestItems = $items('Get Latest Conversation1');\nconst latest = latestItems.length ? latestItems[0].json : {};\n\n// Return enriched item\nreturn {\n  ...$json,\n\n  // Ensure these four are present from Get Latest Conversation\n  id: latest.id ?? $json.id,\n  user_id: latest.user_id ?? $json.user_id,\n  telegram_chat_id: latest.telegram_chat_id ?? $json.telegram_chat_id,\n  message_id: latest.message_id ?? $json.message_id,\n\n  ARA_ACTION,\n  final_reply,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -640,
        192
      ],
      "id": "2a3172cf-a655-4752-bf2c-5351ab6834b0",
      "name": "Route Confirmed Actions1"
    },
    {
      "parameters": {
        "tableId": "reminders",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation').item.json.user_id }}"
            },
            {
              "fieldId": "reminder_text",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.topic }}"
            },
            {
              "fieldId": "reminder_time",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.suggested_time }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "{{ $now }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "1f942f8c-453e-4b58-a451-1d2f5841ca08",
      "name": "Create Reminder1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_create",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "0d51000f-6a84-4eb8-8e74-e2190366c0dd"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Create"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7effae48-3c8b-445c-bdaf-8043843459f1",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f18fc6df-6c26-4714-ba28-fa4560fcec67",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "escalate",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Escalate"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4995634b-8db5-4173-8c98-866642aee254",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "timezone_update",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Timezone update"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "6695a56f-6968-4e5d-a459-9d98fe92a1ef",
                    "leftValue": "={{ $json[\"ARA_ACTION\"].type }}",
                    "rightValue": "update_user_preferences",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update User Profile"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -352,
        160
      ],
      "id": "8f6c1d97-0033-4290-b367-42ebab364792",
      "name": "Route Actions Switch1"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "reminders",
        "filters": {
          "conditions": [
            {
              "keyName": "reminder_text",
              "condition": "ilike",
              "keyValue": "={{ $json.pending_action_payload.topic }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        0,
        192
      ],
      "id": "b6e54d83-3183-4a7c-8e0d-5dd3dde96907",
      "name": "Delete Reminder1"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "home_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "current_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1744,
        1840
      ],
      "id": "40b02f20-9a6f-4115-b403-87f74fb80f84",
      "name": "Update Timezone"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "users",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "home_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "current_timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            },
            {
              "fieldId": "timezone",
              "fieldValue": "={{ $json.pending_action_payload.timezone }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        0,
        384
      ],
      "id": "0d8f925b-04fc-4709-aabb-eeebc2d57161",
      "name": "Update Timezone1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "46456542-8f2a-447d-b598-1713986577a7",
              "name": "user_name",
              "value": "={{    $node[\"Get User1\"].json.first_name    || $node[\"Get User1\"].json.telegram_username    || $json.telegram_chat_id  }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1536,
        1648
      ],
      "id": "b9a3c634-397d-49b7-972e-c86001ae5bf5",
      "name": "Get User name"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "46456542-8f2a-447d-b598-1713986577a7",
              "name": "user_name",
              "value": "={{    $node[\"Get User1\"].json.first_name    || $node[\"Get User1\"].json.telegram_username    || $json.telegram_chat_id  }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        0,
        576
      ],
      "id": "4437bc14-e426-4db4-9f91-c6904089be21",
      "name": "Get User name1"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.twilio.com/2010-04-01/Accounts/AC_REDACTED/Messages.json",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "twilioApi",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "From",
              "value": "=whatsapp:+601125911400"
            },
            {
              "name": "To",
              "value": "whatsapp:+601136521251"
            },
            {
              "name": "ContentSid",
              "value": "HXce8e8c9580065acd9c86815c679a0dbe"
            },
            {
              "name": "ContentVariables",
              "value": "={{ JSON.stringify({\n  \"1\": $json.user_name,\n  \"2\": $('Route Confirmed Actions').item.json.telegram_chat_id,\n  \"3\": $('Route Confirmed Actions').item.json.ARA_ACTION.payload.reason\n       + \". \"\n       + $('Route Confirmed Actions').item.json.ARA_ACTION.payload.summary,\n  \"4\": $('Route Confirmed Actions').item.json.ARA_ACTION.payload.last_user_message,\n  \"5\": $now\n}) }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1760,
        1648
      ],
      "id": "94837475-9387-40a4-b978-ae10ddd791b4",
      "name": "Escalate"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.twilio.com/2010-04-01/Accounts/AC_REDACTED/Messages.json",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "twilioApi",
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "From",
              "value": "=whatsapp:+601125911400"
            },
            {
              "name": "To",
              "value": "whatsapp:+601136521251"
            },
            {
              "name": "ContentSid",
              "value": "HXce8e8c9580065acd9c86815c679a0dbe"
            },
            {
              "name": "ContentVariables",
              "value": "={{ JSON.stringify({\n  \"1\": $json.user_name,\n  \"2\": $('Route Confirmed Actions1').item.json.telegram_chat_id,\n  \"3\": $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.reason\n       + \". \"\n       + $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.summary,\n  \"4\": $('Route Confirmed Actions1').item.json.ARA_ACTION.payload.last_user_message,\n  \"5\": $now\n}) }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        288,
        576
      ],
      "id": "c3df10e2-93e0-4360-8de5-13a39d0100e7",
      "name": "Escalate1"
    },
    {
      "parameters": {
        "tableId": "escalations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.user_id }}"
            },
            {
              "fieldId": "user_name",
              "fieldValue": "={{ $('Get User name').item.json.user_name }}"
            },
            {
              "fieldId": "user_phone",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.telegram_chat_id }}"
            },
            {
              "fieldId": "reason",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.reason }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.summary }}"
            },
            {
              "fieldId": "last_user_message",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.last_user_message }}"
            },
            {
              "fieldId": "urgency",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.pending_action_payload.urgency }}"
            },
            {
              "fieldId": "admin_phone",
              "fieldValue": "={{ '601136521251' }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "={{ 'open' }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1984,
        1648
      ],
      "id": "45c8aea8-dfcb-44e3-95a5-64e3db144655",
      "name": "Create Escalation Log"
    },
    {
      "parameters": {
        "tableId": "escalations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.user_id }}"
            },
            {
              "fieldId": "user_name",
              "fieldValue": "={{ $('Get User name1').item.json.user_name }}"
            },
            {
              "fieldId": "user_phone",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.telegram_chat_id }}"
            },
            {
              "fieldId": "reason",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.reason }}"
            },
            {
              "fieldId": "summary",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.summary }}"
            },
            {
              "fieldId": "last_user_message",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.last_user_message }}"
            },
            {
              "fieldId": "urgency",
              "fieldValue": "={{ $('Route Confirmed Actions1').item.json.pending_action_payload.urgency }}"
            },
            {
              "fieldId": "admin_phone",
              "fieldValue": "={{ '601136521251' }}"
            },
            {
              "fieldId": "status",
              "fieldValue": "={{ 'open' }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        512,
        576
      ],
      "id": "85d93bda-e383-4631-9c4d-2487f9372cb8",
      "name": "Create Escalation Log1"
    },
    {
      "parameters": {
        "from": "+601125911400",
        "to": "={{ $json.telegram_id }}",
        "toWhatsapp": true,
        "message": "HI! üòä Welcome to ARA (Ai-Ready Assistant). Sebentar ye, saya sedang daftar user baru.\n\n_By continuing to chat, you agree to ARA‚Äôs Terms & Privacy Policy_\n_https://araaisolution.com/terms-of-service_\n_https://araaisolution.com/privacy-policy_\n\n",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        -3984,
        704
      ],
      "id": "f2e4094a-14f6-47f7-b1f8-d7d87d0f8c3a",
      "name": "Send 1st Message"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.error }}",
                    "rightValue": "duplicate key value violates unique constraint \"users_telegram_id_key\"",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "40c674dd-ce02-4977-a627-ada421b19aaf"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Existing user"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -4224,
        944
      ],
      "id": "cf440b7e-5694-4862-92b7-f3fe91dd716a",
      "name": "New User?",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "content": "## Changed"
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1136,
        1824
      ],
      "typeVersion": 1,
      "id": "aa94a5b9-dbda-43bc-a01b-a7456f452ca0",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "jsCode": "const replyRaw = ($json.assistant_response || '').trim();\n\n// Simple language guess from latest user message (if available)\nconst userMsg = ($json.user_message || '').trim().toLowerCase();\n\nfunction buildFallback(msg) {\n  const hasMalayHints = /lah|tak|awak|saya|boleh|ingatkan|esok|pukul/.test(msg);\n  if (hasMalayHints) {\n    return \"Maaf, ada masalah teknikal sekejap. Cuba hantar semula mesej tadi ya. üôè\";\n  }\n  return \"Sorry, something went wrong on my side. Please send your last message again. üôè\";\n}\n\nlet safeReply = replyRaw;\nlet fallback_used = false;\n\nif (!safeReply) {\n  safeReply = buildFallback(userMsg);\n  fallback_used = true;\n}\n\n// Return everything + guaranteed reply text\nreturn {\n  ...$json,\n  assistant_response: safeReply,\n  fallback_used,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -176,
        2080
      ],
      "id": "bf93f2aa-8c24-4efe-b635-381cd4f0d5fa",
      "name": "Prepare Reply (Fail-Safe)"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "event_type",
              "fieldValue": "incoming_message"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{   {     source: \"whatsapp\",     direction: \"inbound\",     message_id: $json.SmsMessageSid || $json.MessageSid || $json.message_id || null,     from: $json.From || $json.from || null,     to: $json.To || $json.to || null,     raw_body: $json.Body || $json.body || $json.user_message || \"\"   } }}"
            },
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -4224,
        1680
      ],
      "id": "e65c09c9-9981-42a1-9126-f065dfdcb815",
      "name": "Log Incoming Message"
    },
    {
      "parameters": {
        "content": "## Changed"
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -4336,
        1648
      ],
      "typeVersion": 1,
      "id": "3388233c-7f4c-4c2e-90a5-450253a81f94",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Route Confirmed Actions').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "reminder_created"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  type: \"reminder\",\n  action: \"created\",\n  reminder_id: $json.id || null,\n  reminder_text: $json.reminder_text || null,\n  reminder_time: $json.reminder_time || null,\n  is_sent: $json.is_sent\n} }}\n"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1840,
        1024
      ],
      "id": "c4c1e79a-ba41-4fa1-b35a-72eb752d2874",
      "name": "Log Reminder Created"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "memory_extracted"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {   source: \"whatsapp\",   type: \"memory\",   action: \"saved\",   memory_id: $json.id || null,   memory_category: $json.category || null,   memory_title: $json.title || null } }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2208,
        2032
      ],
      "id": "a20189cc-37e4-4e7c-8475-abd1f31624dd",
      "name": "Log Memory Extracted"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "fallback_triggered"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  scope: \"main_agent\",\n  reason: \"assistant_response_empty_or_invalid\",\n  last_user_message: $json.user_message || null\n} }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        496,
        2496
      ],
      "id": "52e8825b-3dbd-45b6-9c5d-77eb3d14f725",
      "name": "log Main Fallback"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.fallback_used }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "32a5b251-f43e-40f7-bda8-b82ec3edfbf7"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        352,
        2320
      ],
      "id": "ab299e65-bd81-4b96-acfc-1b0d08b50a52",
      "name": "IF Fallback Used?"
    },
    {
      "parameters": {
        "jsCode": "const replyRaw = ($json.assistant_response || '').trim();\n\n// Simple language guess from latest user message (if available)\nconst userMsg = ($json.user_message || '').trim().toLowerCase();\n\nfunction buildFallback(msg) {\n  const hasMalayHints = /lah|tak|awak|saya|boleh|ingatkan|esok|pukul/.test(msg);\n  if (hasMalayHints) {\n    return \"Maaf, ada masalah teknikal sekejap. Cuba hantar semula mesej tadi ya. üôè\";\n  }\n  return \"Sorry, something went wrong on my side. Please send your last message again. üôè\";\n}\n\nlet safeReply = replyRaw;\nlet fallback_used = false;\n\nif (!safeReply) {\n  safeReply = buildFallback(userMsg);\n  fallback_used = true;\n}\n\n// Return everything + guaranteed reply text\nreturn {\n  ...$json,\n  assistant_response: safeReply,\n  fallback_used,\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -912,
        848
      ],
      "id": "4110c47f-24d4-49d0-9c52-f02311ab1260",
      "name": "Prepare Reply (Fail-Safe)1"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Get Latest Conversation1').item.json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "fallback_triggered"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {\n  source: \"whatsapp\",\n  scope: \"main_agent\",\n  reason: \"assistant_response_empty_or_invalid\",\n  last_user_message: $json.user_message || null\n} }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -512,
        1280
      ],
      "id": "cb1d89a0-ff21-4937-b53d-ab7e2943d6f5",
      "name": "log Main Fallback1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.fallback_used }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "32a5b251-f43e-40f7-bda8-b82ec3edfbf7"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.3,
      "position": [
        -720,
        1184
      ],
      "id": "08e89314-3bbd-444f-9951-617ade9ffaa4",
      "name": "IF Fallback Used?1"
    },
    {
      "parameters": {
        "tableId": "usage_logs",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $json.user_id }}"
            },
            {
              "fieldId": "event_type",
              "fieldValue": "memory_extracted"
            },
            {
              "fieldId": "metadata",
              "fieldValue": "={{ {   source: \"whatsapp\",   type: \"memory\",   action: \"saved\",   memory_id: $json.id || null,   memory_category: $json.category || null,   memory_title: $json.title || null } }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1024,
        784
      ],
      "id": "6ee299e2-6cc5-47a5-8a85-67aea7114428",
      "name": "Log Memory Extracted1"
    },
    {
      "parameters": {
        "jsCode": "// This code cleans relative-day words from reminder topic\n// and leaves other flows untouched.\n\nconst RELATIVE_DAY_REGEX = /\\b(hari ini|esok|lusa|minggu depan|bulan depan|malam ini|pagi esok|today|tomorrow|tonight|next week|next month|this morning|this evening)\\b/gi;\n\nreturn items.map(item => {\n  const data = item.json || {};\n\n  let payload = data.pending_action_payload;\n\n  // Some flows store payload as JSON string, some as object\n  if (typeof payload === 'string') {\n    try {\n      payload = JSON.parse(payload);\n    } catch (e) {\n      // If parsing fails, just skip cleaning and pass through\n      item.json = data;\n      return item;\n    }\n  }\n\n  if (payload && typeof payload === 'object' && typeof payload.topic === 'string') {\n    payload.topic = payload.topic\n      .replace(RELATIVE_DAY_REGEX, '')   // remove relative-day words\n      .replace(/\\s+/g, ' ')             // collapse double spaces\n      .trim();\n  }\n\n  // Put payload back in its original shape\n  data.pending_action_payload = payload;\n\n  item.json = data;\n  return item;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1392,
        1040
      ],
      "id": "408558e8-ae79-458a-9b92-706a02f1792f",
      "name": "Sanitise Reminder Topic"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE public.users\nSET\n  preferred_name = COALESCE(NULLIF($1::text, 'null'), preferred_name),\n  preferred_language = CASE\n    WHEN $2 IS NULL OR $2 = '__KEEP__' THEN preferred_language\n    ELSE $2\n  END\nWHERE id = $3;\n",
        "options": {
          "queryReplacement": "={{ $json[\"ARA_ACTION\"].payload.preferred_name ?? null }}, {{ \n  $json[\"ARA_ACTION\"].payload.preferred_language === undefined\n    ? '__KEEP__'\n    : $json[\"ARA_ACTION\"].payload.preferred_language\n}}, {{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1296,
        1808
      ],
      "id": "275d8560-5072-4966-a1fb-f0ceb4668941",
      "name": "PG ‚Äì Update user preferences"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE public.users\nSET\n preferred_name = COALESCE(NULLIF($1::text, 'null'), preferred_name),\n  preferred_language = CASE\n    WHEN $2 IS NULL OR $2 = '__KEEP__' THEN preferred_language\n    ELSE $2\n  END\nWHERE id = $3;\n",
        "options": {
          "queryReplacement": "={{ $json[\"ARA_ACTION\"].payload.preferred_name ?? null }}, {{    $json[\"ARA_ACTION\"].payload.preferred_language === undefined     ? '__KEEP__'     : $json[\"ARA_ACTION\"].payload.preferred_language }}, {{ $json.user_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -224,
        480
      ],
      "id": "0d470b7e-0ee0-404a-9898-79636a0532d4",
      "name": "PG ‚Äì Update user preferences1"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Mixed-Offer Override (SAFE GUARDRAIL)\n// Run mode: \"Run Once for Each Item\"  ‚úÖ must return a SINGLE object (not an array)\n\nconst item = $json;\n\nconst currentType = (item.pending_action_type || 'none').toString();\n\n// Pass through if extractor already found an action\nif (currentType !== 'none') {\n  return item;\n}\n\nconst assistantText = (item.assistant_response || '').toString().trim();\nif (!assistantText) return item;\n\n// 1) Must look like a REMINDER offer (not generic offers)\nconst hasReminderWords = /\\b(remind|reminder|ingatkan|peringat)\\b/i.test(assistantText);\n\nconst hasOfferAsk =\n  /\\b(would you like me to|do you want me to|shall i|should i|can i|may i)\\b/i.test(assistantText) ||\n  /\\b(just to confirm|to confirm)\\b/i.test(assistantText) ||\n  /\\b(nak saya|mahu saya|boleh saya)\\b/i.test(assistantText);\n\nif (!hasReminderWords || !hasOfferAsk) {\n  return item;\n}\n\n// 2) Require explicit day anchor (no guessing dates)\nconst isTomorrow = /\\b(tomorrow|esok)\\b/i.test(assistantText);\nconst isToday = /\\b(today|harini|hari ini)\\b/i.test(assistantText);\nif (!isTomorrow && !isToday) return item;\n\n// 3) Extract clock time\nlet hour = null;\nlet minute = 0;\n\nlet m = assistantText.match(/\\b([01]?\\d|2[0-3])[:.](\\d{2})\\s*(am|pm)?\\b/i);\nif (m) {\n  hour = parseInt(m[1], 10);\n  minute = parseInt(m[2], 10);\n  const ampm = (m[3] || '').toLowerCase();\n  if (ampm === 'pm' && hour < 12) hour += 12;\n  if (ampm === 'am' && hour === 12) hour = 0;\n} else {\n  m = assistantText.match(/\\b([1-9]|1[0-2])\\s*(am|pm)\\b/i);\n  if (m) {\n    hour = parseInt(m[1], 10);\n    minute = 0;\n    const ampm = (m[2] || '').toLowerCase();\n    if (ampm === 'pm' && hour < 12) hour += 12;\n    if (ampm === 'am' && hour === 12) hour = 0;\n  }\n}\n\nif (hour === null) return item;\n\n// 4) Build suggested_time safely for +08 zones only\nconst tz = item?.ara_context?.user?.timezone || 'Asia/Kuala_Lumpur';\nconst plus8Zones = new Set(['Asia/Kuala_Lumpur', 'Asia/Kuching', 'Asia/Singapore']);\nif (!plus8Zones.has(tz)) return item;\n\nfunction pad2(n) { return String(n).padStart(2, '0'); }\n\nconst nowUtc = new Date();\nconst nowPlus8 = new Date(nowUtc.getTime() + 8 * 60 * 60 * 1000);\n\nlet y = nowPlus8.getUTCFullYear();\nlet mo = nowPlus8.getUTCMonth() + 1;\nlet d = nowPlus8.getUTCDate();\n\nif (isTomorrow) d += 1;\n\nconst suggested_time = `${y}-${pad2(mo)}-${pad2(d)}T${pad2(hour)}:${pad2(minute)}:00+08:00`;\n\n// 5) Topic extraction (SAFE): derive from THIS assistant offer sentence, not history\nlet topic = null;\n\n// Try English \"about <topic>\" pattern\nlet t = assistantText.match(/\\babout\\s+(.+?)(\\?|$)/i);\nif (t && t[1]) {\n  topic = t[1].trim();\n}\n\n// Try Malay \"pasal/mengenai/tentang <topic>\" pattern\nif (!topic) {\n  t = assistantText.match(/\\b(pasal|mengenai|tentang)\\s+(.+?)(\\?|$)/i);\n  if (t && t[2]) topic = t[2].trim();\n}\n\n// Clean trailing filler words\nif (topic) {\n  topic = topic.replace(/\\s+(right|ya|betul)\\s*$/i, '').trim();\n}\n\n// Fallback 1: use current user message text (still safer than scanning long history)\nif (!topic) {\n  topic = (item?.ara_context?.current_message?.text || item?.user_message || '').toString().trim();\n}\n\n// Fallback 2: safe snippet of assistant\nif (!topic) {\n  topic = assistantText.slice(0, 120);\n}\n\n\n// Apply override\nreturn {\n  ...item,\n  pending_action_type: 'reminder_offer',\n  pending_action_payload: {\n    topic,\n    suggested_time,\n  },\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        1760
      ],
      "id": "dadf15ea-a9d6-4045-a23f-afc16af3f036",
      "name": "Mixed-Offer Override"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"assistant_response\": { \"type\": \"string\" },\n    \"pending_action_type\": { \"type\": \"string\" },\n    \"pending_action_payload\": { \"type\": [\"object\", \"null\"] }\n  },\n  \"required\": [\"assistant_response\", \"pending_action_type\", \"pending_action_payload\"],\n  \"additionalProperties\": true\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -624,
        2064
      ],
      "id": "55206f83-9baa-4028-a429-75fd3e7619a1",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "jsCode": "const out = [];\n\nfor (const item of $input.all()) {\n  const j = item.json;\n  const p = j.pending_action_payload ?? j.output?.pending_action_payload ?? {};\n\n  let ids = [];\n\n  // Case 1: array already provided\n  if (Array.isArray(p.reminder_ids)) {\n    ids = p.reminder_ids;\n\n  // Case 2: comma-separated string\n  } else if (typeof p.reminder_ids === \"string\") {\n    ids = p.reminder_ids.split(\",\").map(s => s.trim());\n\n  // Case 3: single id\n  } else if (p.reminder_id) {\n    ids = [p.reminder_id];\n\n  // Case 4: reminder_id_1, reminder_id_2, reminder_id_3 ... reminder_id_N\n  } else {\n    ids = Object.keys(p)\n      .filter(k => /^reminder_id_\\d+$/.test(k))\n      .sort((a, b) => Number(a.split(\"_\").pop()) - Number(b.split(\"_\").pop()))\n      .map(k => p[k]);\n  }\n\n  // Emit one n8n item per reminder id\n  for (const id of ids.filter(Boolean)) {\n    out.push({\n      json: {\n        reminder_id: id,\n        user_id: j.user_id, // keep for safety filter\n      }\n    });\n  }\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1184,
        1504
      ],
      "id": "ae5e917b-0623-4b01-94ef-d809d5e50cec",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "reminders",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $json.reminder_id }}"
            },
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1616,
        1520
      ],
      "id": "f6fdd998-05c9-49e6-9d37-0f7e10df2b36",
      "name": "Delete Reminder"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "58254766-51ec-4ad3-ab34-2928e9b7d44c",
              "leftValue": "={{ $json.reminder_id }}",
              "rightValue": "all",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1376,
        1472
      ],
      "id": "b2f32037-e4e0-401b-81da-5573336a1d7d",
      "name": "If ALL?"
    },
    {
      "parameters": {
        "operation": "delete",
        "tableId": "reminders",
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $('Code in JavaScript').item.json.user_id }}"
            },
            {
              "keyName": "is_sent",
              "condition": "eq",
              "keyValue": "={{ false }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1808,
        1456
      ],
      "id": "fd788b99-e47c-4293-912a-4764188e611d",
      "name": "Delete ALL"
    },
    {
      "parameters": {
        "jsCode": "// Explode Reminder (FIXED)\n// Supports BOTH:\n// 1) Bulk: pending_action_payload.reminders = [{topic, suggested_time}, ...]\n// 2) Single: pending_action_payload = {topic, suggested_time}\n\nconst base = $json;\n\nconst payload =\n  base.pending_action_payload ||\n  base.output?.pending_action_payload ||\n  null;\n\nlet reminders = [];\n\nif (payload && Array.isArray(payload.reminders) && payload.reminders.length > 0) {\n  reminders = payload.reminders;\n} else if (payload && payload.topic && payload.suggested_time) {\n  reminders = [{ topic: payload.topic, suggested_time: payload.suggested_time }];\n} else {\n  return [];\n}\n\nconst user_id = base.user_id;\nconst telegram_chat_id = base.telegram_chat_id;\nconst session_id = base.session_id;\nconst message_id = base.message_id;\n\nreturn reminders.map((r, idx) => ({\n  json: {\n    source_message_id: message_id,\n    source_session_id: session_id,\n    batch_index: idx,\n\n    user_id,\n    reminder_text: r.topic,\n    reminder_time: r.suggested_time,\n    is_sent: false,\n\n    telegram_chat_id,\n  }\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1120,
        1088
      ],
      "id": "c50b0358-b381-4898-b5ba-6cf2ee4363a9",
      "name": "Explode Reminder"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_create",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0001"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Create"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_list",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0002"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "List"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete_request",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "d6a7c6d6-7d6c-4f0b-8a8e-1a8f1d6a0003"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete Request"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "7effae48-3c8b-445c-bdaf-8043843459f1",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "reminder_delete",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Delete"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "f18fc6df-6c26-4714-ba28-fa4560fcec67",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "escalate",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Escalate"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "602c304b-fae9-4ee9-aea5-3622eea25845",
                    "leftValue": "={{ $json.pending_action_type }}",
                    "rightValue": "timezone_update",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update timezone"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "959a4996-035d-4e07-951b-9fe19d261d98",
                    "leftValue": "={{ $json[\"ARA_ACTION\"].type }}",
                    "rightValue": "update_user_preferences",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Update User Profile"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        544,
        1520
      ],
      "id": "a5cfd68f-a2c4-4771-a4dd-e608ab40aaa3",
      "name": "Route Actions Switch2"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "reminders",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "user_id",
              "condition": "eq",
              "keyValue": "={{ $json.user_id }}"
            },
            {
              "keyName": "is_sent",
              "condition": "eq",
              "keyValue": "={{  false }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1248,
        1296
      ],
      "id": "23196805-3d66-4448-a458-29049f3b2b23",
      "name": "List Reminders"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "leftValue": "={{ $('Route Actions Switch2').item.json.output.pending_action_type }}",
              "rightValue": "reminder_list",
              "operator": {
                "type": "string",
                "operation": "equals"
              },
              "id": "acb1dea8-5ea5-49f6-aaee-a44cdb995471"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1488,
        1296
      ],
      "id": "50c68d22-2358-4f44-b9cf-c07bd8c410f0",
      "name": "IF Reminder List?"
    },
    {
      "parameters": {
        "jsCode": "// Format Reminder List (human WhatsApp style)\n// Mode: Run Once for All Items ‚úÖ\n// Input items = rows from \"List Reminders\" node\n\nfunction getTelegramChatId() {\n  // You said Route Actions Switch2 has it ‚Äî keep that as primary\n  const v =\n    $items('Route Actions Switch2')?.[0]?.json?.telegram_chat_id ||\n    $items('Route Confirmed Actions')?.[0]?.json?.telegram_chat_id ||\n    $items('Get Latest Conversation')?.[0]?.json?.telegram_chat_id ||\n    $items('Route Actions Switch')?.[0]?.json?.telegram_chat_id ||\n    null;\n\n  return v ? String(v).trim() : null;\n}\n\nfunction getPreferredLanguage() {\n  // Safest: pull from Get User1 node output\n  const u = $items('Get User1')?.[0]?.json ?? {};\n  return (u.preferred_language || 'en').toString().toLowerCase();\n}\n\nfunction getUserTimezone() {\n  // Try to use ara_context first, else fall back to Malaysia\n  const tz =\n    $json?.ara_context?.user?.current_timezone ||\n    $json?.ara_context?.user?.timezone ||\n    $items('Get User1')?.[0]?.json?.current_timezone ||\n    $items('Get User1')?.[0]?.json?.timezone ||\n    'Asia/Kuala_Lumpur';\n  return tz;\n}\n\nfunction formatDateHeader(d, lang, timeZone) {\n  // Example: Tue, 27 Jan\n  const locale =\n    lang === 'ms' ? 'ms-MY' :\n    lang === 'id' ? 'id-ID' :\n    'en-MY';\n\n  return new Intl.DateTimeFormat(locale, {\n    timeZone,\n    weekday: 'short',\n    day: '2-digit',\n    month: 'short',\n  }).format(d);\n}\n\nfunction formatTime12h(d, lang, timeZone) {\n  // Example: 3:00 PM\n  const locale =\n    lang === 'ms' ? 'en-MY' :   // Malay users usually still prefer \"3:00 PM\" formatting\n    lang === 'id' ? 'en-ID' :\n    'en-MY';\n\n  return new Intl.DateTimeFormat(locale, {\n    timeZone,\n    hour: 'numeric',\n    minute: '2-digit',\n    hour12: true,\n  }).format(d);\n}\n\nfunction getText(lang, key) {\n  const dict = {\n    en: {\n      title: \"Here are your reminders:\",\n      none: \"You don‚Äôt have any active reminders yet.\",\n      tip: \"If you want, just type: ‚ÄúRemind me to ‚Ä¶ at ‚Ä¶‚Äù\",\n    },\n    ms: {\n      title: \"Ini reminder awak:\",\n      none: \"Buat masa sekarang, tak ada reminder yang aktif lagi.\",\n      tip: \"Kalau nak set, boleh taip: ‚ÄúIngatkan saya ‚Ä¶ pukul ‚Ä¶‚Äù\",\n    },\n    id: {\n      title: \"Ini daftar pengingat kamu:\",\n      none: \"Saat ini kamu belum punya pengingat yang aktif.\",\n      tip: \"Kalau mau set, ketik: ‚ÄúIngatkan saya ‚Ä¶ jam ‚Ä¶‚Äù\",\n    },\n  };\n  return (dict[lang] && dict[lang][key]) ? dict[lang][key] : dict.en[key];\n}\n\n// --------------------\n// Main\n// --------------------\nconst telegram_chat_id = getTelegramChatId();   // ‚úÖ PATCH: always carry forward\nconst lang = getPreferredLanguage();            // en | ms | id\nconst timeZone = getUserTimezone();\n\n// All DB rows from List Reminders\nconst rows = items.map(i => i.json).filter(r => r && r.reminder_time);\n\n// No reminders case\nif (!rows.length) {\n  const assistant_response = `${getText(lang, 'none')}\\n${getText(lang, 'tip')}`;\n  return [{\n    json: {\n      ...($json || {}),\n      telegram_chat_id, // ‚úÖ PATCH\n      assistant_response,\n      // IMPORTANT: stop re-triggering list\n      pending_action_type: \"none\",\n      pending_action_payload: null,\n    }\n  }];\n}\n\n// Sort by reminder_time ascending\nrows.sort((a, b) => new Date(a.reminder_time).getTime() - new Date(b.reminder_time).getTime());\n\n// Group by date (YYYY-MM-DD in user's timezone)\nfunction dateKey(d) {\n  const parts = new Intl.DateTimeFormat('en-CA', {\n    timeZone,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n  }).formatToParts(d);\n\n  const y = parts.find(p => p.type === 'year')?.value;\n  const m = parts.find(p => p.type === 'month')?.value;\n  const da = parts.find(p => p.type === 'day')?.value;\n  return `${y}-${m}-${da}`;\n}\n\nconst groups = new Map();\nfor (const r of rows) {\n  const d = new Date(r.reminder_time);\n  const key = dateKey(d);\n  if (!groups.has(key)) groups.set(key, []);\n  groups.get(key).push({ ...r, _date: d });\n}\n\n// Build WhatsApp message\nlet lines = [];\nlines.push(getText(lang, 'title'));\n\nfor (const [, list] of groups.entries()) {\n  // Date header\n  const headerDate = list[0]._date;\n  lines.push(`\\n${formatDateHeader(headerDate, lang, timeZone)}`);\n\n  // Items\n  for (const r of list) {\n    const t = formatTime12h(r._date, lang, timeZone);\n    const text = (r.reminder_text || '').toString().trim() || '(no title)';\n    lines.push(`- ${t} ‚Äî ${text}`);\n  }\n}\n\nconst assistant_response = lines.join('\\n');\n\nreturn [{\n  json: {\n    ...($json || {}),\n    telegram_chat_id, // ‚úÖ PATCH\n    assistant_response,\n    // IMPORTANT: stop re-triggering list\n    pending_action_type: \"none\",\n    pending_action_payload: null,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1808,
        1216
      ],
      "id": "556d0acd-a21a-4955-8252-d616d144923c",
      "name": "Format Reminder List Message"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $json.telegram_chat_id }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        2544,
        1216
      ],
      "id": "0f56653a-77f0-4f33-a301-ef58718b6f70",
      "name": "Send Reply - Reminder List"
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2016,
        1216
      ],
      "id": "99d08416-b0fd-4d18-8a95-c513d85a64bf",
      "name": "Merge"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2224,
        1216
      ],
      "id": "d4c5507a-ee6e-40d1-b5c1-355b4cae7b29",
      "name": "Wait",
      "webhookId": "f50730ba-92b5-46fb-b71a-1a77e9946da6"
    },
    {
      "parameters": {
        "tableId": "conversations",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "user_id",
              "fieldValue": "={{ $('Merge').item.json.user_id }}"
            },
            {
              "fieldId": "telegram_chat_id",
              "fieldValue": "={{ $('Merge').item.json.telegram_chat_id }}"
            },
            {
              "fieldId": "message_id",
              "fieldValue": "={{ $item(0).$node[\"Twilio Webhook\"].json.body.MessageSid }}"
            },
            {
              "fieldId": "created_at",
              "fieldValue": "={{ $now }}"
            },
            {
              "fieldId": "message_type",
              "fieldValue": "=whatsapp"
            },
            {
              "fieldId": "assistant_response",
              "fieldValue": "={{ $json.body }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2864,
        1232
      ],
      "id": "e314618c-c305-45ff-b9a0-b583cff92d86",
      "name": "Update Conversation2",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Delete Offer (WhatsApp-friendly, Auto Language EN/MS/ID)\n// Input: $input.all() = reminders rows\n// Uses agent payload to auto-match best reminder to delete\n\nfunction norm(s = \"\") {\n  return s\n    .toLowerCase()\n    .replace(/[^a-z0-9\\s]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n}\n\nfunction pickLang(raw) {\n  const s = (raw || \"\").toString().toLowerCase().trim();\n  if (!s) return \"en\";\n  if (s.startsWith(\"ms\") || s.includes(\"melayu\") || s.includes(\"bahasa malaysia\")) return \"ms\";\n  if (s.startsWith(\"id\") || s.includes(\"indonesia\") || s.includes(\"bahasa indonesia\")) return \"id\";\n  if (s.startsWith(\"en\") || s.includes(\"english\")) return \"en\";\n  // fallback: treat \"bm\" as ms\n  if (s === \"bm\") return \"ms\";\n  return \"en\";\n}\n\nconst I18N = {\n  en: {\n    header_label: \"Your active reminders\",\n    none: \"‚úÖ You don‚Äôt have any active reminders right now.\",\n    ask_number: \"Reply with the *number* you want to delete. (Example: *2*)\",\n    confirm_title: \"üóëÔ∏è Delete this reminder?\",\n    confirm_yesno: \"Reply *yes* to confirm or *no* to cancel.\",\n    list_emoji: \"üìå\",\n  },\n  ms: {\n    header_label: \"Peringatan aktif anda\",\n    none: \"‚úÖ Anda tiada peringatan aktif buat masa ini.\",\n    ask_number: \"Balas dengan *nombor* yang anda nak padam. (Contoh: *2*)\",\n    confirm_title: \"üóëÔ∏è Padam peringatan ini?\",\n    confirm_yesno: \"Balas *ya* untuk sahkan atau *tidak* untuk batal.\",\n    list_emoji: \"üìå\",\n  },\n  id: {\n    header_label: \"Pengingat aktif kamu\",\n    none: \"‚úÖ Kamu tidak punya pengingat aktif saat ini.\",\n    ask_number: \"Balas dengan *nomor* yang ingin kamu hapus. (Contoh: *2*)\",\n    confirm_title: \"üóëÔ∏è Hapus pengingat ini?\",\n    confirm_yesno: \"Balas *ya* untuk konfirmasi atau *tidak* untuk batal.\",\n    list_emoji: \"üìå\",\n  },\n};\n\nfunction fmtGmtOffset(tz) {\n  const sample = new Date();\n  const parts = new Intl.DateTimeFormat(\"en-US\", {\n    timeZone: tz,\n    timeZoneName: \"shortOffset\",\n    hour: \"2-digit\",\n  }).formatToParts(sample);\n\n  const off = parts.find(p => p.type === \"timeZoneName\")?.value || \"\";\n  return off.replace(\"GMT\", \"GMT\");\n}\n\nfunction friendlyCity(tz) {\n  const map = {\n    \"Asia/Kuala_Lumpur\": \"Kuala Lumpur\",\n    \"Asia/Singapore\": \"Singapore\",\n    \"Asia/Jakarta\": \"Jakarta\",\n    \"Asia/Bangkok\": \"Bangkok\",\n  };\n  return map[tz] || tz.replace(/_/g, \" \");\n}\n\nfunction formatWhen(iso, tz, lang) {\n  if (!iso) return \"(time not set)\";\n  const d = new Date(iso);\n\n  // Use locale by language\n  const locale = lang === \"ms\" ? \"ms-MY\" : lang === \"id\" ? \"id-ID\" : \"en-GB\";\n\n  // WhatsApp-friendly: \"Mon, 27 Jan ‚Ä¢ 6:00 PM\"\n  const day = new Intl.DateTimeFormat(locale, {\n    timeZone: tz,\n    weekday: \"short\",\n  }).format(d);\n\n  const date = new Intl.DateTimeFormat(locale, {\n    timeZone: tz,\n    day: \"2-digit\",\n    month: \"short\",\n  }).format(d);\n\n  const time = new Intl.DateTimeFormat(locale, {\n    timeZone: tz,\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: true,\n  }).format(d);\n\n  return `${day}, ${date} ‚Ä¢ ${time}`;\n}\n\n// --- Get user + timezone + language safely ---\nconst u = $items(\"Get User1\")?.[0]?.json ?? {};\nconst lang = pickLang(u.preferred_language || $json?.preferred_language || \"en\");\n\nconst tz =\n  ($json?.ara_context?.current_timezone ||\n    $json?.ara_context?.home_timezone ||\n    u.current_timezone ||\n    u.home_timezone ||\n    \"Asia/Kuala_Lumpur\"\n  ).toString();\n\n// --- Agent payload (for matching) ---\nconst agentOut = $items(\"ARA Main Agent\")?.[0]?.json?.output ?? {};\nconst req = agentOut.pending_action_payload || {};\nconst extracted = norm(req.extracted_topic || \"\");\nconst queryText = norm(req.query_text || \"\");\n\n// --- Reminders from input ---\nconst reminders = $input.all().map(i => i.json);\n\n// --- Header with city + tz ---\nconst city = friendlyCity(tz);\nconst gmt = fmtGmtOffset(tz);\nconst header = `üïí *${city} (${gmt})*`;\n\nconst t = I18N[lang] || I18N.en;\n\n// If none\nif (!reminders.length) {\n  const assistant_response = `${header}\\n\\n${t.none}`;\n  return [{ json: { assistant_response, pendingAction: null } }];\n}\n\n// Build list (WhatsApp style)\nconst listLines = reminders.map((r, i) => {\n  const when = formatWhen(r.reminder_time, tz, lang);\n  return `*${i + 1})* ${r.reminder_text}\\n   _${when}_`;\n});\n\nlet assistant_response =\n  `${header}\\n\\n` +\n  `${t.list_emoji} *${t.header_label}*\\n` +\n  listLines.join(\"\\n\\n\");\n\n// --- Match scoring ---\nconst scored = reminders\n  .map(r => {\n    const rt = norm(r.reminder_text || \"\");\n    let score = 0;\n\n    if (extracted && rt.includes(extracted)) score += 5;\n\n    if (queryText) {\n      const words = queryText.split(\" \").filter(w => w.length >= 3);\n      score += words.filter(w => rt.includes(w)).length;\n    }\n\n    return { r, score };\n  })\n  .sort((a, b) => b.score - a.score);\n\nconst best = scored[0];\n\n// If no match / ambiguous ‚Üí ask for number\nif ((best.score || 0) === 0) {\n  assistant_response += `\\n\\n${t.ask_number}`;\n\n  return [\n    {\n      json: {\n        assistant_response,\n        pendingAction: {\n          type: \"reminder_delete_select\",\n          payload: {\n            candidates: reminders.map(r => ({\n              id: r.id,\n              reminder_text: r.reminder_text,\n              reminder_time: r.reminder_time,\n            })),\n          },\n        },\n      },\n    },\n  ];\n}\n\n// Offer delete confirmation (clean + human)\nconst bestWhen = formatWhen(best.r.reminder_time, tz, lang);\n\nassistant_response +=\n  `\\n\\n${t.confirm_title}\\n` +\n  `‚Ä¢ *${best.r.reminder_text}*\\n` +\n  `  _${bestWhen}_\\n\\n` +\n  `${t.confirm_yesno}`;\n\nreturn [\n  {\n    json: {\n      assistant_response,\n      pendingAction: {\n        type: \"reminder_delete_offer\",\n        payload: {\n          reminder_id: best.r.id,\n          reminder_text: best.r.reminder_text,\n          reminder_time: best.r.reminder_time,\n        },\n      },\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2128,
        1424
      ],
      "id": "22ec497b-55b7-48b5-a627-7bb34e9685e1",
      "name": "Build Delete Offer"
    },
    {
      "parameters": {
        "from": "+14155238886",
        "to": "={{ $('Get User1').first().json.telegram_id ? ('+' + $('Get User1').first().json.telegram_id.replace(/^\\+/, '')) : '' }}",
        "toWhatsapp": true,
        "message": "={{ $json.assistant_response }}",
        "options": {}
      },
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [
        2384,
        1424
      ],
      "id": "257e97ef-998f-4662-94a4-df0d528a9408",
      "name": "Send Reply - Delete Confirmation"
    }
  ],
  "connections": {
    "ARA Main Agent": {
      "main": [
        [
          {
            "node": "Extract Pending Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Model": {
      "ai_languageModel": [
        [
          {
            "node": "Extract Memories",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Search Memory Tool": {
      "ai_tool": [
        [
          {
            "node": "ARA Main Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Extract Memories": {
      "main": [
        [
          {
            "node": "Validate Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Ended?": {
      "main": [
        [],
        [
          {
            "node": "Generate Session Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [],
        [
          {
            "node": "Within 30 days?1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Within 30 days?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Manager": {
      "main": [
        [
          {
            "node": "Continue Session",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Session": {
      "main": [
        [
          {
            "node": "Fetch Session History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Session": {
      "main": [
        [
          {
            "node": "Fetch Session History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Session History": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sort": {
      "main": [
        [
          {
            "node": "Session Manager",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get User Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Previous Conversation": {
      "main": [
        [
          {
            "node": "Sort",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Memories": {
      "main": [
        [
          {
            "node": "Get Relevant Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait for Memory & Session": {
      "main": [
        [
          {
            "node": "Get ARA Brain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context with Memory": {
      "main": [
        [
          {
            "node": "Get Latest Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Within 30 days?": {
      "main": [
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User1": {
      "main": [
        [
          {
            "node": "Check Time Zone",
            "type": "main",
            "index": 0
          },
          {
            "node": "Log Incoming Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Memories1": {
      "main": [
        [
          {
            "node": "Has Memories?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Memories?1": {
      "main": [
        [
          {
            "node": "Save Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Session Summary1": {
      "main": [
        [
          {
            "node": "Save Session Summary1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Conversation": {
      "main": [
        [
          {
            "node": "Session Ended?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Memories": {
      "main": [
        [
          {
            "node": "Prepare Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "ARA Main Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Twilio Webhook": {
      "main": [
        [
          {
            "node": "Prepare Incoming Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Within 30 days?1": {
      "main": [
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Previous Conversation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Incoming Message": {
      "main": [
        [
          {
            "node": "Ensure User Exist",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Free User Onboarding": {
      "main": [
        [
          {
            "node": "Extract Pending Action1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure User Exist": {
      "main": [
        [
          {
            "node": "Get User1",
            "type": "main",
            "index": 0
          },
          {
            "node": "New User?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply": {
      "main": [
        [
          {
            "node": "Extract Memories",
            "type": "main",
            "index": 0
          },
          {
            "node": "Update Conversation",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get Latest Conversation": {
      "main": [
        [
          {
            "node": "ARA Main Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Pending Action": {
      "main": [
        [
          {
            "node": "Prepare Reply (Fail-Safe)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Mixed-Offer Override",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Confirmed Actions": {
      "main": [
        [
          {
            "node": "Route Actions Switch2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Relevant Memories": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get ARA Brain": {
      "main": [
        [
          {
            "node": "Format Brain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Brain": {
      "main": [
        [
          {
            "node": "Format Context with Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Time Zone": {
      "main": [
        [
          {
            "node": "Get Previous Conversation1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Previous Conversation1": {
      "main": [
        [
          {
            "node": "Sort1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sort1": {
      "main": [
        [
          {
            "node": "Session Manager1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get User Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get ARA Brain1": {
      "main": [
        [
          {
            "node": "Format Brain1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Brain1": {
      "main": [
        [
          {
            "node": "Format Context with Memory1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Context with Memory1": {
      "main": [
        [
          {
            "node": "Get Latest Conversation1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Latest Conversation1": {
      "main": [
        [
          {
            "node": "Free User Onboarding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Manager1": {
      "main": [
        [
          {
            "node": "Continue Session1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create New Session1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Session1": {
      "main": [
        [
          {
            "node": "Fetch Session History2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Continue Session1": {
      "main": [
        [
          {
            "node": "Fetch Session History2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Session History2": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User Memories1": {
      "main": [
        [
          {
            "node": "Get Relevant Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Relevant Memories1": {
      "main": [
        [
          {
            "node": "Wait for Memory & Session1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Wait for Memory & Session1": {
      "main": [
        [
          {
            "node": "Get ARA Brain1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Extract Memories1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Extract Memories1": {
      "main": [
        [
          {
            "node": "Validate Memories1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Ended?1": {
      "main": [
        [],
        [
          {
            "node": "Generate Session Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Memories": {
      "main": [
        [
          {
            "node": "Has Memories?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Memories?": {
      "main": [
        [
          {
            "node": "Save Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Session Summary": {
      "main": [
        [
          {
            "node": "Save Session Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Conversation1": {
      "main": [
        [
          {
            "node": "Session Ended?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Memories1": {
      "main": [
        [
          {
            "node": "Prepare Memories",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply1": {
      "main": [
        [
          {
            "node": "Extract Memories1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Update Conversation1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Pending Action1": {
      "main": [
        [
          {
            "node": "Route Confirmed Actions1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Reply (Fail-Safe)1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Confirmed Actions1": {
      "main": [
        [
          {
            "node": "Route Actions Switch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Actions Switch1": {
      "main": [
        [
          {
            "node": "Create Reminder1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Delete Reminder1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get User name1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Timezone1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "PG ‚Äì Update user preferences1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User name": {
      "main": [
        [
          {
            "node": "Escalate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get User name1": {
      "main": [
        [
          {
            "node": "Escalate1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Escalate": {
      "main": [
        [
          {
            "node": "Create Escalation Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Escalate1": {
      "main": [
        [
          {
            "node": "Create Escalation Log1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "New User?": {
      "main": [
        [],
        [
          {
            "node": "Send 1st Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Reply (Fail-Safe)": {
      "main": [
        [
          {
            "node": "Send Reply",
            "type": "main",
            "index": 0
          },
          {
            "node": "IF Fallback Used?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Reminder": {
      "main": [
        [
          {
            "node": "Log Reminder Created",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Memories1": {
      "main": [
        [
          {
            "node": "Log Memory Extracted",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Fallback Used?": {
      "main": [
        [
          {
            "node": "log Main Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Reply (Fail-Safe)1": {
      "main": [
        [
          {
            "node": "IF Fallback Used?1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send Reply1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Fallback Used?1": {
      "main": [
        [
          {
            "node": "log Main Fallback1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Memories": {
      "main": [
        [
          {
            "node": "Log Memory Extracted1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sanitise Reminder Topic": {
      "main": [
        [
          {
            "node": "Create Reminder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mixed-Offer Override": {
      "main": [
        [
          {
            "node": "Route Confirmed Actions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "ARA Main Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "If ALL?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If ALL?": {
      "main": [
        [
          {
            "node": "Delete ALL",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Delete Reminder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Explode Reminder": {
      "main": [
        [
          {
            "node": "Sanitise Reminder Topic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route Actions Switch2": {
      "main": [
        [
          {
            "node": "Explode Reminder",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "List Reminders",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "List Reminders",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get User name",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Update Timezone",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "PG ‚Äì Update user preferences",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List Reminders": {
      "main": [
        [
          {
            "node": "IF Reminder List?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Reminder List?": {
      "main": [
        [
          {
            "node": "Format Reminder List Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Delete Offer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Reminder List Message": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Send Reply - Reminder List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Reply - Reminder List": {
      "main": [
        [
          {
            "node": "Update Conversation2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Delete Offer": {
      "main": [
        [
          {
            "node": "Send Reply - Delete Confirmation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true
  }
}
